import { UserImporterOptions, ImportCandidate } from 'ipfs-unixfs-importer';
import * as ipfs_unixfs_importer_types_src_types from 'ipfs-unixfs-importer/types/src/types';
import * as Web3 from 'web3';
import Web3__default from 'web3';
import * as BN from 'bn.js';
import { AbiItem } from 'web3-utils';
import * as axios from 'axios';
import { AxiosResponse, AxiosRequestConfig, AxiosError } from 'axios';
import FormData from 'form-data';
import Wallet from 'ethereumjs-wallet';
import { HttpProvider, AbstractProvider, Log, TransactionReceipt } from 'web3-core';
import abiDecoder from 'abi-decoder';
import { Hedgehog } from '@audius/hedgehog';
import { EIP712TypedData } from 'eth-sig-util';

declare type Content = ReadableStream | Buffer | string;
interface ImageHasher {
    options: UserImporterOptions;
    content: ImportCandidate;
}
interface NonImageHasher {
    options: UserImporterOptions;
    content: Uint8Array;
}
interface HashedImage {
    path: string | undefined;
    cid: string;
    size: number;
}

type ContractABI = {
  abi: AbiItem[]
  contractName: string
}

declare class Utils {
    static importDataContractABI(pathStr: string): ContractABI;
    static importEthContractABI(pathStr: string): ContractABI;
    static utf8ToHex(utf8Str: string): string;
    static padRight(hexStr: string, size: number): string;
    static hexToUtf8(hexStr: string): string;
    static keccak256(utf8Str: string): string;
    static isBN(number: number | string): boolean;
    static toBN(number: number, base?: number): BN;
    static BN(): typeof BN;
    static checkStrLen(str: string, maxLen: number, minLen?: number): void;
    static wait(milliseconds: number): Promise<void>;
    static isFQDN(url: string): boolean;
    static isHttps(url: string): boolean;
    static isHealthy(url: string): Promise<any>;
    static formatOptionalMultihash(multihash: string): string;
    static decodeMultihash(multihash: string): {
        digest: string;
        hashFn: number;
        size: number;
    };
    /**
     * Given a digest value (written on chain, obtained through AudiusABIDecoder.decodeMethod),
     * convert back to a IFPS CIDv0
     * @param multihashDigest digest value from decodeMultihash
     * @returns String CID value
     */
    static encodeMultihash(multihashDigest: string): string;
    static parseDataFromResponse(response: AxiosResponse): any;
    static configureWeb3(web3Provider: string, chainNetworkId: string, requiresAccount?: boolean): Promise<false | Web3.default>;
    static get zeroAddress(): string;
    static isZeroAddress(address: string): boolean;
    static makeUuid(): string;
    /**
     * Decodes a string id into an int. Returns null if an invalid ID.
     */
    static decodeHashId(id: string): number | null;
    /**
     * Encodes an int to a string based hashid
     */
    static encodeHashId(id: number | null): string | null;
    /**
     * If `promise` responds before `timeoutMs`,
     * this function returns its response; else rejects with `timeoutMessage`
     */
    static racePromiseWithTimeout(promise: Promise<void>, timeoutMs: number, timeoutMessage: string): Promise<unknown>;
    static fileHasher: {
        convertNanosToMillis(nanoSeconds: bigint): bigint;
        initImageHasher(content: ipfs_unixfs_importer_types_src_types.ImportCandidate, options: ipfs_unixfs_importer_types_src_types.UserImporterOptions): ImageHasher;
        initNonImageHasher(content: Uint8Array, options: ipfs_unixfs_importer_types_src_types.UserImporterOptions): NonImageHasher;
        convertToBuffer(content: Content, logger: any): Promise<Buffer>;
        hashNonImages(content: Uint8Array, options?: ipfs_unixfs_importer_types_src_types.UserImporterOptions): Promise<string>;
        hashImages(content: ipfs_unixfs_importer_types_src_types.ImportCandidate, options?: ipfs_unixfs_importer_types_src_types.UserImporterOptions): Promise<HashedImage[]>;
        generateNonImageCid(content: Content, logger?: any): Promise<string>;
        generateImageCids(content: ipfs_unixfs_importer_types_src_types.ImportCandidate, logger?: any): Promise<HashedImage[]>;
    };
}

declare global {
    interface Window {
        grecaptcha: {
            ready: (callback: () => void) => Promise<void>;
            execute: (siteKey: string, config: {
                action: string;
            }) => Promise<string>;
        };
    }
}
interface CaptchaConfig {
    siteKey: string;
    serviceKey: string;
}
declare class Captcha {
    siteKey: string;
    serviceKey: string;
    constructor({ siteKey, serviceKey }: CaptchaConfig);
    /**
     * Intended to be called by clients. Will generate a token used to calculate recaptcha score.
     * @param action name for this "action" for grouping
     */
    generate(action: string): Promise<string>;
    /**
     * Intended to be called by services. According to recaptcha v3 docs:
     * A score of 1.0 is very likely a good interaction, 0.0 is very likely a bot
     * @param token
     * @param minScore score must be >= minScore to be ok
     * @returns
     *    {boolean | null} ok - whether score > minScore (false if something went wrong)
     *    {number | null} score - the raw score [0, 1] (or null if a score was not computed)
     */
    verify(token: string, minScore?: number): Promise<{
        score: any;
        ok: boolean;
        hostname: any;
    }>;
}

interface ContractMethod {
    arguments: string[];
    estimateGas: (config: {
        from: Wallet | string | undefined;
        gas: number | undefined;
    }) => Promise<number>;
    _method: {
        name: string;
        inputs: Array<{
            type: string;
        }>;
    };
    encodeABI: () => string;
    send: <Tx>(config: {
        from: Wallet | undefined;
        gas: number;
        gasPrice?: number;
    }) => Tx;
}

declare type Providers = [
    HttpProvider,
    ...Array<HttpProvider | AbstractProvider>
];

declare type SchemaConfig = {
    schema: {
        definitions: Record<string, {
            required: string[];
            properties: Record<string, {
                default: unknown;
            }>;
        } | {}>;
    };
    baseDefinition: string;
    validate?: (obj: Record<string, unknown>) => void;
};
declare type Schemas = {
    TrackSchema: SchemaConfig;
    UserSchema: SchemaConfig;
};

declare type Web3Config = {
    ownerWallet: Wallet;
    providers: Providers;
    useExternalWeb3: boolean;
    internalWeb3Config: {
        web3ProviderEndpoints: string[];
        privateKey: string;
    };
    externalWeb3Config: {
        web3: Web3__default;
        ownerWallet: Wallet;
    };
};

declare class AudiusABIDecoder {
    static decodeMethod(contractName: string, encodedABI: string): abiDecoder.DecodedMethod;
    static decodeLogs(_: string, logs: Log[]): abiDecoder.DecodedLog;
}

declare type TimeFrame = 'day' | 'week' | 'month' | 'year' | 'millennium';

declare type Data = Record<string, unknown>;
declare type RelayTransaction = {
    resp: {
        txHash: string;
        txParams: {
            data: string;
            gasLimit: string;
            gasPrice: number;
            nonce: string;
            to: string;
            value: string;
        };
    };
};
declare type TransactionData = {
    recentBlockhash: string;
    secpInstruction?: {
        publicKey: string;
        message: string;
        signature: any;
        recoveryId: number;
    };
    instruction: {
        keys: Array<{
            pubkey: string;
            isSigner?: boolean;
            isWritable?: boolean;
        }>;
        programId: string;
        data: Record<string, unknown>;
    };
};
declare type AttestationResult = {
    status: string;
    userId: string;
    challengeId: string;
    amount: number;
    source: string;
    specifier: string;
    error?: string;
    phase?: string;
    reason?: string;
};
declare class IdentityService {
    identityServiceEndpoint: string;
    captcha: Captcha;
    web3Manager: Web3Manager | null;
    constructor(identityServiceEndpoint: string, captcha: Captcha);
    setWeb3Manager(web3Manager: Web3Manager): void;
    getFn(params: {
        lookupKey: string;
        username: string;
    }): Promise<{
        iv: string;
        cipherText: string;
    }>;
    setAuthFn(obj: Data): Promise<unknown>;
    setUserFn(obj: Data & {
        token?: string;
    }): Promise<unknown>;
    getUserEvents(walletAddress: string): Promise<unknown>;
    sendRecoveryInfo(obj: Record<string, unknown>): Promise<unknown>;
    /**
     * Check if an email address has been previously registered.
     */
    checkIfEmailRegistered(email: string): Promise<{
        exists: boolean;
    }>;
    getUserEmail(): Promise<{
        email: string | undefined | null;
    }>;
    /**
     * Associates a user with a twitter uuid.
     * @param uuid from the Twitter API
     * @param userId
     * @param handle User handle
     */
    associateTwitterUser(uuid: string, userId: number, handle: string): Promise<unknown>;
    /**
     * Associates a user with an instagram uuid.
     * @param uuid from the Instagram API
     * @param userId
     * @param handle
     */
    associateInstagramUser(uuid: string, userId: number, handle: string): Promise<unknown>;
    /**
     * Logs a track listen for a given user id.
     * @param trackId
     * @param userId
     * @param listenerAddress if logging this listen on behalf of another IP address, pass through here
     * @param signatureData if logging this listen via a 3p service, a signed piece of data proving authenticity
     */
    logTrackListen(trackId: number, userId: number, listenerAddress: string, signatureData?: {
        signature: string;
        timestamp: string;
    }, solanaListen?: boolean): Promise<unknown>;
    /**
     * Return listen history tracks for a given user id.
     * @param userId - User ID
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */
    getListenHistoryTracks(userId: number, limit?: number, offset?: number): Promise<unknown>;
    /**
     * Looks up a Twitter account by handle.
     * @returns twitter API response.
     */
    lookupTwitterHandle(handle: string): Promise<unknown>;
    /**
     * Gets tracks trending on Audius.
     * @param timeFrame one of day, week, month, or year
     * @param idsArray track ids
     * @param limit
     * @param offset
     */
    getTrendingTracks(timeFrame?: string | null, idsArray?: number[] | null, limit?: number | null, offset?: number | null): Promise<{
        listenCounts: Array<{
            trackId: number;
            listens: number;
        }>;
    }>;
    /**
     * Gets listens for tracks bucketted by timeFrame.
     * @param timeFrame one of day, week, month, or year
     * @param idsArray track ids
     * @param startTime parseable by Date.parse
     * @param endTime parseable by Date.parse
     * @param limit
     * @param offset
     */
    getTrackListens(timeFrame?: TimeFrame | null, idsArray?: number[] | null, startTime?: string | null, endTime?: string | null, limit?: number | null, offset?: number | null): Promise<{
        bucket: Array<{
            trackId: number;
            date: string;
            listens: number;
        }>;
    }>;
    createUserRecord(email: string, walletAddress: string): Promise<unknown>;
    relay(contractRegistryKey: string | null | undefined, contractAddress: string | null | undefined, senderAddress: string, encodedABI: string, gasLimit: number): Promise<{
        receipt: TransactionReceipt;
    }>;
    ethRelay(contractAddress: string, senderAddress: Wallet | string, encodedABI: string, gasLimit: string): Promise<RelayTransaction>;
    wormholeRelay({ senderAddress, permit, transferTokens }: {
        senderAddress: string;
        permit: string;
        transferTokens: string[];
    }): Promise<unknown>;
    /**
     * Gets the correct wallet that will relay a txn for `senderAddress`
     * @param senderAddress wallet
     */
    getEthRelayer(senderAddress: string): Promise<unknown>;
    getRandomFeePayer(): Promise<unknown>;
    solanaRelay(transactionData: TransactionData): Promise<unknown>;
    solanaRelayRaw(transactionData: TransactionData): Promise<unknown>;
    getMinimumDelegationAmount(wallet: string): Promise<unknown>;
    updateMinimumDelegationAmount(wallet: string, minimumDelegationAmount: number, signedData: AxiosRequestConfig['headers']): Promise<unknown>;
    /**
     * Sends an attestation result to identity.
     *
     */
    sendAttestationResult(data: AttestationResult): Promise<unknown>;
    _makeRequest<T = unknown>(axiosRequestObj: AxiosRequestConfig): Promise<T>;
    _signData(): Promise<{
        "Encoded-Data-Message": string;
        "Encoded-Data-Signature": string | undefined;
    } | {
        "Encoded-Data-Message"?: undefined;
        "Encoded-Data-Signature"?: undefined;
    }>;
}

/** singleton class to be instantiated and persisted with every AudiusLibs */
declare class Web3Manager {
    web3Config: Web3Config;
    isServer: boolean;
    identityService: IdentityService;
    hedgehog: Hedgehog;
    AudiusABIDecoder: typeof AudiusABIDecoder;
    web3: Web3__default | undefined;
    useExternalWeb3: boolean | undefined;
    ownerWallet: Wallet;
    constructor(web3Config: Web3Config, identityService: IdentityService, hedgehog: Hedgehog, isServer: boolean);
    init(): Promise<void>;
    getWeb3(): Web3__default;
    setWeb3(web3: Web3__default): void;
    getWalletAddress(): any;
    setOwnerWallet(ownerWallet: Wallet): void;
    web3IsExternal(): boolean | undefined;
    getOwnerWalletPrivateKey(): Buffer;
    /**
     * Signs provided string data (should be timestamped).
     * @param data
     */
    sign(data: string): Promise<string | undefined>;
    /**
     * Given a data payload and signature, verifies that signature is valid, and returns
     * Ethereum wallet address used to sign data.
     * @param data information that was signed
     * @param signature hex-formatted signature of data generated by web3 personalSign method
     */
    verifySignature(data: string, signature: string): Promise<string>;
    signTypedData(signatureData: EIP712TypedData): Promise<unknown>;
    sendTransaction(contractMethod: ContractMethod, contractRegistryKey?: string | null, contractAddress?: string | null, txRetries?: number, txGasLimit?: number): Promise<TransactionReceipt>;
    provider(url: string, timeout: number): HttpProvider;
    monkeyPatchProvider(httpProvider: HttpProvider): HttpProvider;
}

declare type CurrentUser = {
    user_id: string;
    wallet: string;
    blocknumber: number;
    track_blocknumber: number;
    creator_node_endpoint: string;
    is_creator: boolean;
};
/**
 * Singleton class to store the current user if initialized.
 * Some instances of AudiusLibs and services require a current user to
 * return valid queries, e.g. requesting the a discprov to return a reposted track.
 */
declare class UserStateManager {
    currentUser: CurrentUser | null;
    constructor();
    /**
     * Sets this.currentUser with currentUser
     * @param {Object} currentUser fields to override this.currentUser with
     */
    setCurrentUser(currentUser: CurrentUser): void;
    getCurrentUser(): CurrentUser | null;
    getCurrentUserId(): string | null;
    clearUser(): void;
}

declare type Metadata = {
    track_segments: unknown;
    download?: {
        is_downloadable: boolean;
        cid: string;
    };
    cover_art_sizes: string;
};
declare type ProgressCB = (loaded: number, total: number) => void;
declare type MonitoringCallbacks = {
    request?: Function;
    healthCheck?: Function;
};
declare type ClockValueRequestConfig = {
    user: CurrentUser;
    endpoint: string;
    timeout?: number;
};
declare type FileUploadResponse = {
    data: {
        uuid: string;
    };
    error: Error;
};
declare class CreatorNode {
    /**
     * Pulls off the primary creator node from a creator node endpoint string.
     * @param endpoints user.creator_node_endpoint
     */
    static getPrimary(endpoints: string): string | undefined;
    /**
     * Pulls off the secondary creator nodes from a creator node endpoint string.
     * @param endpoints user.creator_node_endpoint
     */
    static getSecondaries(endpoints: string): string[];
    /**
     * Pulls the user's creator nodes out of the list
     * @param endpoints user.creator_node_endpoint
     */
    static getEndpoints(endpoints: string): string[];
    /**
     * Builds the creator_node_endpoint value off of a primary and secondaries list
     * @param primary the primary endpoint
     * @param secondaries a list of secondary endpoints
     */
    static buildEndpoint(primary: string, secondaries: string[]): string;
    /**
     * Pulls off the user's clock value from a creator node endpoint and the user's wallet address.
     * @param endpoint content node endpoint
     * @param wallet user wallet address
     * @param timeout max time alloted for clock request
     * @param params optional query string params
     */
    static getClockValue(endpoint: string, wallet: string, timeout: number, params?: Record<string, string>): Promise<any>;
    /**
     * Checks if a download is available from provided creator node endpoints
     * @param endpoints creator node endpoints
     * @param trackId
     */
    static checkIfDownloadAvailable(endpoints: string, trackId: number): Promise<any>;
    web3Manager: Web3Manager;
    creatorNodeEndpoint: string;
    isServer: boolean;
    userStateManager: UserStateManager;
    lazyConnect: boolean;
    schemas: Schemas;
    passList: Set<string> | null;
    blockList: Set<string> | null;
    monitoringCallbacks: MonitoringCallbacks;
    connected: boolean;
    connecting: boolean;
    authToken: null;
    maxBlockNumber: number;
    /**
     * Constructs a service class for a creator node
     * @param web3Manager
     * @param creatorNodeEndpoint fallback creator node endpoint (to be deprecated)
     * @param isServer
     * @param userStateManager  singleton UserStateManager instance
     * @param lazyConnect whether or not to lazy connect (sign in) on load
     * @param schemas
     * @param passList whether or not to include only specified nodes (default null)
     * @param blockList whether or not to exclude any nodes (default null)
     * @param monitoringCallbacks callbacks to be invoked with metrics from requests sent to a service
     */
    constructor(web3Manager: Web3Manager, creatorNodeEndpoint: string, isServer: boolean, userStateManager: UserStateManager, lazyConnect: boolean, schemas: Schemas, passList?: Set<string> | null, blockList?: Set<string> | null, monitoringCallbacks?: MonitoringCallbacks);
    init(): Promise<void>;
    /** Establishes a connection to a content node endpoint */
    connect(): Promise<void>;
    /** Checks if connected, otherwise establishing a connection */
    ensureConnected(): Promise<void>;
    getEndpoint(): string;
    /**
     * Switch from one creatorNodeEndpoint to another including logging out from the old node, updating the endpoint and logging into new node */
    setEndpoint(creatorNodeEndpoint: string): Promise<void>;
    /** Clear all connection state in this class by deleting authToken and setting 'connected' = false */
    clearConnection(): void;
    /**
     * Uploads creator content to a creator node
     * @param metadata the creator metadata
     */
    uploadCreatorContent(metadata: Metadata, blockNumber?: null): Promise<any>;
    /**
     * Creates a creator on the creator node, associating user id with file content
     * @param audiusUserId returned by user creation on-blockchain
     * @param metadataFileUUID unique ID for metadata file
     * @param blockNumber
     */
    associateCreator(audiusUserId: number, metadataFileUUID: string, blockNumber: number): Promise<void>;
    /**
     * Uploads a track (including audio and image content) to a creator node
     * @param trackFile the audio content
     * @param coverArtFile the image content
     * @param metadata the metadata for the track
     * @param onProgress an optional on progress callback
     */
    uploadTrackContent(trackFile: File, coverArtFile: File, metadata: Metadata, onProgress?: ProgressCB): Promise<any>;
    /**
     * Uploads track metadata to a creator node
     * The metadata object must include a `track_id` field or a
     * source file must be provided (returned from uploading track content).
     * @param metadata
     * @param sourceFile
     */
    uploadTrackMetadata(metadata: Metadata, sourceFile: string): Promise<any>;
    /**
     * Creates a track on the content node, associating track id with file content
     * @param audiusTrackId returned by track creation on-blockchain
     * @param metadataFileUUID unique ID for metadata file
     * @param blockNumber
     * @param transcodedTrackUUID the CID for the transcoded master if this is a first-time upload
     */
    associateTrack(audiusTrackId: number, metadataFileUUID: string, blockNumber: number, transcodedTrackUUID: string): Promise<void>;
    /**
     * Uploads an image to the connected content node
     * @param file image to upload
     * @param onProgress called with loaded bytes and total bytes
     * @param timeoutMs timeout in ms axios request to upload file to CN will wait
     * @return response body
     */
    uploadImage(file: File, square: boolean | undefined, onProgress: ProgressCB, timeoutMs?: number | null): Promise<{
        uuid: string;
    }>;
    /**
     * @param file track to upload
     * @param onProgress called with loaded bytes and total bytes
     * @return response body
     */
    uploadTrackAudio(file: File, onProgress: ProgressCB): Promise<any>;
    handleAsyncTrackUpload(file: File, onProgress: ProgressCB): Promise<any>;
    pollProcessingStatus(uuid: string): Promise<any>;
    /**
     * Gets the task progress given the task type and uuid associated with the task
     * @param uuid the uuid of the track transcoding task
     * @returns the status, and the success or failed response if the task is complete
     */
    getTrackContentProcessingStatus(uuid: string): Promise<any>;
    /**
     * Given a particular endpoint to a creator node, check whether
     * this user has a sync in progress on that node.
     * @param endpoint
     * @param timeout ms
     */
    getSyncStatus(endpoint: string, timeout?: number | null): Promise<{
        status: any;
        userBlockNumber: number;
        trackBlockNumber: number;
        isBehind: boolean;
        isConfigured: boolean;
    }>;
    /**
     * Syncs a secondary creator node for a given user
     * @param secondary
     * @param primary specific primary to use
     * @param immediate whether or not this is a blocking request and handled right away
     * @param validate whether or not to validate the provided secondary is valid
     */
    syncSecondary(secondary: string, primary?: string, immediate?: boolean, validate?: boolean): Promise<axios.AxiosResponse<any> | undefined>;
    /**
     * Signs up a creator node user with a wallet address
     * @param walletAddress
     */
    _signupNodeUser(walletAddress: string): Promise<void>;
    /**
     * Logs user into cnode, if not already logged in.
     * Requests a challenge from cnode, sends signed challenge response to cn.
     * If successful, receive and set authToken locally.
     */
    _loginNodeUser(): Promise<void>;
    /** Calls logout on the content node. Needs an authToken for this since logout is an authenticated endpoint */
    _logoutNodeUser(): Promise<void>;
    /**
     * Gets and returns the clock values across the replica set for the wallet in userStateManager.
     * @returns Array of objects with the structure:
     *
     * {
     *  type: 'primary' or 'secondary',
     *  endpoint: <Content Node endpoint>,
     *  clockValue: clock value (should be an integer) or null
     * }
     *
     * 'clockValue' may be null if the request to fetch the clock value fails
     */
    getClockValuesFromReplicaSet(): Promise<{
        type: string;
        endpoint: string;
        clockValue: any;
    }[] | undefined>;
    /**
     * Wrapper around getClockValue() to return either a proper or null clock value
     * @param {Object} param
     * @param {Object} param.user user metadata object from userStateManager
     * @param {string} param.endpoint the Content Node endpoint to check the clock value for
     * @param {number?} [param.timeout=1000] the max time allotted for a clock request; defaulted to 1000ms
     */
    _clockValueRequest({ user, endpoint, timeout }: ClockValueRequestConfig): Promise<{
        type: string;
        endpoint: string;
        clockValue: any;
    }>;
    /**
     * Makes an axios request to the connected creator node.
     * @param requiresConnection if set, the currently configured creator node
     * is connected to before the request is made.
     * @return response body
     */
    _makeRequest(axiosRequestObj: AxiosRequestConfig, requiresConnection?: boolean): Promise<any>;
    /**
     * Create headers and formData for file upload
     * @param file the file to upload
     * @returns headers and formData in an object
     */
    createFormDataAndUploadHeaders(file: File, extraFormDataOptions?: Record<string, unknown>): {
        headers: Record<string, string | null>;
        formData: FormData;
    };
    /**
     * Uploads a file to the connected creator node.
     * @param file
     * @param route route to handle upload (image_upload, track_upload, etc.)
     * @param onProgress called with loaded bytes and total bytes
     * @param extraFormDataOptions extra FormData fields passed to the upload
     * @param retries max number of attempts made for axios request to upload file to CN before erroring
     * @param timeoutMs timeout in ms axios request to upload file to CN will wait
     */
    _uploadFile(file: File, route: string, onProgress?: ProgressCB, extraFormDataOptions?: Record<string, unknown>, retries?: number, timeoutMs?: number | null): Promise<FileUploadResponse>;
    _handleErrorHelper(e: Error | AxiosError, requestUrl?: string, requestId?: string | null): Promise<void>;
}

type Options = { skipRollover: boolean }

declare class SanityChecks {
  libs: any
  options: Options

  constructor(libsInstance: any, options?: Options): void
  async run(creatorNodeWhitelist: string[] | null): Promise<void>
}

export { CreatorNode, SanityChecks, Utils };
