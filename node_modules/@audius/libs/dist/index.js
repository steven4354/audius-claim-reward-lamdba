'use strict';

var require$$0$3 = require('web3');
var bs58$2 = require('bs58');
var axios$3 = require('axios');
var Hashids = require('hashids/cjs');
var util = require('util');
var require$$0$4 = require('lodash');
var ipfsUnixfsImporter = require('ipfs-unixfs-importer');
var fs = require('fs');
var process = require('process');
var stream = require('stream');
var assert = require('assert');
var FormData = require('form-data');
var require$$1$1u = require('ethereumjs-util');
var solidity = require('@ethersproject/solidity');
var semver = require('semver');
var ethereumjsTx = require('ethereumjs-tx');
var retry$2 = require('async-retry');
var AudiusData = require('@audius/anchor-audius-data');
var anchor$1 = require('@project-serum/anchor');
var require$$1$1v = require('@solana/web3.js');
var require$$3$1 = require('keccak256');
var require$$4$2 = require('secp256k1');
var sigUtil$2 = require('eth-sig-util');
var abiDecoder = require('abi-decoder');
var EthereumWallet = require('ethereumjs-wallet');
var urlJoin$1 = require('proper-url-join');
var require$$0$5 = require('@solana/spl-token');
var require$$1$1w = require('borsh');
var require$$0$6 = require('buffer');
var hedgehog$1 = require('@audius/hedgehog');
var jsonschema = require('jsonschema');
var require$$2$3 = require('ethers/lib/utils');
var require$$3$2 = require('ethers/lib/index');
var require$$4$3 = require('@certusone/wormhole-sdk');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

function _mergeNamespaces(n, m) {
  m.forEach(function (e) {
    e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
      if (k !== 'default' && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  });
  return Object.freeze(n);
}

var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);
var bs58__default = /*#__PURE__*/_interopDefaultLegacy(bs58$2);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios$3);
var Hashids__default = /*#__PURE__*/_interopDefaultLegacy(Hashids);
var require$$0__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$0$4);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);
var FormData__default = /*#__PURE__*/_interopDefaultLegacy(FormData);
var require$$1__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$1$1u);
var semver__default = /*#__PURE__*/_interopDefaultLegacy(semver);
var retry__default = /*#__PURE__*/_interopDefaultLegacy(retry$2);
var AudiusData__namespace = /*#__PURE__*/_interopNamespace(AudiusData);
var AudiusData__default = /*#__PURE__*/_interopDefaultLegacy(AudiusData);
var anchor__default = /*#__PURE__*/_interopDefaultLegacy(anchor$1);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1$1v);
var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3$1);
var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4$2);
var sigUtil__default = /*#__PURE__*/_interopDefaultLegacy(sigUtil$2);
var abiDecoder__default = /*#__PURE__*/_interopDefaultLegacy(abiDecoder);
var EthereumWallet__default = /*#__PURE__*/_interopDefaultLegacy(EthereumWallet);
var urlJoin__default = /*#__PURE__*/_interopDefaultLegacy(urlJoin$1);
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$5);
var require$$1__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$1$1w);
var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$6);
var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2$3);
var require$$3__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$3$2);
var require$$4__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$4$3);

function _asyncIterator(iterable) {
  var method,
      async,
      sync,
      retry = 2;

  for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {
    if (async && null != (method = iterable[async])) return method.call(iterable);
    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
    async = "@@asyncIterator", sync = "@@iterator";
  }

  throw new TypeError("Object is not async iterable");
}

function AsyncFromSyncIterator(s) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
    var done = r.done;
    return Promise.resolve(r.value).then(function (value) {
      return {
        value: value,
        done: done
      };
    });
  }

  return AsyncFromSyncIterator = function (s) {
    this.s = s, this.n = s.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function () {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    return: function (value) {
      var ret = this.s.return;
      return void 0 === ret ? Promise.resolve({
        value: value,
        done: !0
      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
    },
    throw: function (value) {
      var thr = this.s.return;
      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(s);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _wrapRegExp() {
  _wrapRegExp = function (re, groups) {
    return new BabelRegExp(re, void 0, groups);
  };

  var _super = RegExp.prototype,
      _groups = new WeakMap();

  function BabelRegExp(re, flags, groups) {
    var _this = new RegExp(re, flags);

    return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);
  }

  function buildGroups(result, re) {
    var g = _groups.get(re);

    return Object.keys(g).reduce(function (groups, name) {
      return groups[name] = result[g[name]], groups;
    }, Object.create(null));
  }

  return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {
    var result = _super.exec.call(this, str);

    return result && (result.groups = buildGroups(result, this)), result;
  }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
    if ("string" == typeof substitution) {
      var groups = _groups.get(this);

      return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
        return "$" + groups[name];
      }));
    }

    if ("function" == typeof substitution) {
      var _this = this;

      return _super[Symbol.replace].call(this, str, function () {
        var args = arguments;
        return "object" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
      });
    }

    return _super[Symbol.replace].call(this, str, substitution);
  }, _wrapRegExp.apply(this, arguments);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };
  }

  return _get.apply(this, arguments);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function createModule(modulePath) {
	return {
		path: modulePath,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, base == null ? modulePath : base);
		}
	};
}

function commonjsRegister$1t (path, loader) {
	DYNAMIC_REQUIRE_LOADERS[path] = loader;
}

var DYNAMIC_REQUIRE_LOADERS = Object.create(null);
var DYNAMIC_REQUIRE_CACHE = Object.create(null);
var DYNAMIC_REQUIRE_SHORTS = Object.create(null);
var DEFAULT_PARENT_MODULE = {
	id: '<' + 'rollup>', exports: {}, parent: undefined, filename: null, loaded: false, children: [], paths: []
};
var CHECKED_EXTENSIONS = ['', '.js', '.json'];

function normalize (path) {
	path = path.replace(/\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/')
	  path = '/' + path;
	else if (path.length === 0)
	  path = '.';
	return path;
}

function join () {
	if (arguments.length === 0)
	  return '.';
	var joined;
	for (var i = 0; i < arguments.length; ++i) {
	  var arg = arguments[i];
	  if (arg.length > 0) {
		if (joined === undefined)
		  joined = arg;
		else
		  joined += '/' + arg;
	  }
	}
	if (joined === undefined)
	  return '.';

	return joined;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\'))
		return false;
	return true;
}

function dirname (path) {
  if (path.length === 0)
    return '.';

  var i = path.length - 1;
  while (i > 0) {
    var c = path.charCodeAt(i);
    if ((c === 47 || c === 92) && i !== path.length - 1)
      break;
    i--;
  }

  if (i > 0)
    return path.substr(0, i);

  if (path.chartCodeAt(0) === 47 || path.chartCodeAt(0) === 92)
    return path.charAt(0);

  return '.';
}

function commonjsResolveImpl (path, originalModuleDir, testCache) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '/';
	}
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = originalModuleDir ? normalize(originalModuleDir + '/' + path) : path;
		} else if (originalModuleDir) {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		} else {
			relPath = normalize(join('node_modules', path));
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < CHECKED_EXTENSIONS.length; extensionIndex++) {
			var resolvedPath = relPath + CHECKED_EXTENSIONS[extensionIndex];
			if (DYNAMIC_REQUIRE_CACHE[resolvedPath]) {
				return resolvedPath;
			}
			if (DYNAMIC_REQUIRE_SHORTS[resolvedPath]) {
			  return resolvedPath;
			}
			if (DYNAMIC_REQUIRE_LOADERS[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

function commonjsResolve (path, originalModuleDir) {
	var resolvedPath = commonjsResolveImpl(path, originalModuleDir);
	if (resolvedPath !== null) {
		return resolvedPath;
	}
	return require.resolve(path);
}

function commonjsRequire (path, originalModuleDir) {
	var resolvedPath = commonjsResolveImpl(path, originalModuleDir);
	if (resolvedPath !== null) {
    var cachedModule = DYNAMIC_REQUIRE_CACHE[resolvedPath];
    if (cachedModule) return cachedModule.exports;
    var shortTo = DYNAMIC_REQUIRE_SHORTS[resolvedPath];
    if (shortTo) {
      cachedModule = DYNAMIC_REQUIRE_CACHE[shortTo];
      if (cachedModule)
        return cachedModule.exports;
      resolvedPath = commonjsResolveImpl(shortTo, null);
    }
    var loader = DYNAMIC_REQUIRE_LOADERS[resolvedPath];
    if (loader) {
      DYNAMIC_REQUIRE_CACHE[resolvedPath] = cachedModule = {
        id: resolvedPath,
        filename: resolvedPath,
        path: dirname(resolvedPath),
        exports: {},
        parent: DEFAULT_PARENT_MODULE,
        loaded: false,
        children: [],
        paths: [],
        require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? cachedModule.path : base);
        }
      };
      try {
        loader.call(commonjsGlobal, cachedModule, cachedModule.exports);
      } catch (error) {
        delete DYNAMIC_REQUIRE_CACHE[resolvedPath];
        throw error;
      }
      cachedModule.loaded = true;
      return cachedModule.exports;
    }	}
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

commonjsRequire.cache = DYNAMIC_REQUIRE_CACHE;
commonjsRequire.resolve = commonjsResolve;

var src = createModule("/$$rollup_base$$/src");

var contractName$1s = "AdminUpgradeabilityProxy";
var abi$1s = [
	{
		constant: false,
		inputs: [
			{
				name: "newImplementation",
				type: "address"
			}
		],
		name: "upgradeTo",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newImplementation",
				type: "address"
			},
			{
				name: "data",
				type: "bytes"
			}
		],
		name: "upgradeToAndCall",
		outputs: [
		],
		payable: true,
		stateMutability: "payable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "implementation",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newAdmin",
				type: "address"
			}
		],
		name: "changeAdmin",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "admin",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_logic",
				type: "address"
			},
			{
				name: "_admin",
				type: "address"
			},
			{
				name: "_data",
				type: "bytes"
			}
		],
		payable: true,
		stateMutability: "payable",
		type: "constructor"
	},
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "previousAdmin",
				type: "address"
			},
			{
				indexed: false,
				name: "newAdmin",
				type: "address"
			}
		],
		name: "AdminChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "implementation",
				type: "address"
			}
		],
		name: "Upgraded",
		type: "event"
	}
];
var require$$1$1t = {
	contractName: contractName$1s,
	abi: abi$1s
};

const commonjsRegister$1s = commonjsRegister$1t;
commonjsRegister$1s("/$$rollup_base$$/data-contracts/ABIs/AdminUpgradeabilityProxy.json", function (module, exports) {
  module.exports = require$$1$1t;
});

var contractName$1r = "BaseAdminUpgradeabilityProxy";
var abi$1r = [
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "previousAdmin",
				type: "address"
			},
			{
				indexed: false,
				name: "newAdmin",
				type: "address"
			}
		],
		name: "AdminChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "implementation",
				type: "address"
			}
		],
		name: "Upgraded",
		type: "event"
	},
	{
		constant: false,
		inputs: [
		],
		name: "admin",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "implementation",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newAdmin",
				type: "address"
			}
		],
		name: "changeAdmin",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newImplementation",
				type: "address"
			}
		],
		name: "upgradeTo",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newImplementation",
				type: "address"
			},
			{
				name: "data",
				type: "bytes"
			}
		],
		name: "upgradeToAndCall",
		outputs: [
		],
		payable: true,
		stateMutability: "payable",
		type: "function"
	}
];
var require$$1$1s = {
	contractName: contractName$1r,
	abi: abi$1r
};

const commonjsRegister$1r = commonjsRegister$1t;
commonjsRegister$1r("/$$rollup_base$$/data-contracts/ABIs/BaseAdminUpgradeabilityProxy.json", function (module, exports) {
  module.exports = require$$1$1s;
});

var contractName$1q = "BaseUpgradeabilityProxy";
var abi$1q = [
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "implementation",
				type: "address"
			}
		],
		name: "Upgraded",
		type: "event"
	}
];
var require$$1$1r = {
	contractName: contractName$1q,
	abi: abi$1q
};

const commonjsRegister$1q = commonjsRegister$1t;
commonjsRegister$1q("/$$rollup_base$$/data-contracts/ABIs/BaseUpgradeabilityProxy.json", function (module, exports) {
  module.exports = require$$1$1r;
});

var contractName$1p = "DiscoveryProviderFactory";
var abi$1p = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			},
			{
				name: "_discoveryProviderStorageRegistryKey",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_id",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_wallet",
				type: "address"
			},
			{
				indexed: false,
				name: "_endpoint",
				type: "string"
			}
		],
		name: "NewDiscoveryProvider",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "getDiscoveryProvider",
		outputs: [
			{
				name: "wallet",
				type: "address"
			},
			{
				name: "endpoint",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getTotalNumberOfProviders",
		outputs: [
			{
				name: "total",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_endpoint",
				type: "string"
			}
		],
		name: "register",
		outputs: [
			{
				name: "discProvId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$1q = {
	contractName: contractName$1p,
	abi: abi$1p
};

const commonjsRegister$1p = commonjsRegister$1t;
commonjsRegister$1p("/$$rollup_base$$/data-contracts/ABIs/DiscoveryProviderFactory.json", function (module, exports) {
  module.exports = require$$1$1q;
});

var contractName$1o = "DiscoveryProviderFactoryInterface";
var abi$1o = [
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "getDiscoveryProvider",
		outputs: [
			{
				name: "wallet",
				type: "address"
			},
			{
				name: "endpoint",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getTotalNumberOfProviders",
		outputs: [
			{
				name: "total",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_endpoint",
				type: "string"
			}
		],
		name: "register",
		outputs: [
			{
				name: "discProvId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$1p = {
	contractName: contractName$1o,
	abi: abi$1o
};

const commonjsRegister$1o = commonjsRegister$1t;
commonjsRegister$1o("/$$rollup_base$$/data-contracts/ABIs/DiscoveryProviderFactoryInterface.json", function (module, exports) {
  module.exports = require$$1$1p;
});

var contractName$1n = "DiscoveryProviderStorage";
var abi$1n = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		name: "discProvEndpoints",
		outputs: [
			{
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		name: "discProvWallets",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "getDiscoveryProvider",
		outputs: [
			{
				name: "wallet",
				type: "address"
			},
			{
				name: "endpoint",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getTotalNumberOfProviders",
		outputs: [
			{
				name: "total",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_wallet",
				type: "address"
			},
			{
				name: "_endpoint",
				type: "string"
			}
		],
		name: "register",
		outputs: [
			{
				name: "id",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$1o = {
	contractName: contractName$1n,
	abi: abi$1n
};

const commonjsRegister$1n = commonjsRegister$1t;
commonjsRegister$1n("/$$rollup_base$$/data-contracts/ABIs/DiscoveryProviderStorage.json", function (module, exports) {
  module.exports = require$$1$1o;
});

var contractName$1m = "DiscoveryProviderStorageInterface";
var abi$1m = [
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "getDiscoveryProvider",
		outputs: [
			{
				name: "wallet",
				type: "address"
			},
			{
				name: "endpoint",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getTotalNumberOfProviders",
		outputs: [
			{
				name: "total",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_wallet",
				type: "address"
			},
			{
				name: "_endpoint",
				type: "string"
			}
		],
		name: "register",
		outputs: [
			{
				name: "id",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$1n = {
	contractName: contractName$1m,
	abi: abi$1m
};

const commonjsRegister$1m = commonjsRegister$1t;
commonjsRegister$1m("/$$rollup_base$$/data-contracts/ABIs/DiscoveryProviderStorageInterface.json", function (module, exports) {
  module.exports = require$$1$1n;
});

var contractName$1l = "ECDSA";
var abi$1l = [
];
var require$$1$1m = {
	contractName: contractName$1l,
	abi: abi$1l
};

const commonjsRegister$1l = commonjsRegister$1t;
commonjsRegister$1l("/$$rollup_base$$/data-contracts/ABIs/ECDSA.json", function (module, exports) {
  module.exports = require$$1$1m;
});

var contractName$1k = "Initializable";
var abi$1k = [
];
var require$$1$1l = {
	contractName: contractName$1k,
	abi: abi$1k
};

const commonjsRegister$1k = commonjsRegister$1t;
commonjsRegister$1k("/$$rollup_base$$/data-contracts/ABIs/Initializable.json", function (module, exports) {
  module.exports = require$$1$1l;
});

var contractName$1j = "IPLDBlacklistFactory";
var abi$1j = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			},
			{
				name: "_networkId",
				type: "uint256"
			},
			{
				name: "_verifierAddress",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_multihashDigest",
				type: "bytes32"
			}
		],
		name: "AddIPLDToBlacklist",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_multihashDigest",
				type: "bytes32"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "addIPLDToBlacklist",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$1k = {
	contractName: contractName$1j,
	abi: abi$1j
};

const commonjsRegister$1j = commonjsRegister$1t;
commonjsRegister$1j("/$$rollup_base$$/data-contracts/ABIs/IPLDBlacklistFactory.json", function (module, exports) {
  module.exports = require$$1$1k;
});

var contractName$1i = "Migrations";
var abi$1i = [
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "lastCompletedMigration",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		constant: false,
		inputs: [
			{
				name: "completed",
				type: "uint256"
			}
		],
		name: "setCompleted",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_newAddress",
				type: "address"
			}
		],
		name: "upgrade",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$1j = {
	contractName: contractName$1i,
	abi: abi$1i
};

const commonjsRegister$1i = commonjsRegister$1t;
commonjsRegister$1i("/$$rollup_base$$/data-contracts/ABIs/Migrations.json", function (module, exports) {
  module.exports = require$$1$1j;
});

var contractName$1h = "OpenZeppelinUpgradesAddress";
var abi$1h = [
];
var require$$1$1i = {
	contractName: contractName$1h,
	abi: abi$1h
};

const commonjsRegister$1h = commonjsRegister$1t;
commonjsRegister$1h("/$$rollup_base$$/data-contracts/ABIs/OpenZeppelinUpgradesAddress.json", function (module, exports) {
  module.exports = require$$1$1i;
});

var contractName$1g = "Ownable";
var abi$1g = [
	{
		inputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$1h = {
	contractName: contractName$1g,
	abi: abi$1g
};

const commonjsRegister$1g = commonjsRegister$1t;
commonjsRegister$1g("/$$rollup_base$$/data-contracts/ABIs/Ownable.json", function (module, exports) {
  module.exports = require$$1$1h;
});

var contractName$1f = "PlaylistFactory";
var abi$1f = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			},
			{
				name: "_playlistStorageRegistryKey",
				type: "bytes32"
			},
			{
				name: "_userFactoryRegistryKey",
				type: "bytes32"
			},
			{
				name: "_trackFactoryRegistryKey",
				type: "bytes32"
			},
			{
				name: "_networkId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_playlistOwnerId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_isPrivate",
				type: "bool"
			},
			{
				indexed: false,
				name: "_isAlbum",
				type: "bool"
			},
			{
				indexed: false,
				name: "_trackIds",
				type: "uint256[]"
			}
		],
		name: "PlaylistCreated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "PlaylistDeleted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_addedTrackId",
				type: "uint256"
			}
		],
		name: "PlaylistTrackAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_deletedTrackId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_deletedTrackTimestamp",
				type: "uint256"
			}
		],
		name: "PlaylistTrackDeleted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_orderedTrackIds",
				type: "uint256[]"
			}
		],
		name: "PlaylistTracksOrdered",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_updatedPlaylistName",
				type: "string"
			}
		],
		name: "PlaylistNameUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_updatedIsPrivate",
				type: "bool"
			}
		],
		name: "PlaylistPrivacyUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_playlistImageMultihashDigest",
				type: "bytes32"
			}
		],
		name: "PlaylistCoverPhotoUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_playlistDescription",
				type: "string"
			}
		],
		name: "PlaylistDescriptionUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_playlistUPC",
				type: "bytes32"
			}
		],
		name: "PlaylistUPCUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistOwnerId",
				type: "uint256"
			},
			{
				name: "_playlistName",
				type: "string"
			},
			{
				name: "_isPrivate",
				type: "bool"
			},
			{
				name: "_isAlbum",
				type: "bool"
			},
			{
				name: "_trackIds",
				type: "uint256[]"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "createPlaylist",
		outputs: [
			{
				name: "newPlaylistId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "deletePlaylist",
		outputs: [
			{
				name: "status",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_addedTrackId",
				type: "uint256"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "addPlaylistTrack",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_deletedTrackId",
				type: "uint256"
			},
			{
				name: "_deletedTrackTimestamp",
				type: "uint256"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "deletePlaylistTrack",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_trackIds",
				type: "uint256[]"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "orderPlaylistTracks",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_updatedPlaylistName",
				type: "string"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updatePlaylistName",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_updatedPlaylistPrivacy",
				type: "bool"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updatePlaylistPrivacy",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_playlistImageMultihashDigest",
				type: "bytes32"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updatePlaylistCoverPhoto",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_playlistDescription",
				type: "string"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updatePlaylistDescription",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_updatedPlaylistUPC",
				type: "bytes32"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updatePlaylistUPC",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "playlistExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "isTrackInPlaylist",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_caller",
				type: "address"
			},
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "callerOwnsPlaylist",
		outputs: [
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$1g = {
	contractName: contractName$1f,
	abi: abi$1f
};

const commonjsRegister$1f = commonjsRegister$1t;
commonjsRegister$1f("/$$rollup_base$$/data-contracts/ABIs/PlaylistFactory.json", function (module, exports) {
  module.exports = require$$1$1g;
});

var contractName$1e = "PlaylistFactoryInterface";
var abi$1e = [
	{
		constant: true,
		inputs: [
			{
				name: "_caller",
				type: "address"
			},
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "callerOwnsPlaylist",
		outputs: [
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "playlistExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$1f = {
	contractName: contractName$1e,
	abi: abi$1e
};

const commonjsRegister$1e = commonjsRegister$1t;
commonjsRegister$1e("/$$rollup_base$$/data-contracts/ABIs/PlaylistFactoryInterface.json", function (module, exports) {
  module.exports = require$$1$1f;
});

var contractName$1d = "PlaylistStorage";
var abi$1d = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		name: "playlistOwner",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistOwnerId",
				type: "uint256"
			},
			{
				name: "_isAlbum",
				type: "bool"
			},
			{
				name: "_trackIds",
				type: "uint256[]"
			}
		],
		name: "createPlaylist",
		outputs: [
			{
				name: "newPlaylistId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_addedTrackId",
				type: "uint256"
			}
		],
		name: "addPlaylistTrack",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_deletedTrackId",
				type: "uint256"
			}
		],
		name: "deletePlaylistTrack",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "getPlaylistOwner",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "isTrackInPlaylist",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "playlistExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$1e = {
	contractName: contractName$1d,
	abi: abi$1d
};

const commonjsRegister$1d = commonjsRegister$1t;
commonjsRegister$1d("/$$rollup_base$$/data-contracts/ABIs/PlaylistStorage.json", function (module, exports) {
  module.exports = require$$1$1e;
});

var contractName$1c = "PlaylistStorageInterface";
var abi$1c = [
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_isAlbum",
				type: "bool"
			},
			{
				name: "_trackIds",
				type: "uint256[]"
			}
		],
		name: "createPlaylist",
		outputs: [
			{
				name: "newPlaylistId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_addedTrackId",
				type: "uint256"
			}
		],
		name: "addPlaylistTrack",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_deletedTrackId",
				type: "uint256"
			}
		],
		name: "deletePlaylistTrack",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "getPlaylistOwner",
		outputs: [
			{
				name: "playlistOwnerId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "isTrackInPlaylist",
		outputs: [
			{
				name: "trackInPlaylist",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "playlistExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$1d = {
	contractName: contractName$1c,
	abi: abi$1c
};

const commonjsRegister$1c = commonjsRegister$1t;
commonjsRegister$1c("/$$rollup_base$$/data-contracts/ABIs/PlaylistStorageInterface.json", function (module, exports) {
  module.exports = require$$1$1d;
});

var contractName$1b = "Proxy";
var abi$1b = [
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	}
];
var require$$1$1c = {
	contractName: contractName$1b,
	abi: abi$1b
};

const commonjsRegister$1b = commonjsRegister$1t;
commonjsRegister$1b("/$$rollup_base$$/data-contracts/ABIs/Proxy.json", function (module, exports) {
  module.exports = require$$1$1c;
});

var contractName$1a = "Registry";
var abi$1a = [
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: false,
				name: "_address",
				type: "address"
			}
		],
		name: "ContractAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: false,
				name: "_address",
				type: "address"
			}
		],
		name: "ContractRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: false,
				name: "_oldAddress",
				type: "address"
			},
			{
				indexed: false,
				name: "_newAddress",
				type: "address"
			}
		],
		name: "ContractUpgraded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_name",
				type: "bytes32"
			},
			{
				name: "_address",
				type: "address"
			}
		],
		name: "addContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_name",
				type: "bytes32"
			},
			{
				name: "_version",
				type: "uint256"
			}
		],
		name: "getContract",
		outputs: [
			{
				name: "contractAddr",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_name",
				type: "bytes32"
			}
		],
		name: "getContract",
		outputs: [
			{
				name: "contractAddr",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_name",
				type: "bytes32"
			}
		],
		name: "getContractVersionCount",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_name",
				type: "bytes32"
			}
		],
		name: "removeContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_name",
				type: "bytes32"
			},
			{
				name: "_newAddress",
				type: "address"
			}
		],
		name: "upgradeContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$1b = {
	contractName: contractName$1a,
	abi: abi$1a
};

const commonjsRegister$1a = commonjsRegister$1t;
commonjsRegister$1a("/$$rollup_base$$/data-contracts/ABIs/Registry.json", function (module, exports) {
  module.exports = require$$1$1b;
});

var contractName$19 = "RegistryContract";
var abi$19 = [
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$1a = {
	contractName: contractName$19,
	abi: abi$19
};

const commonjsRegister$19 = commonjsRegister$1t;
commonjsRegister$19("/$$rollup_base$$/data-contracts/ABIs/RegistryContract.json", function (module, exports) {
  module.exports = require$$1$1a;
});

var contractName$18 = "RegistryContractInterface";
var abi$18 = [
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$19 = {
	contractName: contractName$18,
	abi: abi$18
};

const commonjsRegister$18 = commonjsRegister$1t;
commonjsRegister$18("/$$rollup_base$$/data-contracts/ABIs/RegistryContractInterface.json", function (module, exports) {
  module.exports = require$$1$19;
});

var contractName$17 = "RegistryInterface";
var abi$17 = [
	{
		constant: true,
		inputs: [
			{
				name: "_name",
				type: "bytes32"
			},
			{
				name: "_version",
				type: "uint256"
			}
		],
		name: "getContract",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_name",
				type: "bytes32"
			}
		],
		name: "getContract",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_name",
				type: "bytes32"
			}
		],
		name: "getContractVersionCount",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$18 = {
	contractName: contractName$17,
	abi: abi$17
};

const commonjsRegister$17 = commonjsRegister$1t;
commonjsRegister$17("/$$rollup_base$$/data-contracts/ABIs/RegistryInterface.json", function (module, exports) {
  module.exports = require$$1$18;
});

var contractName$16 = "SigningLogic";
var abi$16 = [
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				name: "name",
				type: "string"
			},
			{
				name: "version",
				type: "string"
			},
			{
				name: "chainId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	}
];
var require$$1$17 = {
	contractName: contractName$16,
	abi: abi$16
};

const commonjsRegister$16 = commonjsRegister$1t;
commonjsRegister$16("/$$rollup_base$$/data-contracts/ABIs/SigningLogic.json", function (module, exports) {
  module.exports = require$$1$17;
});

var contractName$15 = "SigningLogicInitializable";
var abi$15 = [
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "name",
				type: "string"
			},
			{
				name: "version",
				type: "string"
			},
			{
				name: "chainId",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$16 = {
	contractName: contractName$15,
	abi: abi$15
};

const commonjsRegister$15 = commonjsRegister$1t;
commonjsRegister$15("/$$rollup_base$$/data-contracts/ABIs/SigningLogicInitializable.json", function (module, exports) {
  module.exports = require$$1$16;
});

var contractName$14 = "SocialFeatureFactory";
var abi$14 = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			},
			{
				name: "_socialFeatureStorageRegistryKey",
				type: "bytes32"
			},
			{
				name: "_userFactoryRegistryKey",
				type: "bytes32"
			},
			{
				name: "_trackFactoryRegistryKey",
				type: "bytes32"
			},
			{
				name: "_playlistFactoryRegistryKey",
				type: "bytes32"
			},
			{
				name: "_networkId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "TrackRepostAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "TrackRepostDeleted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "PlaylistRepostAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "PlaylistRepostDeleted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_followerUserId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_followeeUserId",
				type: "uint256"
			}
		],
		name: "UserFollowAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_followerUserId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_followeeUserId",
				type: "uint256"
			}
		],
		name: "UserFollowDeleted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "addTrackRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "addPlaylistRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "deleteTrackRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "deletePlaylistRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_followerUserId",
				type: "uint256"
			},
			{
				name: "_followeeUserId",
				type: "uint256"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "addUserFollow",
		outputs: [
			{
				name: "status",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_followerUserId",
				type: "uint256"
			},
			{
				name: "_followeeUserId",
				type: "uint256"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "deleteUserFollow",
		outputs: [
			{
				name: "status",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "userRepostedTrack",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "userRepostedPlaylist",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$15 = {
	contractName: contractName$14,
	abi: abi$14
};

const commonjsRegister$14 = commonjsRegister$1t;
commonjsRegister$14("/$$rollup_base$$/data-contracts/ABIs/SocialFeatureFactory.json", function (module, exports) {
  module.exports = require$$1$15;
});

var contractName$13 = "SocialFeatureStorage";
var abi$13 = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "addTrackRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "deleteTrackRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "userRepostedTrack",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "addPlaylistRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "deletePlaylistRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "userRepostedPlaylist",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$14 = {
	contractName: contractName$13,
	abi: abi$13
};

const commonjsRegister$13 = commonjsRegister$1t;
commonjsRegister$13("/$$rollup_base$$/data-contracts/ABIs/SocialFeatureStorage.json", function (module, exports) {
  module.exports = require$$1$14;
});

var contractName$12 = "SocialFeatureStorageInterface";
var abi$12 = [
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "addTrackRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "deleteTrackRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "userRepostedTrack",
		outputs: [
			{
				name: "reposted",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "addPlaylistRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "deletePlaylistRepost",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "userRepostedPlaylist",
		outputs: [
			{
				name: "reposted",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$13 = {
	contractName: contractName$12,
	abi: abi$12
};

const commonjsRegister$12 = commonjsRegister$1t;
commonjsRegister$12("/$$rollup_base$$/data-contracts/ABIs/SocialFeatureStorageInterface.json", function (module, exports) {
  module.exports = require$$1$13;
});

var contractName$11 = "TestContract";
var abi$11 = [
	{
		constant: true,
		inputs: [
		],
		name: "x",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_x",
				type: "uint256"
			}
		],
		name: "setX",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$12 = {
	contractName: contractName$11,
	abi: abi$11
};

const commonjsRegister$11 = commonjsRegister$1t;
commonjsRegister$11("/$$rollup_base$$/data-contracts/ABIs/TestContract.json", function (module, exports) {
  module.exports = require$$1$12;
});

var contractName$10 = "TestContractInterface";
var abi$10 = [
	{
		constant: false,
		inputs: [
			{
				name: "_x",
				type: "uint256"
			}
		],
		name: "setX",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$11 = {
	contractName: contractName$10,
	abi: abi$10
};

const commonjsRegister$10 = commonjsRegister$1t;
commonjsRegister$10("/$$rollup_base$$/data-contracts/ABIs/TestContractInterface.json", function (module, exports) {
  module.exports = require$$1$11;
});

var contractName$$ = "TestContractWithStorage";
var abi$$ = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			},
			{
				name: "_testStorageRegistryKey",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_key",
				type: "bytes32"
			},
			{
				indexed: false,
				name: "_val",
				type: "bytes32"
			}
		],
		name: "NewData",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_key",
				type: "bytes32"
			}
		],
		name: "getData",
		outputs: [
			{
				name: "val",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_key",
				type: "bytes32"
			},
			{
				name: "_val",
				type: "bytes32"
			}
		],
		name: "addData",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$10 = {
	contractName: contractName$$,
	abi: abi$$
};

const commonjsRegister$$ = commonjsRegister$1t;
commonjsRegister$$("/$$rollup_base$$/data-contracts/ABIs/TestContractWithStorage.json", function (module, exports) {
  module.exports = require$$1$10;
});

var contractName$_ = "TestContractWithStorageInterface";
var abi$_ = [
	{
		constant: true,
		inputs: [
			{
				name: "_key",
				type: "bytes32"
			}
		],
		name: "getData",
		outputs: [
			{
				name: "val",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$$ = {
	contractName: contractName$_,
	abi: abi$_
};

const commonjsRegister$_ = commonjsRegister$1t;
commonjsRegister$_("/$$rollup_base$$/data-contracts/ABIs/TestContractWithStorageInterface.json", function (module, exports) {
  module.exports = require$$1$$;
});

var contractName$Z = "TestStorage";
var abi$Z = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_key",
				type: "bytes32"
			}
		],
		name: "getData",
		outputs: [
			{
				name: "val",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_key",
				type: "bytes32"
			},
			{
				name: "_val",
				type: "bytes32"
			}
		],
		name: "addData",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$_ = {
	contractName: contractName$Z,
	abi: abi$Z
};

const commonjsRegister$Z = commonjsRegister$1t;
commonjsRegister$Z("/$$rollup_base$$/data-contracts/ABIs/TestStorage.json", function (module, exports) {
  module.exports = require$$1$_;
});

var contractName$Y = "TestStorageInterface";
var abi$Y = [
	{
		constant: true,
		inputs: [
			{
				name: "_key",
				type: "bytes32"
			}
		],
		name: "getData",
		outputs: [
			{
				name: "val",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_key",
				type: "bytes32"
			},
			{
				name: "_val",
				type: "bytes32"
			}
		],
		name: "addData",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$Z = {
	contractName: contractName$Y,
	abi: abi$Y
};

const commonjsRegister$Y = commonjsRegister$1t;
commonjsRegister$Y("/$$rollup_base$$/data-contracts/ABIs/TestStorageInterface.json", function (module, exports) {
  module.exports = require$$1$Z;
});

var contractName$X = "TestUserReplicaSetManager";
var abi$X = [
	{
		constant: false,
		inputs: [
			{
				name: "_bootstrapSPIds",
				type: "uint256[]"
			},
			{
				name: "_bootstrapNodeDelegateWallets",
				type: "address[]"
			},
			{
				name: "_bootstrapNodeOwnerWallets",
				type: "address[]"
			}
		],
		name: "seedBootstrapNodes",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getUserReplicaSetBootstrapAddress",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			}
		],
		name: "getUserReplicaSet",
		outputs: [
			{
				name: "primaryId",
				type: "uint256"
			},
			{
				name: "secondaryIds",
				type: "uint256[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getSeedComplete",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_cnodeSpId",
				type: "uint256"
			},
			{
				name: "_cnodeWallets",
				type: "address[2]"
			},
			{
				name: "_proposerSpIds",
				type: "uint256[3]"
			},
			{
				name: "_proposerNonces",
				type: "bytes32[3]"
			},
			{
				name: "_proposer1Sig",
				type: "bytes"
			},
			{
				name: "_proposer2Sig",
				type: "bytes"
			},
			{
				name: "_proposer3Sig",
				type: "bytes"
			}
		],
		name: "addOrUpdateContentNode",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_spID",
				type: "uint256"
			}
		],
		name: "getContentNodeWallets",
		outputs: [
			{
				name: "delegateOwnerWallet",
				type: "address"
			},
			{
				name: "ownerWallet",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_newBootstrapAddress",
				type: "address"
			}
		],
		name: "updateUserReplicaBootstrapAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "name",
				type: "string"
			},
			{
				name: "version",
				type: "string"
			},
			{
				name: "chainId",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			},
			{
				name: "_userFactoryRegistryKey",
				type: "bytes32"
			},
			{
				name: "_userReplicaSetBootstrapAddress",
				type: "address"
			},
			{
				name: "_networkId",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_primaryId",
				type: "uint256"
			},
			{
				name: "_secondaryIds",
				type: "uint256[]"
			},
			{
				name: "_oldPrimaryId",
				type: "uint256"
			},
			{
				name: "_oldSecondaryIds",
				type: "uint256[]"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateReplicaSet",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_primaryId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_secondaryIds",
				type: "uint256[]"
			},
			{
				indexed: false,
				name: "_signer",
				type: "address"
			}
		],
		name: "UpdateReplicaSet",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_cnodeSpId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_cnodeDelegateOwnerWallet",
				type: "address"
			},
			{
				indexed: false,
				name: "_cnodeOwnerWallet",
				type: "address"
			},
			{
				indexed: false,
				name: "_proposerSpIds",
				type: "uint256[3]"
			},
			{
				indexed: false,
				name: "_proposer1DelegateOwnerWallet",
				type: "address"
			},
			{
				indexed: false,
				name: "_proposer2DelegateOwnerWallet",
				type: "address"
			},
			{
				indexed: false,
				name: "_proposer3DelegateOwnerWallet",
				type: "address"
			}
		],
		name: "AddOrUpdateContentNode",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
		],
		name: "newFunction",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "pure",
		type: "function"
	}
];
var require$$1$Y = {
	contractName: contractName$X,
	abi: abi$X
};

const commonjsRegister$X = commonjsRegister$1t;
commonjsRegister$X("/$$rollup_base$$/data-contracts/ABIs/TestUserReplicaSetManager.json", function (module, exports) {
  module.exports = require$$1$Y;
});

var contractName$W = "TrackFactory";
var abi$W = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			},
			{
				name: "_trackStorageRegistryKey",
				type: "bytes32"
			},
			{
				name: "_userFactoryRegistryKey",
				type: "bytes32"
			},
			{
				name: "_networkId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_id",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_trackOwnerId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_multihashDigest",
				type: "bytes32"
			},
			{
				indexed: false,
				name: "_multihashHashFn",
				type: "uint8"
			},
			{
				indexed: false,
				name: "_multihashSize",
				type: "uint8"
			}
		],
		name: "NewTrack",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_trackId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_trackOwnerId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_multihashDigest",
				type: "bytes32"
			},
			{
				indexed: false,
				name: "_multihashHashFn",
				type: "uint8"
			},
			{
				indexed: false,
				name: "_multihashSize",
				type: "uint8"
			}
		],
		name: "UpdateTrack",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "TrackDeleted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "trackExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_trackOwnerId",
				type: "uint256"
			},
			{
				name: "_multihashDigest",
				type: "bytes32"
			},
			{
				name: "_multihashHashFn",
				type: "uint8"
			},
			{
				name: "_multihashSize",
				type: "uint8"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "addTrack",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_trackId",
				type: "uint256"
			},
			{
				name: "_trackOwnerId",
				type: "uint256"
			},
			{
				name: "_multihashDigest",
				type: "bytes32"
			},
			{
				name: "_multihashHashFn",
				type: "uint8"
			},
			{
				name: "_multihashSize",
				type: "uint8"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateTrack",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_trackId",
				type: "uint256"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "deleteTrack",
		outputs: [
			{
				name: "status",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_caller",
				type: "address"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "callerOwnsTrack",
		outputs: [
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "getTrack",
		outputs: [
			{
				name: "trackOwnerId",
				type: "uint256"
			},
			{
				name: "multihashDigest",
				type: "bytes32"
			},
			{
				name: "multihashHashFn",
				type: "uint8"
			},
			{
				name: "multihashSize",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$X = {
	contractName: contractName$W,
	abi: abi$W
};

const commonjsRegister$W = commonjsRegister$1t;
commonjsRegister$W("/$$rollup_base$$/data-contracts/ABIs/TrackFactory.json", function (module, exports) {
  module.exports = require$$1$X;
});

var contractName$V = "TrackFactoryInterface";
var abi$V = [
	{
		constant: true,
		inputs: [
			{
				name: "_caller",
				type: "address"
			},
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "callerOwnsTrack",
		outputs: [
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "getTrack",
		outputs: [
			{
				name: "trackOwnerId",
				type: "uint256"
			},
			{
				name: "multihashDigest",
				type: "bytes32"
			},
			{
				name: "multihashHashFn",
				type: "uint8"
			},
			{
				name: "multihashSize",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "trackExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$W = {
	contractName: contractName$V,
	abi: abi$V
};

const commonjsRegister$V = commonjsRegister$1t;
commonjsRegister$V("/$$rollup_base$$/data-contracts/ABIs/TrackFactoryInterface.json", function (module, exports) {
  module.exports = require$$1$W;
});

var contractName$U = "TrackStorage";
var abi$U = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "getTrack",
		outputs: [
			{
				name: "trackOwnerId",
				type: "uint256"
			},
			{
				name: "multihashDigest",
				type: "bytes32"
			},
			{
				name: "multihashHashFn",
				type: "uint8"
			},
			{
				name: "multihashSize",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_trackOwnerId",
				type: "uint256"
			},
			{
				name: "_multihashDigest",
				type: "bytes32"
			},
			{
				name: "_multihashHashFn",
				type: "uint8"
			},
			{
				name: "_multihashSize",
				type: "uint8"
			}
		],
		name: "addTrack",
		outputs: [
			{
				name: "newTrackId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_trackId",
				type: "uint256"
			},
			{
				name: "_trackOwnerId",
				type: "uint256"
			},
			{
				name: "_multihashDigest",
				type: "bytes32"
			},
			{
				name: "_multihashHashFn",
				type: "uint8"
			},
			{
				name: "_multihashSize",
				type: "uint8"
			}
		],
		name: "updateTrack",
		outputs: [
			{
				name: "updatePerformed",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "trackExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$V = {
	contractName: contractName$U,
	abi: abi$U
};

const commonjsRegister$U = commonjsRegister$1t;
commonjsRegister$U("/$$rollup_base$$/data-contracts/ABIs/TrackStorage.json", function (module, exports) {
  module.exports = require$$1$V;
});

var contractName$T = "TrackStorageInterface";
var abi$T = [
	{
		constant: true,
		inputs: [
			{
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "getTrack",
		outputs: [
			{
				name: "trackOwnerId",
				type: "uint256"
			},
			{
				name: "multihashDigest",
				type: "bytes32"
			},
			{
				name: "multihashHashFn",
				type: "uint8"
			},
			{
				name: "multihashSize",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_trackOwnerId",
				type: "uint256"
			},
			{
				name: "_multihashDigest",
				type: "bytes32"
			},
			{
				name: "_multihashHashFn",
				type: "uint8"
			},
			{
				name: "_multihashSize",
				type: "uint8"
			}
		],
		name: "addTrack",
		outputs: [
			{
				name: "newTrackId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_trackId",
				type: "uint256"
			},
			{
				name: "_trackOwnerId",
				type: "uint256"
			},
			{
				name: "_multihashDigest",
				type: "bytes32"
			},
			{
				name: "_multihashHashFn",
				type: "uint8"
			},
			{
				name: "_multihashSize",
				type: "uint8"
			}
		],
		name: "updateTrack",
		outputs: [
			{
				name: "updatePerformed",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "trackExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$U = {
	contractName: contractName$T,
	abi: abi$T
};

const commonjsRegister$T = commonjsRegister$1t;
commonjsRegister$T("/$$rollup_base$$/data-contracts/ABIs/TrackStorageInterface.json", function (module, exports) {
  module.exports = require$$1$U;
});

var contractName$S = "UpgradeabilityProxy";
var abi$S = [
	{
		inputs: [
			{
				name: "_logic",
				type: "address"
			},
			{
				name: "_data",
				type: "bytes"
			}
		],
		payable: true,
		stateMutability: "payable",
		type: "constructor"
	},
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "implementation",
				type: "address"
			}
		],
		name: "Upgraded",
		type: "event"
	}
];
var require$$1$T = {
	contractName: contractName$S,
	abi: abi$S
};

const commonjsRegister$S = commonjsRegister$1t;
commonjsRegister$S("/$$rollup_base$$/data-contracts/ABIs/UpgradeabilityProxy.json", function (module, exports) {
  module.exports = require$$1$T;
});

var contractName$R = "UserFactory";
var abi$R = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			},
			{
				name: "_userStorageRegistryKey",
				type: "bytes32"
			},
			{
				name: "_networkId",
				type: "uint256"
			},
			{
				name: "_verifierAddress",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_handle",
				type: "bytes16"
			},
			{
				indexed: false,
				name: "_wallet",
				type: "address"
			}
		],
		name: "AddUser",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_multihashDigest",
				type: "bytes32"
			}
		],
		name: "UpdateMultihash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_name",
				type: "bytes32"
			}
		],
		name: "UpdateName",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_location",
				type: "bytes32"
			}
		],
		name: "UpdateLocation",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_bio",
				type: "string"
			}
		],
		name: "UpdateBio",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_profilePhotoDigest",
				type: "bytes32"
			}
		],
		name: "UpdateProfilePhoto",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_coverPhotoDigest",
				type: "bytes32"
			}
		],
		name: "UpdateCoverPhoto",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_isCreator",
				type: "bool"
			}
		],
		name: "UpdateIsCreator",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_isVerified",
				type: "bool"
			}
		],
		name: "UpdateIsVerified",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_creatorNodeEndpoint",
				type: "string"
			}
		],
		name: "UpdateCreatorNodeEndpoint",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_callerAddress",
				type: "address"
			},
			{
				name: "_userId",
				type: "uint256"
			}
		],
		name: "callerOwnsUser",
		outputs: [
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "getUser",
		outputs: [
			{
				name: "wallet",
				type: "address"
			},
			{
				name: "handle",
				type: "bytes16"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_owner",
				type: "address"
			},
			{
				name: "_handle",
				type: "bytes16"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "addUser",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_multihashDigest",
				type: "bytes32"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateMultihash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_name",
				type: "bytes32"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateName",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_location",
				type: "bytes32"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateLocation",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_bio",
				type: "string"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateBio",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_profilePhotoDigest",
				type: "bytes32"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateProfilePhoto",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_coverPhotoDigest",
				type: "bytes32"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateCoverPhoto",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_isCreator",
				type: "bool"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateIsCreator",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_isVerified",
				type: "bool"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateIsVerified",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_creatorNodeEndpoint",
				type: "string"
			},
			{
				name: "_nonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateCreatorNodeEndpoint",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_handle",
				type: "bytes16"
			}
		],
		name: "handleIsValid",
		outputs: [
			{
				name: "isValid",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "userExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$S = {
	contractName: contractName$R,
	abi: abi$R
};

const commonjsRegister$R = commonjsRegister$1t;
commonjsRegister$R("/$$rollup_base$$/data-contracts/ABIs/UserFactory.json", function (module, exports) {
  module.exports = require$$1$S;
});

var contractName$Q = "UserFactoryInterface";
var abi$Q = [
	{
		constant: true,
		inputs: [
			{
				name: "_caller",
				type: "address"
			},
			{
				name: "_userId",
				type: "uint256"
			}
		],
		name: "callerOwnsUser",
		outputs: [
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "getUser",
		outputs: [
			{
				name: "wallet",
				type: "address"
			},
			{
				name: "handle",
				type: "bytes16"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "userExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$R = {
	contractName: contractName$Q,
	abi: abi$Q
};

const commonjsRegister$Q = commonjsRegister$1t;
commonjsRegister$Q("/$$rollup_base$$/data-contracts/ABIs/UserFactoryInterface.json", function (module, exports) {
  module.exports = require$$1$R;
});

var contractName$P = "UserLibraryFactory";
var abi$P = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			},
			{
				name: "_userFactoryRegistryKey",
				type: "bytes32"
			},
			{
				name: "_trackFactoryRegistryKey",
				type: "bytes32"
			},
			{
				name: "_playlistFactoryRegistryKey",
				type: "bytes32"
			},
			{
				name: "_networkId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "TrackSaveAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_trackId",
				type: "uint256"
			}
		],
		name: "TrackSaveDeleted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "PlaylistSaveAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_playlistId",
				type: "uint256"
			}
		],
		name: "PlaylistSaveDeleted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "addTrackSave",
		outputs: [
			{
				name: "status",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_trackId",
				type: "uint256"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "deleteTrackSave",
		outputs: [
			{
				name: "status",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "addPlaylistSave",
		outputs: [
			{
				name: "status",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_playlistId",
				type: "uint256"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "deletePlaylistSave",
		outputs: [
			{
				name: "status",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$Q = {
	contractName: contractName$P,
	abi: abi$P
};

const commonjsRegister$P = commonjsRegister$1t;
commonjsRegister$P("/$$rollup_base$$/data-contracts/ABIs/UserLibraryFactory.json", function (module, exports) {
  module.exports = require$$1$Q;
});

var contractName$O = "UserReplicaSetManager";
var abi$O = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		name: "usedSignatures",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_userId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_primaryId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_secondaryIds",
				type: "uint256[]"
			},
			{
				indexed: false,
				name: "_signer",
				type: "address"
			}
		],
		name: "UpdateReplicaSet",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				name: "_cnodeSpId",
				type: "uint256"
			},
			{
				indexed: false,
				name: "_cnodeDelegateOwnerWallet",
				type: "address"
			},
			{
				indexed: false,
				name: "_cnodeOwnerWallet",
				type: "address"
			},
			{
				indexed: false,
				name: "_proposerSpIds",
				type: "uint256[3]"
			},
			{
				indexed: false,
				name: "_proposer1DelegateOwnerWallet",
				type: "address"
			},
			{
				indexed: false,
				name: "_proposer2DelegateOwnerWallet",
				type: "address"
			},
			{
				indexed: false,
				name: "_proposer3DelegateOwnerWallet",
				type: "address"
			}
		],
		name: "AddOrUpdateContentNode",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "name",
				type: "string"
			},
			{
				name: "version",
				type: "string"
			},
			{
				name: "chainId",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			},
			{
				name: "_userFactoryRegistryKey",
				type: "bytes32"
			},
			{
				name: "_userReplicaSetBootstrapAddress",
				type: "address"
			},
			{
				name: "_networkId",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_bootstrapSPIds",
				type: "uint256[]"
			},
			{
				name: "_bootstrapNodeDelegateWallets",
				type: "address[]"
			},
			{
				name: "_bootstrapNodeOwnerWallets",
				type: "address[]"
			}
		],
		name: "seedBootstrapNodes",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_cnodeSpId",
				type: "uint256"
			},
			{
				name: "_cnodeWallets",
				type: "address[2]"
			},
			{
				name: "_proposerSpIds",
				type: "uint256[3]"
			},
			{
				name: "_proposerNonces",
				type: "bytes32[3]"
			},
			{
				name: "_proposer1Sig",
				type: "bytes"
			},
			{
				name: "_proposer2Sig",
				type: "bytes"
			},
			{
				name: "_proposer3Sig",
				type: "bytes"
			}
		],
		name: "addOrUpdateContentNode",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			},
			{
				name: "_primaryId",
				type: "uint256"
			},
			{
				name: "_secondaryIds",
				type: "uint256[]"
			},
			{
				name: "_oldPrimaryId",
				type: "uint256"
			},
			{
				name: "_oldSecondaryIds",
				type: "uint256[]"
			},
			{
				name: "_requestNonce",
				type: "bytes32"
			},
			{
				name: "_subjectSig",
				type: "bytes"
			}
		],
		name: "updateReplicaSet",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_newBootstrapAddress",
				type: "address"
			}
		],
		name: "updateUserReplicaBootstrapAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			}
		],
		name: "getUserReplicaSet",
		outputs: [
			{
				name: "primaryId",
				type: "uint256"
			},
			{
				name: "secondaryIds",
				type: "uint256[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_spID",
				type: "uint256"
			}
		],
		name: "getContentNodeWallets",
		outputs: [
			{
				name: "delegateOwnerWallet",
				type: "address"
			},
			{
				name: "ownerWallet",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getUserReplicaSetBootstrapAddress",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getSeedComplete",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$P = {
	contractName: contractName$O,
	abi: abi$O
};

const commonjsRegister$O = commonjsRegister$1t;
commonjsRegister$O("/$$rollup_base$$/data-contracts/ABIs/UserReplicaSetManager.json", function (module, exports) {
  module.exports = require$$1$P;
});

var contractName$N = "UserStorage";
var abi$N = [
	{
		constant: false,
		inputs: [
		],
		name: "kill",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		name: "userHandles",
		outputs: [
			{
				name: "",
				type: "bytes16"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistry",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "bytes16"
			}
		],
		name: "handlesTaken",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				name: "_registryAddress",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_wallet",
				type: "address"
			},
			{
				name: "_handle",
				type: "bytes16"
			},
			{
				name: "_handleLower",
				type: "bytes16"
			}
		],
		name: "addUser",
		outputs: [
			{
				name: "newUserId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_userId",
				type: "uint256"
			}
		],
		name: "getUser",
		outputs: [
			{
				name: "wallet",
				type: "address"
			},
			{
				name: "handle",
				type: "bytes16"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "userExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_handleLower",
				type: "bytes16"
			}
		],
		name: "handleIsTaken",
		outputs: [
			{
				name: "isTaken",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$O = {
	contractName: contractName$N,
	abi: abi$N
};

const commonjsRegister$N = commonjsRegister$1t;
commonjsRegister$N("/$$rollup_base$$/data-contracts/ABIs/UserStorage.json", function (module, exports) {
  module.exports = require$$1$O;
});

var contractName$M = "UserStorageInterface";
var abi$M = [
	{
		constant: false,
		inputs: [
			{
				name: "_wallet",
				type: "address"
			},
			{
				name: "_handle",
				type: "bytes16"
			},
			{
				name: "_handleLower",
				type: "bytes16"
			}
		],
		name: "addUser",
		outputs: [
			{
				name: "newUserId",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "getUser",
		outputs: [
			{
				name: "wallet",
				type: "address"
			},
			{
				name: "handle",
				type: "bytes16"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_id",
				type: "uint256"
			}
		],
		name: "userExists",
		outputs: [
			{
				name: "exists",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_handle",
				type: "bytes16"
			}
		],
		name: "handleIsTaken",
		outputs: [
			{
				name: "isTaken",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$N = {
	contractName: contractName$M,
	abi: abi$M
};

const commonjsRegister$M = commonjsRegister$1t;
commonjsRegister$M("/$$rollup_base$$/data-contracts/ABIs/UserStorageInterface.json", function (module, exports) {
  module.exports = require$$1$N;
});

var contractName$L = "Address";
var abi$L = [
];
var require$$1$M = {
	contractName: contractName$L,
	abi: abi$L
};

const commonjsRegister$L = commonjsRegister$1t;
commonjsRegister$L("/$$rollup_base$$/eth-contracts/ABIs/Address.json", function (module, exports) {
  module.exports = require$$1$M;
});

var contractName$K = "AudiusAdminUpgradeabilityProxy";
var abi$K = [
	{
		inputs: [
			{
				internalType: "address",
				name: "_logic",
				type: "address"
			},
			{
				internalType: "address",
				name: "_proxyAdmin",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			}
		],
		payable: true,
		stateMutability: "payable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "implementation",
				type: "address"
			}
		],
		name: "Upgraded",
		type: "event"
	},
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_newImplementation",
				type: "address"
			}
		],
		name: "upgradeTo",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getAudiusProxyAdminAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "implementation",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_adminAddress",
				type: "address"
			}
		],
		name: "setAudiusProxyAdminAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$L = {
	contractName: contractName$K,
	abi: abi$K
};

const commonjsRegister$K = commonjsRegister$1t;
commonjsRegister$K("/$$rollup_base$$/eth-contracts/ABIs/AudiusAdminUpgradeabilityProxy.json", function (module, exports) {
  module.exports = require$$1$L;
});

var contractName$J = "AudiusClaimDistributor";
var abi$J = [
	{
		inputs: [
			{
				internalType: "address",
				name: "_token",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "_merkleRoot",
				type: "bytes32"
			}
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "index",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "Claimed",
		type: "event"
	},
	{
		inputs: [
		],
		name: "merkleRoot",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function",
		constant: true
	},
	{
		inputs: [
		],
		name: "token",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function",
		constant: true
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "index",
				type: "uint256"
			}
		],
		name: "isClaimed",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function",
		constant: true
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "index",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "bytes32[]",
				name: "merkleProof",
				type: "bytes32[]"
			}
		],
		name: "claim",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var metadata = "{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{\"claim(uint256,address,uint256,bytes32[])\":{\"notice\":\"No caller permissioning needed since token is transfered to account argument,    and there is no incentive to call function for another account. Can only submit claim for full claimable amount, otherwise proof verification will fail.\"}},\"notice\":\"Replicated from (No changes made): https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol\"}},\"settings\":{\"compilationTarget\":{\"/Users/joey/workspace/claim-distribution/contracts/AudiusClaimDistributor.sol\":\"AudiusClaimDistributor\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":false},\"runs\":200},\"remappings\":[]},\"sources\":{\"/Users/joey/workspace/claim-distribution/contracts/AudiusClaimDistributor.sol\":{\"keccak256\":\"0xb479969ba8f612589c6958cd6bdffb8bfd3c26bfcfccc5fc73bdf81f58779ff2\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://7ffcd574dffcdadba4ebba659cde0509ed302c341eb03153997b89f84bb854c8\",\"dweb:/ipfs/QmZGXJh2BSgeLr92Jd2pW4hicKL7Muvx8ENfR2kBH9KTKv\"]},\"@openzeppelin/contracts/cryptography/MerkleProof.sol\":{\"keccak256\":\"0x96a652802a06645a5908f74f104ec95ff0897e261e7028ee319bafc55582b597\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5afea8071316055c01a3d144da77523b8ae7ec8295e99559000cb07b23b98d30\",\"dweb:/ipfs/QmX14dHGgyErJb3R7wSNBSgxLdyX6EAVwJsZ6yK1xyG1Mo\"]},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0x5c26b39d26f7ed489e555d955dcd3e01872972e71fdd1528e93ec164e4f23385\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://efdc632af6960cf865dbc113665ea1f5b90eab75cc40ec062b2f6ae6da582017\",\"dweb:/ipfs/QmfAZFDuG62vxmAN9DnXApv7e7PMzPqi4RkqqZHLMSQiY5\"]}},\"version\":1}";
var bytecode = "0x608060405234801561001057600080fd5b506040516105953803806105958339818101604052604081101561003357600080fd5b508051602090910151600080546001600160a01b0319166001600160a01b0390931692909217825560015561052790819061006e90396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80632e7ba6ef146100515780632eb4a7ab146100df5780639e34070f146100f9578063fc0c546a1461012a575b600080fd5b6100dd6004803603608081101561006757600080fd5b8135916001600160a01b03602082013516916040820135919081019060808101606082013564010000000081111561009e57600080fd5b8201836020820111156100b057600080fd5b803590602001918460208302840111640100000000831117156100d257600080fd5b50909250905061014e565b005b6100e761036b565b60408051918252519081900360200190f35b6101166004803603602081101561010f57600080fd5b5035610371565b604080519115158252519081900360200190f35b610132610397565b604080516001600160a01b039092168252519081900360200190f35b61015785610371565b156101935760405162461bcd60e51b815260040180806020018281038252602d8152602001806104c5602d913960400191505060405180910390fd5b6040805160208082018890526bffffffffffffffffffffffff19606088901b1682840152605480830187905283518084039091018152607483018085528151918301919091206094928602808501840190955285825293610217939192879287928392909101908490808284376000920191909152505060015491508490506103a6565b6102525760405162461bcd60e51b81526004018080602001828103825260268152602001806104776026913960400191505060405180910390fd5b61025b8661044f565b600080546040805163a9059cbb60e01b81526001600160a01b038981166004830152602482018990529151919092169263a9059cbb92604480820193602093909283900390910190829087803b1580156102b457600080fd5b505af11580156102c8573d6000803e3d6000fd5b505050506040513d60208110156102de57600080fd5b505161031b5760405162461bcd60e51b815260040180806020018281038252602881526020018061049d6028913960400191505060405180910390fd5b604080518781526001600160a01b038716602082015280820186905290517f4ec90e965519d92681267467f775ada5bd214aa92c0dc93d90a5e880ce9ed0269181900360600190a1505050505050565b60015481565b6101008104600090815260026020526040902054600160ff9092169190911b9081161490565b6000546001600160a01b031681565b600081815b85518110156104445760008682815181106103c257fe5b60200260200101519050808311610409578281604051602001808381526020018281526020019250505060405160208183030381529060405280519060200120925061043b565b808360405160200180838152602001828152602001925050506040516020818303038152906040528051906020012092505b506001016103ab565b509092149392505050565b610100810460009081526002602052604090208054600160ff9093169290921b909117905556fe417564697573436c61696d4469737472696275746f723a20496e76616c69642070726f6f662e417564697573436c61696d4469737472696275746f723a205472616e73666572206661696c65642e417564697573436c61696d4469737472696275746f723a2044726f7020616c726561647920636c61696d65642ea264697066735822122018014325095f80effd049103159db0073881384608f356cc08c3de087713e46964736f6c634300060a0033";
var deployedBytecode = "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c80632e7ba6ef146100515780632eb4a7ab146100df5780639e34070f146100f9578063fc0c546a1461012a575b600080fd5b6100dd6004803603608081101561006757600080fd5b8135916001600160a01b03602082013516916040820135919081019060808101606082013564010000000081111561009e57600080fd5b8201836020820111156100b057600080fd5b803590602001918460208302840111640100000000831117156100d257600080fd5b50909250905061014e565b005b6100e761036b565b60408051918252519081900360200190f35b6101166004803603602081101561010f57600080fd5b5035610371565b604080519115158252519081900360200190f35b610132610397565b604080516001600160a01b039092168252519081900360200190f35b61015785610371565b156101935760405162461bcd60e51b815260040180806020018281038252602d8152602001806104c5602d913960400191505060405180910390fd5b6040805160208082018890526bffffffffffffffffffffffff19606088901b1682840152605480830187905283518084039091018152607483018085528151918301919091206094928602808501840190955285825293610217939192879287928392909101908490808284376000920191909152505060015491508490506103a6565b6102525760405162461bcd60e51b81526004018080602001828103825260268152602001806104776026913960400191505060405180910390fd5b61025b8661044f565b600080546040805163a9059cbb60e01b81526001600160a01b038981166004830152602482018990529151919092169263a9059cbb92604480820193602093909283900390910190829087803b1580156102b457600080fd5b505af11580156102c8573d6000803e3d6000fd5b505050506040513d60208110156102de57600080fd5b505161031b5760405162461bcd60e51b815260040180806020018281038252602881526020018061049d6028913960400191505060405180910390fd5b604080518781526001600160a01b038716602082015280820186905290517f4ec90e965519d92681267467f775ada5bd214aa92c0dc93d90a5e880ce9ed0269181900360600190a1505050505050565b60015481565b6101008104600090815260026020526040902054600160ff9092169190911b9081161490565b6000546001600160a01b031681565b600081815b85518110156104445760008682815181106103c257fe5b60200260200101519050808311610409578281604051602001808381526020018281526020019250505060405160208183030381529060405280519060200120925061043b565b808360405160200180838152602001828152602001925050506040516020818303038152906040528051906020012092505b506001016103ab565b509092149392505050565b610100810460009081526002602052604090208054600160ff9093169290921b909117905556fe417564697573436c61696d4469737472696275746f723a20496e76616c69642070726f6f662e417564697573436c61696d4469737472696275746f723a205472616e73666572206661696c65642e417564697573436c61696d4469737472696275746f723a2044726f7020616c726561647920636c61696d65642ea264697066735822122018014325095f80effd049103159db0073881384608f356cc08c3de087713e46964736f6c634300060a0033";
var immutableReferences = {
};
var sourceMap = "322:1948:0:-:0;;;652:121;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;652:121:0;;;;;;;718:5;:14;;-1:-1:-1;;;;;;718:14:0;-1:-1:-1;;;;;718:14:0;;;;;;;;;-1:-1:-1;742:24:0;322:1948;;;;;;;;";
var deployedSourceMap = "322:1948:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1624:644;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;1624:644:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;1624:644:0;;-1:-1:-1;1624:644:0;-1:-1:-1;1624:644:0;:::i;:::-;;386:25;;;:::i;:::-;;;;;;;;;;;;;;;;779:316;;;;;;;;;;;;;;;;-1:-1:-1;779:316:0;;:::i;:::-;;;;;;;;;;;;;;;;;;360:20;;;:::i;:::-;;;;-1:-1:-1;;;;;360:20:0;;;;;;;;;;;;;;1624:644;1747:16;1757:5;1747:9;:16::i;:::-;1746:17;1738:75;;;;-1:-1:-1;;;1738:75:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1885:40;;;;;;;;;;-1:-1:-1;;1885:40:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1875:51;;;;;;;;;1944:49;;;;;;;;;;;;;;;1875:51;1944:49;;1885:40;;1963:11;;;;;;1944:49;;;;1963:11;;1944:49;1963:11;1944:49;;;;;;;;;-1:-1:-1;;1976:10:0;;;-1:-1:-1;1988:4:0;;-1:-1:-1;1944:18:0;:49::i;:::-;1936:100;;;;-1:-1:-1;;;1936:100:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2094:18;2106:5;2094:11;:18::i;:::-;2137:5;;;2130:39;;;-1:-1:-1;;;2130:39:0;;-1:-1:-1;;;;;2130:39:0;;;;;;;;;;;;;;;2137:5;;;;;2130:22;;:39;;;;;;;;;;;;;;;;;;2137:5;2130:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;2130:39:0;2122:92;;;;-1:-1:-1;;;2122:92:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2230:31;;;;;;-1:-1:-1;;;;;2230:31:0;;;;;;;;;;;;;;;;;;;;;;;1624:644;;;;;;:::o;386:25::-;;;;:::o;779:316::-;885:3;877:11;;834:4;967:31;;;:13;:31;;;;;;1024:1;924:11;;;;1024:20;;;;1062:18;;;:26;;779:316::o;360:20::-;;;-1:-1:-1;;;;;360:20:0;;:::o;497:779:2:-;588:4;627;588;642:515;666:5;:12;662:1;:16;642:515;;;699:20;722:5;728:1;722:8;;;;;;;;;;;;;;699:31;;765:12;749;:28;745:402;;917:12;931;900:44;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;890:55;;;;;;875:70;;745:402;;;1104:12;1118;1087:44;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1077:55;;;;;;1062:70;;745:402;-1:-1:-1;680:3:2;;642:515;;;-1:-1:-1;1249:20:2;;;;497:779;-1:-1:-1;;;497:779:2:o;1101:246:0:-;1190:3;1182:11;;1155:24;1284:31;;;:13;:31;;;;;;;1319:1;1229:11;;;;1319:20;;;;1284:56;;;1250:90;;1101:246::o";
var source = "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\n\n/**\n * Replicated from (No changes made): https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol\n */\ncontract AudiusClaimDistributor {\n    address public token;\n    bytes32 public merkleRoot;\n\n    // This is a packed array of booleans.\n    mapping(uint256 => uint256) private claimedBitMap;\n\n    // This event is triggered whenever a call to #claim succeeds.\n    event Claimed(uint256 index, address account, uint256 amount);\n\n    constructor(address _token, bytes32 _merkleRoot) public {\n        token = _token;\n        merkleRoot = _merkleRoot;\n    }\n\n    function isClaimed(uint256 index) public view returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    /**\n     * No caller permissioning needed since token is transfered to account argument,\n     *    and there is no incentive to call function for another account.\n     * Can only submit claim for full claimable amount, otherwise proof verification will fail.\n     */\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external {\n        require(!isClaimed(index), 'AudiusClaimDistributor: Drop already claimed.');\n\n        // Verify the merkle proof.\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(MerkleProof.verify(merkleProof, merkleRoot, node), 'AudiusClaimDistributor: Invalid proof.');\n\n        // Mark it claimed and send the token.\n        _setClaimed(index);\n        require(IERC20(token).transfer(account, amount), 'AudiusClaimDistributor: Transfer failed.');\n\n        emit Claimed(index, account, amount);\n    }\n}\n";
var sourcePath = "/Users/joey/workspace/claim-distribution/contracts/AudiusClaimDistributor.sol";
var ast = {
	absolutePath: "/Users/joey/workspace/claim-distribution/contracts/AudiusClaimDistributor.sol",
	exportedSymbols: {
		AudiusClaimDistributor: [
			171
		]
	},
	id: 172,
	license: "UNLICENSED",
	nodeType: "SourceUnit",
	nodes: [
		{
			id: 1,
			literals: [
				"solidity",
				">=",
				"0.6",
				".0"
			],
			nodeType: "PragmaDirective",
			src: "39:24:0"
		},
		{
			absolutePath: "@openzeppelin/contracts/token/ERC20/IERC20.sol",
			file: "@openzeppelin/contracts/token/ERC20/IERC20.sol",
			id: 2,
			nodeType: "ImportDirective",
			scope: 172,
			sourceUnit: 354,
			src: "65:56:0",
			symbolAliases: [
			],
			unitAlias: ""
		},
		{
			absolutePath: "@openzeppelin/contracts/cryptography/MerkleProof.sol",
			file: "@openzeppelin/contracts/cryptography/MerkleProof.sol",
			id: 3,
			nodeType: "ImportDirective",
			scope: 172,
			sourceUnit: 276,
			src: "122:62:0",
			symbolAliases: [
			],
			unitAlias: ""
		},
		{
			abstract: false,
			baseContracts: [
			],
			contractDependencies: [
			],
			contractKind: "contract",
			documentation: {
				id: 4,
				nodeType: "StructuredDocumentation",
				src: "186:135:0",
				text: " Replicated from (No changes made): https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol"
			},
			fullyImplemented: true,
			id: 171,
			linearizedBaseContracts: [
				171
			],
			name: "AudiusClaimDistributor",
			nodeType: "ContractDefinition",
			nodes: [
				{
					constant: false,
					functionSelector: "fc0c546a",
					id: 6,
					mutability: "mutable",
					name: "token",
					nodeType: "VariableDeclaration",
					overrides: null,
					scope: 171,
					src: "360:20:0",
					stateVariable: true,
					storageLocation: "default",
					typeDescriptions: {
						typeIdentifier: "t_address",
						typeString: "address"
					},
					typeName: {
						id: 5,
						name: "address",
						nodeType: "ElementaryTypeName",
						src: "360:7:0",
						stateMutability: "nonpayable",
						typeDescriptions: {
							typeIdentifier: "t_address",
							typeString: "address"
						}
					},
					value: null,
					visibility: "public"
				},
				{
					constant: false,
					functionSelector: "2eb4a7ab",
					id: 8,
					mutability: "mutable",
					name: "merkleRoot",
					nodeType: "VariableDeclaration",
					overrides: null,
					scope: 171,
					src: "386:25:0",
					stateVariable: true,
					storageLocation: "default",
					typeDescriptions: {
						typeIdentifier: "t_bytes32",
						typeString: "bytes32"
					},
					typeName: {
						id: 7,
						name: "bytes32",
						nodeType: "ElementaryTypeName",
						src: "386:7:0",
						typeDescriptions: {
							typeIdentifier: "t_bytes32",
							typeString: "bytes32"
						}
					},
					value: null,
					visibility: "public"
				},
				{
					constant: false,
					id: 12,
					mutability: "mutable",
					name: "claimedBitMap",
					nodeType: "VariableDeclaration",
					overrides: null,
					scope: 171,
					src: "461:49:0",
					stateVariable: true,
					storageLocation: "default",
					typeDescriptions: {
						typeIdentifier: "t_mapping$_t_uint256_$_t_uint256_$",
						typeString: "mapping(uint256 => uint256)"
					},
					typeName: {
						id: 11,
						keyType: {
							id: 9,
							name: "uint256",
							nodeType: "ElementaryTypeName",
							src: "469:7:0",
							typeDescriptions: {
								typeIdentifier: "t_uint256",
								typeString: "uint256"
							}
						},
						nodeType: "Mapping",
						src: "461:27:0",
						typeDescriptions: {
							typeIdentifier: "t_mapping$_t_uint256_$_t_uint256_$",
							typeString: "mapping(uint256 => uint256)"
						},
						valueType: {
							id: 10,
							name: "uint256",
							nodeType: "ElementaryTypeName",
							src: "480:7:0",
							typeDescriptions: {
								typeIdentifier: "t_uint256",
								typeString: "uint256"
							}
						}
					},
					value: null,
					visibility: "private"
				},
				{
					anonymous: false,
					documentation: null,
					id: 20,
					name: "Claimed",
					nodeType: "EventDefinition",
					parameters: {
						id: 19,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 14,
								indexed: false,
								mutability: "mutable",
								name: "index",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 20,
								src: "598:13:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 13,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "598:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 16,
								indexed: false,
								mutability: "mutable",
								name: "account",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 20,
								src: "613:15:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_address",
									typeString: "address"
								},
								typeName: {
									id: 15,
									name: "address",
									nodeType: "ElementaryTypeName",
									src: "613:7:0",
									stateMutability: "nonpayable",
									typeDescriptions: {
										typeIdentifier: "t_address",
										typeString: "address"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 18,
								indexed: false,
								mutability: "mutable",
								name: "amount",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 20,
								src: "630:14:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 17,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "630:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "597:48:0"
					},
					src: "584:62:0"
				},
				{
					body: {
						id: 35,
						nodeType: "Block",
						src: "708:65:0",
						statements: [
							{
								expression: {
									argumentTypes: null,
									id: 29,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftHandSide: {
										argumentTypes: null,
										id: 27,
										name: "token",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 6,
										src: "718:5:0",
										typeDescriptions: {
											typeIdentifier: "t_address",
											typeString: "address"
										}
									},
									nodeType: "Assignment",
									operator: "=",
									rightHandSide: {
										argumentTypes: null,
										id: 28,
										name: "_token",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 22,
										src: "726:6:0",
										typeDescriptions: {
											typeIdentifier: "t_address",
											typeString: "address"
										}
									},
									src: "718:14:0",
									typeDescriptions: {
										typeIdentifier: "t_address",
										typeString: "address"
									}
								},
								id: 30,
								nodeType: "ExpressionStatement",
								src: "718:14:0"
							},
							{
								expression: {
									argumentTypes: null,
									id: 33,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftHandSide: {
										argumentTypes: null,
										id: 31,
										name: "merkleRoot",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 8,
										src: "742:10:0",
										typeDescriptions: {
											typeIdentifier: "t_bytes32",
											typeString: "bytes32"
										}
									},
									nodeType: "Assignment",
									operator: "=",
									rightHandSide: {
										argumentTypes: null,
										id: 32,
										name: "_merkleRoot",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 24,
										src: "755:11:0",
										typeDescriptions: {
											typeIdentifier: "t_bytes32",
											typeString: "bytes32"
										}
									},
									src: "742:24:0",
									typeDescriptions: {
										typeIdentifier: "t_bytes32",
										typeString: "bytes32"
									}
								},
								id: 34,
								nodeType: "ExpressionStatement",
								src: "742:24:0"
							}
						]
					},
					documentation: null,
					id: 36,
					implemented: true,
					kind: "constructor",
					modifiers: [
					],
					name: "",
					nodeType: "FunctionDefinition",
					overrides: null,
					parameters: {
						id: 25,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 22,
								mutability: "mutable",
								name: "_token",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 36,
								src: "664:14:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_address",
									typeString: "address"
								},
								typeName: {
									id: 21,
									name: "address",
									nodeType: "ElementaryTypeName",
									src: "664:7:0",
									stateMutability: "nonpayable",
									typeDescriptions: {
										typeIdentifier: "t_address",
										typeString: "address"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 24,
								mutability: "mutable",
								name: "_merkleRoot",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 36,
								src: "680:19:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_bytes32",
									typeString: "bytes32"
								},
								typeName: {
									id: 23,
									name: "bytes32",
									nodeType: "ElementaryTypeName",
									src: "680:7:0",
									typeDescriptions: {
										typeIdentifier: "t_bytes32",
										typeString: "bytes32"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "663:37:0"
					},
					returnParameters: {
						id: 26,
						nodeType: "ParameterList",
						parameters: [
						],
						src: "708:0:0"
					},
					scope: 171,
					src: "652:121:0",
					stateMutability: "nonpayable",
					virtual: false,
					visibility: "public"
				},
				{
					body: {
						id: 74,
						nodeType: "Block",
						src: "840:255:0",
						statements: [
							{
								assignments: [
									44
								],
								declarations: [
									{
										constant: false,
										id: 44,
										mutability: "mutable",
										name: "claimedWordIndex",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 74,
										src: "850:24:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 43,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "850:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 48,
								initialValue: {
									argumentTypes: null,
									commonType: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									},
									id: 47,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftExpression: {
										argumentTypes: null,
										id: 45,
										name: "index",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 38,
										src: "877:5:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "BinaryOperation",
									operator: "/",
									rightExpression: {
										argumentTypes: null,
										hexValue: "323536",
										id: 46,
										isConstant: false,
										isLValue: false,
										isPure: true,
										kind: "number",
										lValueRequested: false,
										nodeType: "Literal",
										src: "885:3:0",
										subdenomination: null,
										typeDescriptions: {
											typeIdentifier: "t_rational_256_by_1",
											typeString: "int_const 256"
										},
										value: "256"
									},
									src: "877:11:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "850:38:0"
							},
							{
								assignments: [
									50
								],
								declarations: [
									{
										constant: false,
										id: 50,
										mutability: "mutable",
										name: "claimedBitIndex",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 74,
										src: "898:23:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 49,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "898:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 54,
								initialValue: {
									argumentTypes: null,
									commonType: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									},
									id: 53,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftExpression: {
										argumentTypes: null,
										id: 51,
										name: "index",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 38,
										src: "924:5:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "BinaryOperation",
									operator: "%",
									rightExpression: {
										argumentTypes: null,
										hexValue: "323536",
										id: 52,
										isConstant: false,
										isLValue: false,
										isPure: true,
										kind: "number",
										lValueRequested: false,
										nodeType: "Literal",
										src: "932:3:0",
										subdenomination: null,
										typeDescriptions: {
											typeIdentifier: "t_rational_256_by_1",
											typeString: "int_const 256"
										},
										value: "256"
									},
									src: "924:11:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "898:37:0"
							},
							{
								assignments: [
									56
								],
								declarations: [
									{
										constant: false,
										id: 56,
										mutability: "mutable",
										name: "claimedWord",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 74,
										src: "945:19:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 55,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "945:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 60,
								initialValue: {
									argumentTypes: null,
									baseExpression: {
										argumentTypes: null,
										id: 57,
										name: "claimedBitMap",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 12,
										src: "967:13:0",
										typeDescriptions: {
											typeIdentifier: "t_mapping$_t_uint256_$_t_uint256_$",
											typeString: "mapping(uint256 => uint256)"
										}
									},
									id: 59,
									indexExpression: {
										argumentTypes: null,
										id: 58,
										name: "claimedWordIndex",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 44,
										src: "981:16:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									isConstant: false,
									isLValue: true,
									isPure: false,
									lValueRequested: false,
									nodeType: "IndexAccess",
									src: "967:31:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "945:53:0"
							},
							{
								assignments: [
									62
								],
								declarations: [
									{
										constant: false,
										id: 62,
										mutability: "mutable",
										name: "mask",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 74,
										src: "1008:12:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 61,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "1008:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 67,
								initialValue: {
									argumentTypes: null,
									components: [
										{
											argumentTypes: null,
											commonType: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											},
											id: 65,
											isConstant: false,
											isLValue: false,
											isPure: false,
											lValueRequested: false,
											leftExpression: {
												argumentTypes: null,
												hexValue: "31",
												id: 63,
												isConstant: false,
												isLValue: false,
												isPure: true,
												kind: "number",
												lValueRequested: false,
												nodeType: "Literal",
												src: "1024:1:0",
												subdenomination: null,
												typeDescriptions: {
													typeIdentifier: "t_rational_1_by_1",
													typeString: "int_const 1"
												},
												value: "1"
											},
											nodeType: "BinaryOperation",
											operator: "<<",
											rightExpression: {
												argumentTypes: null,
												id: 64,
												name: "claimedBitIndex",
												nodeType: "Identifier",
												overloadedDeclarations: [
												],
												referencedDeclaration: 50,
												src: "1029:15:0",
												typeDescriptions: {
													typeIdentifier: "t_uint256",
													typeString: "uint256"
												}
											},
											src: "1024:20:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										}
									],
									id: 66,
									isConstant: false,
									isInlineArray: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									nodeType: "TupleExpression",
									src: "1023:22:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "1008:37:0"
							},
							{
								expression: {
									argumentTypes: null,
									commonType: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									},
									id: 72,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftExpression: {
										argumentTypes: null,
										commonType: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										id: 70,
										isConstant: false,
										isLValue: false,
										isPure: false,
										lValueRequested: false,
										leftExpression: {
											argumentTypes: null,
											id: 68,
											name: "claimedWord",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 56,
											src: "1062:11:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										nodeType: "BinaryOperation",
										operator: "&",
										rightExpression: {
											argumentTypes: null,
											id: 69,
											name: "mask",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 62,
											src: "1076:4:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										src: "1062:18:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "BinaryOperation",
									operator: "==",
									rightExpression: {
										argumentTypes: null,
										id: 71,
										name: "mask",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 62,
										src: "1084:4:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									src: "1062:26:0",
									typeDescriptions: {
										typeIdentifier: "t_bool",
										typeString: "bool"
									}
								},
								functionReturnParameters: 42,
								id: 73,
								nodeType: "Return",
								src: "1055:33:0"
							}
						]
					},
					documentation: null,
					functionSelector: "9e34070f",
					id: 75,
					implemented: true,
					kind: "function",
					modifiers: [
					],
					name: "isClaimed",
					nodeType: "FunctionDefinition",
					overrides: null,
					parameters: {
						id: 39,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 38,
								mutability: "mutable",
								name: "index",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 75,
								src: "798:13:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 37,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "798:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "797:15:0"
					},
					returnParameters: {
						id: 42,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 41,
								mutability: "mutable",
								name: "",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 75,
								src: "834:4:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_bool",
									typeString: "bool"
								},
								typeName: {
									id: 40,
									name: "bool",
									nodeType: "ElementaryTypeName",
									src: "834:4:0",
									typeDescriptions: {
										typeIdentifier: "t_bool",
										typeString: "bool"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "833:6:0"
					},
					scope: 171,
					src: "779:316:0",
					stateMutability: "view",
					virtual: false,
					visibility: "public"
				},
				{
					body: {
						id: 105,
						nodeType: "Block",
						src: "1145:202:0",
						statements: [
							{
								assignments: [
									81
								],
								declarations: [
									{
										constant: false,
										id: 81,
										mutability: "mutable",
										name: "claimedWordIndex",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 105,
										src: "1155:24:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 80,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "1155:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 85,
								initialValue: {
									argumentTypes: null,
									commonType: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									},
									id: 84,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftExpression: {
										argumentTypes: null,
										id: 82,
										name: "index",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 77,
										src: "1182:5:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "BinaryOperation",
									operator: "/",
									rightExpression: {
										argumentTypes: null,
										hexValue: "323536",
										id: 83,
										isConstant: false,
										isLValue: false,
										isPure: true,
										kind: "number",
										lValueRequested: false,
										nodeType: "Literal",
										src: "1190:3:0",
										subdenomination: null,
										typeDescriptions: {
											typeIdentifier: "t_rational_256_by_1",
											typeString: "int_const 256"
										},
										value: "256"
									},
									src: "1182:11:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "1155:38:0"
							},
							{
								assignments: [
									87
								],
								declarations: [
									{
										constant: false,
										id: 87,
										mutability: "mutable",
										name: "claimedBitIndex",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 105,
										src: "1203:23:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 86,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "1203:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 91,
								initialValue: {
									argumentTypes: null,
									commonType: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									},
									id: 90,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftExpression: {
										argumentTypes: null,
										id: 88,
										name: "index",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 77,
										src: "1229:5:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "BinaryOperation",
									operator: "%",
									rightExpression: {
										argumentTypes: null,
										hexValue: "323536",
										id: 89,
										isConstant: false,
										isLValue: false,
										isPure: true,
										kind: "number",
										lValueRequested: false,
										nodeType: "Literal",
										src: "1237:3:0",
										subdenomination: null,
										typeDescriptions: {
											typeIdentifier: "t_rational_256_by_1",
											typeString: "int_const 256"
										},
										value: "256"
									},
									src: "1229:11:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "1203:37:0"
							},
							{
								expression: {
									argumentTypes: null,
									id: 103,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftHandSide: {
										argumentTypes: null,
										baseExpression: {
											argumentTypes: null,
											id: 92,
											name: "claimedBitMap",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 12,
											src: "1250:13:0",
											typeDescriptions: {
												typeIdentifier: "t_mapping$_t_uint256_$_t_uint256_$",
												typeString: "mapping(uint256 => uint256)"
											}
										},
										id: 94,
										indexExpression: {
											argumentTypes: null,
											id: 93,
											name: "claimedWordIndex",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 81,
											src: "1264:16:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										isConstant: false,
										isLValue: true,
										isPure: false,
										lValueRequested: true,
										nodeType: "IndexAccess",
										src: "1250:31:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "Assignment",
									operator: "=",
									rightHandSide: {
										argumentTypes: null,
										commonType: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										id: 102,
										isConstant: false,
										isLValue: false,
										isPure: false,
										lValueRequested: false,
										leftExpression: {
											argumentTypes: null,
											baseExpression: {
												argumentTypes: null,
												id: 95,
												name: "claimedBitMap",
												nodeType: "Identifier",
												overloadedDeclarations: [
												],
												referencedDeclaration: 12,
												src: "1284:13:0",
												typeDescriptions: {
													typeIdentifier: "t_mapping$_t_uint256_$_t_uint256_$",
													typeString: "mapping(uint256 => uint256)"
												}
											},
											id: 97,
											indexExpression: {
												argumentTypes: null,
												id: 96,
												name: "claimedWordIndex",
												nodeType: "Identifier",
												overloadedDeclarations: [
												],
												referencedDeclaration: 81,
												src: "1298:16:0",
												typeDescriptions: {
													typeIdentifier: "t_uint256",
													typeString: "uint256"
												}
											},
											isConstant: false,
											isLValue: true,
											isPure: false,
											lValueRequested: false,
											nodeType: "IndexAccess",
											src: "1284:31:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										nodeType: "BinaryOperation",
										operator: "|",
										rightExpression: {
											argumentTypes: null,
											components: [
												{
													argumentTypes: null,
													commonType: {
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													},
													id: 100,
													isConstant: false,
													isLValue: false,
													isPure: false,
													lValueRequested: false,
													leftExpression: {
														argumentTypes: null,
														hexValue: "31",
														id: 98,
														isConstant: false,
														isLValue: false,
														isPure: true,
														kind: "number",
														lValueRequested: false,
														nodeType: "Literal",
														src: "1319:1:0",
														subdenomination: null,
														typeDescriptions: {
															typeIdentifier: "t_rational_1_by_1",
															typeString: "int_const 1"
														},
														value: "1"
													},
													nodeType: "BinaryOperation",
													operator: "<<",
													rightExpression: {
														argumentTypes: null,
														id: 99,
														name: "claimedBitIndex",
														nodeType: "Identifier",
														overloadedDeclarations: [
														],
														referencedDeclaration: 87,
														src: "1324:15:0",
														typeDescriptions: {
															typeIdentifier: "t_uint256",
															typeString: "uint256"
														}
													},
													src: "1319:20:0",
													typeDescriptions: {
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												}
											],
											id: 101,
											isConstant: false,
											isInlineArray: false,
											isLValue: false,
											isPure: false,
											lValueRequested: false,
											nodeType: "TupleExpression",
											src: "1318:22:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										src: "1284:56:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									src: "1250:90:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								id: 104,
								nodeType: "ExpressionStatement",
								src: "1250:90:0"
							}
						]
					},
					documentation: null,
					id: 106,
					implemented: true,
					kind: "function",
					modifiers: [
					],
					name: "_setClaimed",
					nodeType: "FunctionDefinition",
					overrides: null,
					parameters: {
						id: 78,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 77,
								mutability: "mutable",
								name: "index",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 106,
								src: "1122:13:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 76,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "1122:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "1121:15:0"
					},
					returnParameters: {
						id: 79,
						nodeType: "ParameterList",
						parameters: [
						],
						src: "1145:0:0"
					},
					scope: 171,
					src: "1101:246:0",
					stateMutability: "nonpayable",
					virtual: false,
					visibility: "private"
				},
				{
					body: {
						id: 169,
						nodeType: "Block",
						src: "1728:540:0",
						statements: [
							{
								expression: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											id: 123,
											isConstant: false,
											isLValue: false,
											isPure: false,
											lValueRequested: false,
											nodeType: "UnaryOperation",
											operator: "!",
											prefix: true,
											src: "1746:17:0",
											subExpression: {
												argumentTypes: null,
												"arguments": [
													{
														argumentTypes: null,
														id: 121,
														name: "index",
														nodeType: "Identifier",
														overloadedDeclarations: [
														],
														referencedDeclaration: 109,
														src: "1757:5:0",
														typeDescriptions: {
															typeIdentifier: "t_uint256",
															typeString: "uint256"
														}
													}
												],
												expression: {
													argumentTypes: [
														{
															typeIdentifier: "t_uint256",
															typeString: "uint256"
														}
													],
													id: 120,
													name: "isClaimed",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 75,
													src: "1747:9:0",
													typeDescriptions: {
														typeIdentifier: "t_function_internal_view$_t_uint256_$returns$_t_bool_$",
														typeString: "function (uint256) view returns (bool)"
													}
												},
												id: 122,
												isConstant: false,
												isLValue: false,
												isPure: false,
												kind: "functionCall",
												lValueRequested: false,
												names: [
												],
												nodeType: "FunctionCall",
												src: "1747:16:0",
												tryCall: false,
												typeDescriptions: {
													typeIdentifier: "t_bool",
													typeString: "bool"
												}
											},
											typeDescriptions: {
												typeIdentifier: "t_bool",
												typeString: "bool"
											}
										},
										{
											argumentTypes: null,
											hexValue: "417564697573436c61696d4469737472696275746f723a2044726f7020616c726561647920636c61696d65642e",
											id: 124,
											isConstant: false,
											isLValue: false,
											isPure: true,
											kind: "string",
											lValueRequested: false,
											nodeType: "Literal",
											src: "1765:47:0",
											subdenomination: null,
											typeDescriptions: {
												typeIdentifier: "t_stringliteral_ed031b8cd6efd0b5d6ac7d06318772f4c89447859d54d5d6480f786c223a95d7",
												typeString: "literal_string \"AudiusClaimDistributor: Drop already claimed.\""
											},
											value: "AudiusClaimDistributor: Drop already claimed."
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_bool",
												typeString: "bool"
											},
											{
												typeIdentifier: "t_stringliteral_ed031b8cd6efd0b5d6ac7d06318772f4c89447859d54d5d6480f786c223a95d7",
												typeString: "literal_string \"AudiusClaimDistributor: Drop already claimed.\""
											}
										],
										id: 119,
										name: "require",
										nodeType: "Identifier",
										overloadedDeclarations: [
											-18,
											-18
										],
										referencedDeclaration: -18,
										src: "1738:7:0",
										typeDescriptions: {
											typeIdentifier: "t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$",
											typeString: "function (bool,string memory) pure"
										}
									},
									id: 125,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "1738:75:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_tuple$__$",
										typeString: "tuple()"
									}
								},
								id: 126,
								nodeType: "ExpressionStatement",
								src: "1738:75:0"
							},
							{
								assignments: [
									128
								],
								declarations: [
									{
										constant: false,
										id: 128,
										mutability: "mutable",
										name: "node",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 169,
										src: "1860:12:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_bytes32",
											typeString: "bytes32"
										},
										typeName: {
											id: 127,
											name: "bytes32",
											nodeType: "ElementaryTypeName",
											src: "1860:7:0",
											typeDescriptions: {
												typeIdentifier: "t_bytes32",
												typeString: "bytes32"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 137,
								initialValue: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											"arguments": [
												{
													argumentTypes: null,
													id: 132,
													name: "index",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 109,
													src: "1902:5:0",
													typeDescriptions: {
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												},
												{
													argumentTypes: null,
													id: 133,
													name: "account",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 111,
													src: "1909:7:0",
													typeDescriptions: {
														typeIdentifier: "t_address",
														typeString: "address"
													}
												},
												{
													argumentTypes: null,
													id: 134,
													name: "amount",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 113,
													src: "1918:6:0",
													typeDescriptions: {
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												}
											],
											expression: {
												argumentTypes: [
													{
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													},
													{
														typeIdentifier: "t_address",
														typeString: "address"
													},
													{
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												],
												expression: {
													argumentTypes: null,
													id: 130,
													name: "abi",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: -1,
													src: "1885:3:0",
													typeDescriptions: {
														typeIdentifier: "t_magic_abi",
														typeString: "abi"
													}
												},
												id: 131,
												isConstant: false,
												isLValue: false,
												isPure: true,
												lValueRequested: false,
												memberName: "encodePacked",
												nodeType: "MemberAccess",
												referencedDeclaration: null,
												src: "1885:16:0",
												typeDescriptions: {
													typeIdentifier: "t_function_abiencodepacked_pure$__$returns$_t_bytes_memory_ptr_$",
													typeString: "function () pure returns (bytes memory)"
												}
											},
											id: 135,
											isConstant: false,
											isLValue: false,
											isPure: false,
											kind: "functionCall",
											lValueRequested: false,
											names: [
											],
											nodeType: "FunctionCall",
											src: "1885:40:0",
											tryCall: false,
											typeDescriptions: {
												typeIdentifier: "t_bytes_memory_ptr",
												typeString: "bytes memory"
											}
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_bytes_memory_ptr",
												typeString: "bytes memory"
											}
										],
										id: 129,
										name: "keccak256",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: -8,
										src: "1875:9:0",
										typeDescriptions: {
											typeIdentifier: "t_function_keccak256_pure$_t_bytes_memory_ptr_$returns$_t_bytes32_$",
											typeString: "function (bytes memory) pure returns (bytes32)"
										}
									},
									id: 136,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "1875:51:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_bytes32",
										typeString: "bytes32"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "1860:66:0"
							},
							{
								expression: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											"arguments": [
												{
													argumentTypes: null,
													id: 141,
													name: "merkleProof",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 116,
													src: "1963:11:0",
													typeDescriptions: {
														typeIdentifier: "t_array$_t_bytes32_$dyn_calldata_ptr",
														typeString: "bytes32[] calldata"
													}
												},
												{
													argumentTypes: null,
													id: 142,
													name: "merkleRoot",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 8,
													src: "1976:10:0",
													typeDescriptions: {
														typeIdentifier: "t_bytes32",
														typeString: "bytes32"
													}
												},
												{
													argumentTypes: null,
													id: 143,
													name: "node",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 128,
													src: "1988:4:0",
													typeDescriptions: {
														typeIdentifier: "t_bytes32",
														typeString: "bytes32"
													}
												}
											],
											expression: {
												argumentTypes: [
													{
														typeIdentifier: "t_array$_t_bytes32_$dyn_calldata_ptr",
														typeString: "bytes32[] calldata"
													},
													{
														typeIdentifier: "t_bytes32",
														typeString: "bytes32"
													},
													{
														typeIdentifier: "t_bytes32",
														typeString: "bytes32"
													}
												],
												expression: {
													argumentTypes: null,
													id: 139,
													name: "MerkleProof",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 275,
													src: "1944:11:0",
													typeDescriptions: {
														typeIdentifier: "t_type$_t_contract$_MerkleProof_$275_$",
														typeString: "type(library MerkleProof)"
													}
												},
												id: 140,
												isConstant: false,
												isLValue: false,
												isPure: false,
												lValueRequested: false,
												memberName: "verify",
												nodeType: "MemberAccess",
												referencedDeclaration: 274,
												src: "1944:18:0",
												typeDescriptions: {
													typeIdentifier: "t_function_internal_pure$_t_array$_t_bytes32_$dyn_memory_ptr_$_t_bytes32_$_t_bytes32_$returns$_t_bool_$",
													typeString: "function (bytes32[] memory,bytes32,bytes32) pure returns (bool)"
												}
											},
											id: 144,
											isConstant: false,
											isLValue: false,
											isPure: false,
											kind: "functionCall",
											lValueRequested: false,
											names: [
											],
											nodeType: "FunctionCall",
											src: "1944:49:0",
											tryCall: false,
											typeDescriptions: {
												typeIdentifier: "t_bool",
												typeString: "bool"
											}
										},
										{
											argumentTypes: null,
											hexValue: "417564697573436c61696d4469737472696275746f723a20496e76616c69642070726f6f662e",
											id: 145,
											isConstant: false,
											isLValue: false,
											isPure: true,
											kind: "string",
											lValueRequested: false,
											nodeType: "Literal",
											src: "1995:40:0",
											subdenomination: null,
											typeDescriptions: {
												typeIdentifier: "t_stringliteral_7e9ffaab8cc82fbdaf04569850ace67a05c1344deee101d0ef5ac2442c295c75",
												typeString: "literal_string \"AudiusClaimDistributor: Invalid proof.\""
											},
											value: "AudiusClaimDistributor: Invalid proof."
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_bool",
												typeString: "bool"
											},
											{
												typeIdentifier: "t_stringliteral_7e9ffaab8cc82fbdaf04569850ace67a05c1344deee101d0ef5ac2442c295c75",
												typeString: "literal_string \"AudiusClaimDistributor: Invalid proof.\""
											}
										],
										id: 138,
										name: "require",
										nodeType: "Identifier",
										overloadedDeclarations: [
											-18,
											-18
										],
										referencedDeclaration: -18,
										src: "1936:7:0",
										typeDescriptions: {
											typeIdentifier: "t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$",
											typeString: "function (bool,string memory) pure"
										}
									},
									id: 146,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "1936:100:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_tuple$__$",
										typeString: "tuple()"
									}
								},
								id: 147,
								nodeType: "ExpressionStatement",
								src: "1936:100:0"
							},
							{
								expression: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											id: 149,
											name: "index",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 109,
											src: "2106:5:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										],
										id: 148,
										name: "_setClaimed",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 106,
										src: "2094:11:0",
										typeDescriptions: {
											typeIdentifier: "t_function_internal_nonpayable$_t_uint256_$returns$__$",
											typeString: "function (uint256)"
										}
									},
									id: 150,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "2094:18:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_tuple$__$",
										typeString: "tuple()"
									}
								},
								id: 151,
								nodeType: "ExpressionStatement",
								src: "2094:18:0"
							},
							{
								expression: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											"arguments": [
												{
													argumentTypes: null,
													id: 157,
													name: "account",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 111,
													src: "2153:7:0",
													typeDescriptions: {
														typeIdentifier: "t_address",
														typeString: "address"
													}
												},
												{
													argumentTypes: null,
													id: 158,
													name: "amount",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 113,
													src: "2162:6:0",
													typeDescriptions: {
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												}
											],
											expression: {
												argumentTypes: [
													{
														typeIdentifier: "t_address",
														typeString: "address"
													},
													{
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												],
												expression: {
													argumentTypes: null,
													"arguments": [
														{
															argumentTypes: null,
															id: 154,
															name: "token",
															nodeType: "Identifier",
															overloadedDeclarations: [
															],
															referencedDeclaration: 6,
															src: "2137:5:0",
															typeDescriptions: {
																typeIdentifier: "t_address",
																typeString: "address"
															}
														}
													],
													expression: {
														argumentTypes: [
															{
																typeIdentifier: "t_address",
																typeString: "address"
															}
														],
														id: 153,
														name: "IERC20",
														nodeType: "Identifier",
														overloadedDeclarations: [
														],
														referencedDeclaration: 353,
														src: "2130:6:0",
														typeDescriptions: {
															typeIdentifier: "t_type$_t_contract$_IERC20_$353_$",
															typeString: "type(contract IERC20)"
														}
													},
													id: 155,
													isConstant: false,
													isLValue: false,
													isPure: false,
													kind: "typeConversion",
													lValueRequested: false,
													names: [
													],
													nodeType: "FunctionCall",
													src: "2130:13:0",
													tryCall: false,
													typeDescriptions: {
														typeIdentifier: "t_contract$_IERC20_$353",
														typeString: "contract IERC20"
													}
												},
												id: 156,
												isConstant: false,
												isLValue: false,
												isPure: false,
												lValueRequested: false,
												memberName: "transfer",
												nodeType: "MemberAccess",
												referencedDeclaration: 302,
												src: "2130:22:0",
												typeDescriptions: {
													typeIdentifier: "t_function_external_nonpayable$_t_address_$_t_uint256_$returns$_t_bool_$",
													typeString: "function (address,uint256) external returns (bool)"
												}
											},
											id: 159,
											isConstant: false,
											isLValue: false,
											isPure: false,
											kind: "functionCall",
											lValueRequested: false,
											names: [
											],
											nodeType: "FunctionCall",
											src: "2130:39:0",
											tryCall: false,
											typeDescriptions: {
												typeIdentifier: "t_bool",
												typeString: "bool"
											}
										},
										{
											argumentTypes: null,
											hexValue: "417564697573436c61696d4469737472696275746f723a205472616e73666572206661696c65642e",
											id: 160,
											isConstant: false,
											isLValue: false,
											isPure: true,
											kind: "string",
											lValueRequested: false,
											nodeType: "Literal",
											src: "2171:42:0",
											subdenomination: null,
											typeDescriptions: {
												typeIdentifier: "t_stringliteral_a6ebd4450fbab8083d490c08fa5d0914a1bac0ff76772ca40012e669f531dfa3",
												typeString: "literal_string \"AudiusClaimDistributor: Transfer failed.\""
											},
											value: "AudiusClaimDistributor: Transfer failed."
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_bool",
												typeString: "bool"
											},
											{
												typeIdentifier: "t_stringliteral_a6ebd4450fbab8083d490c08fa5d0914a1bac0ff76772ca40012e669f531dfa3",
												typeString: "literal_string \"AudiusClaimDistributor: Transfer failed.\""
											}
										],
										id: 152,
										name: "require",
										nodeType: "Identifier",
										overloadedDeclarations: [
											-18,
											-18
										],
										referencedDeclaration: -18,
										src: "2122:7:0",
										typeDescriptions: {
											typeIdentifier: "t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$",
											typeString: "function (bool,string memory) pure"
										}
									},
									id: 161,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "2122:92:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_tuple$__$",
										typeString: "tuple()"
									}
								},
								id: 162,
								nodeType: "ExpressionStatement",
								src: "2122:92:0"
							},
							{
								eventCall: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											id: 164,
											name: "index",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 109,
											src: "2238:5:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										{
											argumentTypes: null,
											id: 165,
											name: "account",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 111,
											src: "2245:7:0",
											typeDescriptions: {
												typeIdentifier: "t_address",
												typeString: "address"
											}
										},
										{
											argumentTypes: null,
											id: 166,
											name: "amount",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 113,
											src: "2254:6:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											},
											{
												typeIdentifier: "t_address",
												typeString: "address"
											},
											{
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										],
										id: 163,
										name: "Claimed",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 20,
										src: "2230:7:0",
										typeDescriptions: {
											typeIdentifier: "t_function_event_nonpayable$_t_uint256_$_t_address_$_t_uint256_$returns$__$",
											typeString: "function (uint256,address,uint256)"
										}
									},
									id: 167,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "2230:31:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_tuple$__$",
										typeString: "tuple()"
									}
								},
								id: 168,
								nodeType: "EmitStatement",
								src: "2225:36:0"
							}
						]
					},
					documentation: {
						id: 107,
						nodeType: "StructuredDocumentation",
						src: "1353:266:0",
						text: " No caller permissioning needed since token is transfered to account argument,\n    and there is no incentive to call function for another account.\n Can only submit claim for full claimable amount, otherwise proof verification will fail."
					},
					functionSelector: "2e7ba6ef",
					id: 170,
					implemented: true,
					kind: "function",
					modifiers: [
					],
					name: "claim",
					nodeType: "FunctionDefinition",
					overrides: null,
					parameters: {
						id: 117,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 109,
								mutability: "mutable",
								name: "index",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 170,
								src: "1639:13:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 108,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "1639:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 111,
								mutability: "mutable",
								name: "account",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 170,
								src: "1654:15:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_address",
									typeString: "address"
								},
								typeName: {
									id: 110,
									name: "address",
									nodeType: "ElementaryTypeName",
									src: "1654:7:0",
									stateMutability: "nonpayable",
									typeDescriptions: {
										typeIdentifier: "t_address",
										typeString: "address"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 113,
								mutability: "mutable",
								name: "amount",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 170,
								src: "1671:14:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 112,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "1671:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 116,
								mutability: "mutable",
								name: "merkleProof",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 170,
								src: "1687:30:0",
								stateVariable: false,
								storageLocation: "calldata",
								typeDescriptions: {
									typeIdentifier: "t_array$_t_bytes32_$dyn_calldata_ptr",
									typeString: "bytes32[]"
								},
								typeName: {
									baseType: {
										id: 114,
										name: "bytes32",
										nodeType: "ElementaryTypeName",
										src: "1687:7:0",
										typeDescriptions: {
											typeIdentifier: "t_bytes32",
											typeString: "bytes32"
										}
									},
									id: 115,
									length: null,
									nodeType: "ArrayTypeName",
									src: "1687:9:0",
									typeDescriptions: {
										typeIdentifier: "t_array$_t_bytes32_$dyn_storage_ptr",
										typeString: "bytes32[]"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "1638:80:0"
					},
					returnParameters: {
						id: 118,
						nodeType: "ParameterList",
						parameters: [
						],
						src: "1728:0:0"
					},
					scope: 171,
					src: "1624:644:0",
					stateMutability: "nonpayable",
					virtual: false,
					visibility: "external"
				}
			],
			scope: 172,
			src: "322:1948:0"
		}
	],
	src: "39:2232:0"
};
var legacyAST = {
	absolutePath: "/Users/joey/workspace/claim-distribution/contracts/AudiusClaimDistributor.sol",
	exportedSymbols: {
		AudiusClaimDistributor: [
			171
		]
	},
	id: 172,
	license: "UNLICENSED",
	nodeType: "SourceUnit",
	nodes: [
		{
			id: 1,
			literals: [
				"solidity",
				">=",
				"0.6",
				".0"
			],
			nodeType: "PragmaDirective",
			src: "39:24:0"
		},
		{
			absolutePath: "@openzeppelin/contracts/token/ERC20/IERC20.sol",
			file: "@openzeppelin/contracts/token/ERC20/IERC20.sol",
			id: 2,
			nodeType: "ImportDirective",
			scope: 172,
			sourceUnit: 354,
			src: "65:56:0",
			symbolAliases: [
			],
			unitAlias: ""
		},
		{
			absolutePath: "@openzeppelin/contracts/cryptography/MerkleProof.sol",
			file: "@openzeppelin/contracts/cryptography/MerkleProof.sol",
			id: 3,
			nodeType: "ImportDirective",
			scope: 172,
			sourceUnit: 276,
			src: "122:62:0",
			symbolAliases: [
			],
			unitAlias: ""
		},
		{
			abstract: false,
			baseContracts: [
			],
			contractDependencies: [
			],
			contractKind: "contract",
			documentation: {
				id: 4,
				nodeType: "StructuredDocumentation",
				src: "186:135:0",
				text: " Replicated from (No changes made): https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol"
			},
			fullyImplemented: true,
			id: 171,
			linearizedBaseContracts: [
				171
			],
			name: "AudiusClaimDistributor",
			nodeType: "ContractDefinition",
			nodes: [
				{
					constant: false,
					functionSelector: "fc0c546a",
					id: 6,
					mutability: "mutable",
					name: "token",
					nodeType: "VariableDeclaration",
					overrides: null,
					scope: 171,
					src: "360:20:0",
					stateVariable: true,
					storageLocation: "default",
					typeDescriptions: {
						typeIdentifier: "t_address",
						typeString: "address"
					},
					typeName: {
						id: 5,
						name: "address",
						nodeType: "ElementaryTypeName",
						src: "360:7:0",
						stateMutability: "nonpayable",
						typeDescriptions: {
							typeIdentifier: "t_address",
							typeString: "address"
						}
					},
					value: null,
					visibility: "public"
				},
				{
					constant: false,
					functionSelector: "2eb4a7ab",
					id: 8,
					mutability: "mutable",
					name: "merkleRoot",
					nodeType: "VariableDeclaration",
					overrides: null,
					scope: 171,
					src: "386:25:0",
					stateVariable: true,
					storageLocation: "default",
					typeDescriptions: {
						typeIdentifier: "t_bytes32",
						typeString: "bytes32"
					},
					typeName: {
						id: 7,
						name: "bytes32",
						nodeType: "ElementaryTypeName",
						src: "386:7:0",
						typeDescriptions: {
							typeIdentifier: "t_bytes32",
							typeString: "bytes32"
						}
					},
					value: null,
					visibility: "public"
				},
				{
					constant: false,
					id: 12,
					mutability: "mutable",
					name: "claimedBitMap",
					nodeType: "VariableDeclaration",
					overrides: null,
					scope: 171,
					src: "461:49:0",
					stateVariable: true,
					storageLocation: "default",
					typeDescriptions: {
						typeIdentifier: "t_mapping$_t_uint256_$_t_uint256_$",
						typeString: "mapping(uint256 => uint256)"
					},
					typeName: {
						id: 11,
						keyType: {
							id: 9,
							name: "uint256",
							nodeType: "ElementaryTypeName",
							src: "469:7:0",
							typeDescriptions: {
								typeIdentifier: "t_uint256",
								typeString: "uint256"
							}
						},
						nodeType: "Mapping",
						src: "461:27:0",
						typeDescriptions: {
							typeIdentifier: "t_mapping$_t_uint256_$_t_uint256_$",
							typeString: "mapping(uint256 => uint256)"
						},
						valueType: {
							id: 10,
							name: "uint256",
							nodeType: "ElementaryTypeName",
							src: "480:7:0",
							typeDescriptions: {
								typeIdentifier: "t_uint256",
								typeString: "uint256"
							}
						}
					},
					value: null,
					visibility: "private"
				},
				{
					anonymous: false,
					documentation: null,
					id: 20,
					name: "Claimed",
					nodeType: "EventDefinition",
					parameters: {
						id: 19,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 14,
								indexed: false,
								mutability: "mutable",
								name: "index",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 20,
								src: "598:13:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 13,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "598:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 16,
								indexed: false,
								mutability: "mutable",
								name: "account",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 20,
								src: "613:15:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_address",
									typeString: "address"
								},
								typeName: {
									id: 15,
									name: "address",
									nodeType: "ElementaryTypeName",
									src: "613:7:0",
									stateMutability: "nonpayable",
									typeDescriptions: {
										typeIdentifier: "t_address",
										typeString: "address"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 18,
								indexed: false,
								mutability: "mutable",
								name: "amount",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 20,
								src: "630:14:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 17,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "630:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "597:48:0"
					},
					src: "584:62:0"
				},
				{
					body: {
						id: 35,
						nodeType: "Block",
						src: "708:65:0",
						statements: [
							{
								expression: {
									argumentTypes: null,
									id: 29,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftHandSide: {
										argumentTypes: null,
										id: 27,
										name: "token",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 6,
										src: "718:5:0",
										typeDescriptions: {
											typeIdentifier: "t_address",
											typeString: "address"
										}
									},
									nodeType: "Assignment",
									operator: "=",
									rightHandSide: {
										argumentTypes: null,
										id: 28,
										name: "_token",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 22,
										src: "726:6:0",
										typeDescriptions: {
											typeIdentifier: "t_address",
											typeString: "address"
										}
									},
									src: "718:14:0",
									typeDescriptions: {
										typeIdentifier: "t_address",
										typeString: "address"
									}
								},
								id: 30,
								nodeType: "ExpressionStatement",
								src: "718:14:0"
							},
							{
								expression: {
									argumentTypes: null,
									id: 33,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftHandSide: {
										argumentTypes: null,
										id: 31,
										name: "merkleRoot",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 8,
										src: "742:10:0",
										typeDescriptions: {
											typeIdentifier: "t_bytes32",
											typeString: "bytes32"
										}
									},
									nodeType: "Assignment",
									operator: "=",
									rightHandSide: {
										argumentTypes: null,
										id: 32,
										name: "_merkleRoot",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 24,
										src: "755:11:0",
										typeDescriptions: {
											typeIdentifier: "t_bytes32",
											typeString: "bytes32"
										}
									},
									src: "742:24:0",
									typeDescriptions: {
										typeIdentifier: "t_bytes32",
										typeString: "bytes32"
									}
								},
								id: 34,
								nodeType: "ExpressionStatement",
								src: "742:24:0"
							}
						]
					},
					documentation: null,
					id: 36,
					implemented: true,
					kind: "constructor",
					modifiers: [
					],
					name: "",
					nodeType: "FunctionDefinition",
					overrides: null,
					parameters: {
						id: 25,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 22,
								mutability: "mutable",
								name: "_token",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 36,
								src: "664:14:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_address",
									typeString: "address"
								},
								typeName: {
									id: 21,
									name: "address",
									nodeType: "ElementaryTypeName",
									src: "664:7:0",
									stateMutability: "nonpayable",
									typeDescriptions: {
										typeIdentifier: "t_address",
										typeString: "address"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 24,
								mutability: "mutable",
								name: "_merkleRoot",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 36,
								src: "680:19:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_bytes32",
									typeString: "bytes32"
								},
								typeName: {
									id: 23,
									name: "bytes32",
									nodeType: "ElementaryTypeName",
									src: "680:7:0",
									typeDescriptions: {
										typeIdentifier: "t_bytes32",
										typeString: "bytes32"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "663:37:0"
					},
					returnParameters: {
						id: 26,
						nodeType: "ParameterList",
						parameters: [
						],
						src: "708:0:0"
					},
					scope: 171,
					src: "652:121:0",
					stateMutability: "nonpayable",
					virtual: false,
					visibility: "public"
				},
				{
					body: {
						id: 74,
						nodeType: "Block",
						src: "840:255:0",
						statements: [
							{
								assignments: [
									44
								],
								declarations: [
									{
										constant: false,
										id: 44,
										mutability: "mutable",
										name: "claimedWordIndex",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 74,
										src: "850:24:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 43,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "850:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 48,
								initialValue: {
									argumentTypes: null,
									commonType: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									},
									id: 47,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftExpression: {
										argumentTypes: null,
										id: 45,
										name: "index",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 38,
										src: "877:5:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "BinaryOperation",
									operator: "/",
									rightExpression: {
										argumentTypes: null,
										hexValue: "323536",
										id: 46,
										isConstant: false,
										isLValue: false,
										isPure: true,
										kind: "number",
										lValueRequested: false,
										nodeType: "Literal",
										src: "885:3:0",
										subdenomination: null,
										typeDescriptions: {
											typeIdentifier: "t_rational_256_by_1",
											typeString: "int_const 256"
										},
										value: "256"
									},
									src: "877:11:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "850:38:0"
							},
							{
								assignments: [
									50
								],
								declarations: [
									{
										constant: false,
										id: 50,
										mutability: "mutable",
										name: "claimedBitIndex",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 74,
										src: "898:23:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 49,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "898:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 54,
								initialValue: {
									argumentTypes: null,
									commonType: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									},
									id: 53,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftExpression: {
										argumentTypes: null,
										id: 51,
										name: "index",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 38,
										src: "924:5:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "BinaryOperation",
									operator: "%",
									rightExpression: {
										argumentTypes: null,
										hexValue: "323536",
										id: 52,
										isConstant: false,
										isLValue: false,
										isPure: true,
										kind: "number",
										lValueRequested: false,
										nodeType: "Literal",
										src: "932:3:0",
										subdenomination: null,
										typeDescriptions: {
											typeIdentifier: "t_rational_256_by_1",
											typeString: "int_const 256"
										},
										value: "256"
									},
									src: "924:11:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "898:37:0"
							},
							{
								assignments: [
									56
								],
								declarations: [
									{
										constant: false,
										id: 56,
										mutability: "mutable",
										name: "claimedWord",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 74,
										src: "945:19:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 55,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "945:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 60,
								initialValue: {
									argumentTypes: null,
									baseExpression: {
										argumentTypes: null,
										id: 57,
										name: "claimedBitMap",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 12,
										src: "967:13:0",
										typeDescriptions: {
											typeIdentifier: "t_mapping$_t_uint256_$_t_uint256_$",
											typeString: "mapping(uint256 => uint256)"
										}
									},
									id: 59,
									indexExpression: {
										argumentTypes: null,
										id: 58,
										name: "claimedWordIndex",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 44,
										src: "981:16:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									isConstant: false,
									isLValue: true,
									isPure: false,
									lValueRequested: false,
									nodeType: "IndexAccess",
									src: "967:31:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "945:53:0"
							},
							{
								assignments: [
									62
								],
								declarations: [
									{
										constant: false,
										id: 62,
										mutability: "mutable",
										name: "mask",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 74,
										src: "1008:12:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 61,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "1008:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 67,
								initialValue: {
									argumentTypes: null,
									components: [
										{
											argumentTypes: null,
											commonType: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											},
											id: 65,
											isConstant: false,
											isLValue: false,
											isPure: false,
											lValueRequested: false,
											leftExpression: {
												argumentTypes: null,
												hexValue: "31",
												id: 63,
												isConstant: false,
												isLValue: false,
												isPure: true,
												kind: "number",
												lValueRequested: false,
												nodeType: "Literal",
												src: "1024:1:0",
												subdenomination: null,
												typeDescriptions: {
													typeIdentifier: "t_rational_1_by_1",
													typeString: "int_const 1"
												},
												value: "1"
											},
											nodeType: "BinaryOperation",
											operator: "<<",
											rightExpression: {
												argumentTypes: null,
												id: 64,
												name: "claimedBitIndex",
												nodeType: "Identifier",
												overloadedDeclarations: [
												],
												referencedDeclaration: 50,
												src: "1029:15:0",
												typeDescriptions: {
													typeIdentifier: "t_uint256",
													typeString: "uint256"
												}
											},
											src: "1024:20:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										}
									],
									id: 66,
									isConstant: false,
									isInlineArray: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									nodeType: "TupleExpression",
									src: "1023:22:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "1008:37:0"
							},
							{
								expression: {
									argumentTypes: null,
									commonType: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									},
									id: 72,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftExpression: {
										argumentTypes: null,
										commonType: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										id: 70,
										isConstant: false,
										isLValue: false,
										isPure: false,
										lValueRequested: false,
										leftExpression: {
											argumentTypes: null,
											id: 68,
											name: "claimedWord",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 56,
											src: "1062:11:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										nodeType: "BinaryOperation",
										operator: "&",
										rightExpression: {
											argumentTypes: null,
											id: 69,
											name: "mask",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 62,
											src: "1076:4:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										src: "1062:18:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "BinaryOperation",
									operator: "==",
									rightExpression: {
										argumentTypes: null,
										id: 71,
										name: "mask",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 62,
										src: "1084:4:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									src: "1062:26:0",
									typeDescriptions: {
										typeIdentifier: "t_bool",
										typeString: "bool"
									}
								},
								functionReturnParameters: 42,
								id: 73,
								nodeType: "Return",
								src: "1055:33:0"
							}
						]
					},
					documentation: null,
					functionSelector: "9e34070f",
					id: 75,
					implemented: true,
					kind: "function",
					modifiers: [
					],
					name: "isClaimed",
					nodeType: "FunctionDefinition",
					overrides: null,
					parameters: {
						id: 39,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 38,
								mutability: "mutable",
								name: "index",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 75,
								src: "798:13:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 37,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "798:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "797:15:0"
					},
					returnParameters: {
						id: 42,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 41,
								mutability: "mutable",
								name: "",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 75,
								src: "834:4:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_bool",
									typeString: "bool"
								},
								typeName: {
									id: 40,
									name: "bool",
									nodeType: "ElementaryTypeName",
									src: "834:4:0",
									typeDescriptions: {
										typeIdentifier: "t_bool",
										typeString: "bool"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "833:6:0"
					},
					scope: 171,
					src: "779:316:0",
					stateMutability: "view",
					virtual: false,
					visibility: "public"
				},
				{
					body: {
						id: 105,
						nodeType: "Block",
						src: "1145:202:0",
						statements: [
							{
								assignments: [
									81
								],
								declarations: [
									{
										constant: false,
										id: 81,
										mutability: "mutable",
										name: "claimedWordIndex",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 105,
										src: "1155:24:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 80,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "1155:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 85,
								initialValue: {
									argumentTypes: null,
									commonType: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									},
									id: 84,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftExpression: {
										argumentTypes: null,
										id: 82,
										name: "index",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 77,
										src: "1182:5:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "BinaryOperation",
									operator: "/",
									rightExpression: {
										argumentTypes: null,
										hexValue: "323536",
										id: 83,
										isConstant: false,
										isLValue: false,
										isPure: true,
										kind: "number",
										lValueRequested: false,
										nodeType: "Literal",
										src: "1190:3:0",
										subdenomination: null,
										typeDescriptions: {
											typeIdentifier: "t_rational_256_by_1",
											typeString: "int_const 256"
										},
										value: "256"
									},
									src: "1182:11:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "1155:38:0"
							},
							{
								assignments: [
									87
								],
								declarations: [
									{
										constant: false,
										id: 87,
										mutability: "mutable",
										name: "claimedBitIndex",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 105,
										src: "1203:23:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										typeName: {
											id: 86,
											name: "uint256",
											nodeType: "ElementaryTypeName",
											src: "1203:7:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 91,
								initialValue: {
									argumentTypes: null,
									commonType: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									},
									id: 90,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftExpression: {
										argumentTypes: null,
										id: 88,
										name: "index",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 77,
										src: "1229:5:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "BinaryOperation",
									operator: "%",
									rightExpression: {
										argumentTypes: null,
										hexValue: "323536",
										id: 89,
										isConstant: false,
										isLValue: false,
										isPure: true,
										kind: "number",
										lValueRequested: false,
										nodeType: "Literal",
										src: "1237:3:0",
										subdenomination: null,
										typeDescriptions: {
											typeIdentifier: "t_rational_256_by_1",
											typeString: "int_const 256"
										},
										value: "256"
									},
									src: "1229:11:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "1203:37:0"
							},
							{
								expression: {
									argumentTypes: null,
									id: 103,
									isConstant: false,
									isLValue: false,
									isPure: false,
									lValueRequested: false,
									leftHandSide: {
										argumentTypes: null,
										baseExpression: {
											argumentTypes: null,
											id: 92,
											name: "claimedBitMap",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 12,
											src: "1250:13:0",
											typeDescriptions: {
												typeIdentifier: "t_mapping$_t_uint256_$_t_uint256_$",
												typeString: "mapping(uint256 => uint256)"
											}
										},
										id: 94,
										indexExpression: {
											argumentTypes: null,
											id: 93,
											name: "claimedWordIndex",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 81,
											src: "1264:16:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										isConstant: false,
										isLValue: true,
										isPure: false,
										lValueRequested: true,
										nodeType: "IndexAccess",
										src: "1250:31:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									nodeType: "Assignment",
									operator: "=",
									rightHandSide: {
										argumentTypes: null,
										commonType: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										},
										id: 102,
										isConstant: false,
										isLValue: false,
										isPure: false,
										lValueRequested: false,
										leftExpression: {
											argumentTypes: null,
											baseExpression: {
												argumentTypes: null,
												id: 95,
												name: "claimedBitMap",
												nodeType: "Identifier",
												overloadedDeclarations: [
												],
												referencedDeclaration: 12,
												src: "1284:13:0",
												typeDescriptions: {
													typeIdentifier: "t_mapping$_t_uint256_$_t_uint256_$",
													typeString: "mapping(uint256 => uint256)"
												}
											},
											id: 97,
											indexExpression: {
												argumentTypes: null,
												id: 96,
												name: "claimedWordIndex",
												nodeType: "Identifier",
												overloadedDeclarations: [
												],
												referencedDeclaration: 81,
												src: "1298:16:0",
												typeDescriptions: {
													typeIdentifier: "t_uint256",
													typeString: "uint256"
												}
											},
											isConstant: false,
											isLValue: true,
											isPure: false,
											lValueRequested: false,
											nodeType: "IndexAccess",
											src: "1284:31:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										nodeType: "BinaryOperation",
										operator: "|",
										rightExpression: {
											argumentTypes: null,
											components: [
												{
													argumentTypes: null,
													commonType: {
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													},
													id: 100,
													isConstant: false,
													isLValue: false,
													isPure: false,
													lValueRequested: false,
													leftExpression: {
														argumentTypes: null,
														hexValue: "31",
														id: 98,
														isConstant: false,
														isLValue: false,
														isPure: true,
														kind: "number",
														lValueRequested: false,
														nodeType: "Literal",
														src: "1319:1:0",
														subdenomination: null,
														typeDescriptions: {
															typeIdentifier: "t_rational_1_by_1",
															typeString: "int_const 1"
														},
														value: "1"
													},
													nodeType: "BinaryOperation",
													operator: "<<",
													rightExpression: {
														argumentTypes: null,
														id: 99,
														name: "claimedBitIndex",
														nodeType: "Identifier",
														overloadedDeclarations: [
														],
														referencedDeclaration: 87,
														src: "1324:15:0",
														typeDescriptions: {
															typeIdentifier: "t_uint256",
															typeString: "uint256"
														}
													},
													src: "1319:20:0",
													typeDescriptions: {
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												}
											],
											id: 101,
											isConstant: false,
											isInlineArray: false,
											isLValue: false,
											isPure: false,
											lValueRequested: false,
											nodeType: "TupleExpression",
											src: "1318:22:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										src: "1284:56:0",
										typeDescriptions: {
											typeIdentifier: "t_uint256",
											typeString: "uint256"
										}
									},
									src: "1250:90:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								id: 104,
								nodeType: "ExpressionStatement",
								src: "1250:90:0"
							}
						]
					},
					documentation: null,
					id: 106,
					implemented: true,
					kind: "function",
					modifiers: [
					],
					name: "_setClaimed",
					nodeType: "FunctionDefinition",
					overrides: null,
					parameters: {
						id: 78,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 77,
								mutability: "mutable",
								name: "index",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 106,
								src: "1122:13:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 76,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "1122:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "1121:15:0"
					},
					returnParameters: {
						id: 79,
						nodeType: "ParameterList",
						parameters: [
						],
						src: "1145:0:0"
					},
					scope: 171,
					src: "1101:246:0",
					stateMutability: "nonpayable",
					virtual: false,
					visibility: "private"
				},
				{
					body: {
						id: 169,
						nodeType: "Block",
						src: "1728:540:0",
						statements: [
							{
								expression: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											id: 123,
											isConstant: false,
											isLValue: false,
											isPure: false,
											lValueRequested: false,
											nodeType: "UnaryOperation",
											operator: "!",
											prefix: true,
											src: "1746:17:0",
											subExpression: {
												argumentTypes: null,
												"arguments": [
													{
														argumentTypes: null,
														id: 121,
														name: "index",
														nodeType: "Identifier",
														overloadedDeclarations: [
														],
														referencedDeclaration: 109,
														src: "1757:5:0",
														typeDescriptions: {
															typeIdentifier: "t_uint256",
															typeString: "uint256"
														}
													}
												],
												expression: {
													argumentTypes: [
														{
															typeIdentifier: "t_uint256",
															typeString: "uint256"
														}
													],
													id: 120,
													name: "isClaimed",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 75,
													src: "1747:9:0",
													typeDescriptions: {
														typeIdentifier: "t_function_internal_view$_t_uint256_$returns$_t_bool_$",
														typeString: "function (uint256) view returns (bool)"
													}
												},
												id: 122,
												isConstant: false,
												isLValue: false,
												isPure: false,
												kind: "functionCall",
												lValueRequested: false,
												names: [
												],
												nodeType: "FunctionCall",
												src: "1747:16:0",
												tryCall: false,
												typeDescriptions: {
													typeIdentifier: "t_bool",
													typeString: "bool"
												}
											},
											typeDescriptions: {
												typeIdentifier: "t_bool",
												typeString: "bool"
											}
										},
										{
											argumentTypes: null,
											hexValue: "417564697573436c61696d4469737472696275746f723a2044726f7020616c726561647920636c61696d65642e",
											id: 124,
											isConstant: false,
											isLValue: false,
											isPure: true,
											kind: "string",
											lValueRequested: false,
											nodeType: "Literal",
											src: "1765:47:0",
											subdenomination: null,
											typeDescriptions: {
												typeIdentifier: "t_stringliteral_ed031b8cd6efd0b5d6ac7d06318772f4c89447859d54d5d6480f786c223a95d7",
												typeString: "literal_string \"AudiusClaimDistributor: Drop already claimed.\""
											},
											value: "AudiusClaimDistributor: Drop already claimed."
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_bool",
												typeString: "bool"
											},
											{
												typeIdentifier: "t_stringliteral_ed031b8cd6efd0b5d6ac7d06318772f4c89447859d54d5d6480f786c223a95d7",
												typeString: "literal_string \"AudiusClaimDistributor: Drop already claimed.\""
											}
										],
										id: 119,
										name: "require",
										nodeType: "Identifier",
										overloadedDeclarations: [
											-18,
											-18
										],
										referencedDeclaration: -18,
										src: "1738:7:0",
										typeDescriptions: {
											typeIdentifier: "t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$",
											typeString: "function (bool,string memory) pure"
										}
									},
									id: 125,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "1738:75:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_tuple$__$",
										typeString: "tuple()"
									}
								},
								id: 126,
								nodeType: "ExpressionStatement",
								src: "1738:75:0"
							},
							{
								assignments: [
									128
								],
								declarations: [
									{
										constant: false,
										id: 128,
										mutability: "mutable",
										name: "node",
										nodeType: "VariableDeclaration",
										overrides: null,
										scope: 169,
										src: "1860:12:0",
										stateVariable: false,
										storageLocation: "default",
										typeDescriptions: {
											typeIdentifier: "t_bytes32",
											typeString: "bytes32"
										},
										typeName: {
											id: 127,
											name: "bytes32",
											nodeType: "ElementaryTypeName",
											src: "1860:7:0",
											typeDescriptions: {
												typeIdentifier: "t_bytes32",
												typeString: "bytes32"
											}
										},
										value: null,
										visibility: "internal"
									}
								],
								id: 137,
								initialValue: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											"arguments": [
												{
													argumentTypes: null,
													id: 132,
													name: "index",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 109,
													src: "1902:5:0",
													typeDescriptions: {
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												},
												{
													argumentTypes: null,
													id: 133,
													name: "account",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 111,
													src: "1909:7:0",
													typeDescriptions: {
														typeIdentifier: "t_address",
														typeString: "address"
													}
												},
												{
													argumentTypes: null,
													id: 134,
													name: "amount",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 113,
													src: "1918:6:0",
													typeDescriptions: {
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												}
											],
											expression: {
												argumentTypes: [
													{
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													},
													{
														typeIdentifier: "t_address",
														typeString: "address"
													},
													{
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												],
												expression: {
													argumentTypes: null,
													id: 130,
													name: "abi",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: -1,
													src: "1885:3:0",
													typeDescriptions: {
														typeIdentifier: "t_magic_abi",
														typeString: "abi"
													}
												},
												id: 131,
												isConstant: false,
												isLValue: false,
												isPure: true,
												lValueRequested: false,
												memberName: "encodePacked",
												nodeType: "MemberAccess",
												referencedDeclaration: null,
												src: "1885:16:0",
												typeDescriptions: {
													typeIdentifier: "t_function_abiencodepacked_pure$__$returns$_t_bytes_memory_ptr_$",
													typeString: "function () pure returns (bytes memory)"
												}
											},
											id: 135,
											isConstant: false,
											isLValue: false,
											isPure: false,
											kind: "functionCall",
											lValueRequested: false,
											names: [
											],
											nodeType: "FunctionCall",
											src: "1885:40:0",
											tryCall: false,
											typeDescriptions: {
												typeIdentifier: "t_bytes_memory_ptr",
												typeString: "bytes memory"
											}
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_bytes_memory_ptr",
												typeString: "bytes memory"
											}
										],
										id: 129,
										name: "keccak256",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: -8,
										src: "1875:9:0",
										typeDescriptions: {
											typeIdentifier: "t_function_keccak256_pure$_t_bytes_memory_ptr_$returns$_t_bytes32_$",
											typeString: "function (bytes memory) pure returns (bytes32)"
										}
									},
									id: 136,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "1875:51:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_bytes32",
										typeString: "bytes32"
									}
								},
								nodeType: "VariableDeclarationStatement",
								src: "1860:66:0"
							},
							{
								expression: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											"arguments": [
												{
													argumentTypes: null,
													id: 141,
													name: "merkleProof",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 116,
													src: "1963:11:0",
													typeDescriptions: {
														typeIdentifier: "t_array$_t_bytes32_$dyn_calldata_ptr",
														typeString: "bytes32[] calldata"
													}
												},
												{
													argumentTypes: null,
													id: 142,
													name: "merkleRoot",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 8,
													src: "1976:10:0",
													typeDescriptions: {
														typeIdentifier: "t_bytes32",
														typeString: "bytes32"
													}
												},
												{
													argumentTypes: null,
													id: 143,
													name: "node",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 128,
													src: "1988:4:0",
													typeDescriptions: {
														typeIdentifier: "t_bytes32",
														typeString: "bytes32"
													}
												}
											],
											expression: {
												argumentTypes: [
													{
														typeIdentifier: "t_array$_t_bytes32_$dyn_calldata_ptr",
														typeString: "bytes32[] calldata"
													},
													{
														typeIdentifier: "t_bytes32",
														typeString: "bytes32"
													},
													{
														typeIdentifier: "t_bytes32",
														typeString: "bytes32"
													}
												],
												expression: {
													argumentTypes: null,
													id: 139,
													name: "MerkleProof",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 275,
													src: "1944:11:0",
													typeDescriptions: {
														typeIdentifier: "t_type$_t_contract$_MerkleProof_$275_$",
														typeString: "type(library MerkleProof)"
													}
												},
												id: 140,
												isConstant: false,
												isLValue: false,
												isPure: false,
												lValueRequested: false,
												memberName: "verify",
												nodeType: "MemberAccess",
												referencedDeclaration: 274,
												src: "1944:18:0",
												typeDescriptions: {
													typeIdentifier: "t_function_internal_pure$_t_array$_t_bytes32_$dyn_memory_ptr_$_t_bytes32_$_t_bytes32_$returns$_t_bool_$",
													typeString: "function (bytes32[] memory,bytes32,bytes32) pure returns (bool)"
												}
											},
											id: 144,
											isConstant: false,
											isLValue: false,
											isPure: false,
											kind: "functionCall",
											lValueRequested: false,
											names: [
											],
											nodeType: "FunctionCall",
											src: "1944:49:0",
											tryCall: false,
											typeDescriptions: {
												typeIdentifier: "t_bool",
												typeString: "bool"
											}
										},
										{
											argumentTypes: null,
											hexValue: "417564697573436c61696d4469737472696275746f723a20496e76616c69642070726f6f662e",
											id: 145,
											isConstant: false,
											isLValue: false,
											isPure: true,
											kind: "string",
											lValueRequested: false,
											nodeType: "Literal",
											src: "1995:40:0",
											subdenomination: null,
											typeDescriptions: {
												typeIdentifier: "t_stringliteral_7e9ffaab8cc82fbdaf04569850ace67a05c1344deee101d0ef5ac2442c295c75",
												typeString: "literal_string \"AudiusClaimDistributor: Invalid proof.\""
											},
											value: "AudiusClaimDistributor: Invalid proof."
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_bool",
												typeString: "bool"
											},
											{
												typeIdentifier: "t_stringliteral_7e9ffaab8cc82fbdaf04569850ace67a05c1344deee101d0ef5ac2442c295c75",
												typeString: "literal_string \"AudiusClaimDistributor: Invalid proof.\""
											}
										],
										id: 138,
										name: "require",
										nodeType: "Identifier",
										overloadedDeclarations: [
											-18,
											-18
										],
										referencedDeclaration: -18,
										src: "1936:7:0",
										typeDescriptions: {
											typeIdentifier: "t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$",
											typeString: "function (bool,string memory) pure"
										}
									},
									id: 146,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "1936:100:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_tuple$__$",
										typeString: "tuple()"
									}
								},
								id: 147,
								nodeType: "ExpressionStatement",
								src: "1936:100:0"
							},
							{
								expression: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											id: 149,
											name: "index",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 109,
											src: "2106:5:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										],
										id: 148,
										name: "_setClaimed",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 106,
										src: "2094:11:0",
										typeDescriptions: {
											typeIdentifier: "t_function_internal_nonpayable$_t_uint256_$returns$__$",
											typeString: "function (uint256)"
										}
									},
									id: 150,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "2094:18:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_tuple$__$",
										typeString: "tuple()"
									}
								},
								id: 151,
								nodeType: "ExpressionStatement",
								src: "2094:18:0"
							},
							{
								expression: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											"arguments": [
												{
													argumentTypes: null,
													id: 157,
													name: "account",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 111,
													src: "2153:7:0",
													typeDescriptions: {
														typeIdentifier: "t_address",
														typeString: "address"
													}
												},
												{
													argumentTypes: null,
													id: 158,
													name: "amount",
													nodeType: "Identifier",
													overloadedDeclarations: [
													],
													referencedDeclaration: 113,
													src: "2162:6:0",
													typeDescriptions: {
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												}
											],
											expression: {
												argumentTypes: [
													{
														typeIdentifier: "t_address",
														typeString: "address"
													},
													{
														typeIdentifier: "t_uint256",
														typeString: "uint256"
													}
												],
												expression: {
													argumentTypes: null,
													"arguments": [
														{
															argumentTypes: null,
															id: 154,
															name: "token",
															nodeType: "Identifier",
															overloadedDeclarations: [
															],
															referencedDeclaration: 6,
															src: "2137:5:0",
															typeDescriptions: {
																typeIdentifier: "t_address",
																typeString: "address"
															}
														}
													],
													expression: {
														argumentTypes: [
															{
																typeIdentifier: "t_address",
																typeString: "address"
															}
														],
														id: 153,
														name: "IERC20",
														nodeType: "Identifier",
														overloadedDeclarations: [
														],
														referencedDeclaration: 353,
														src: "2130:6:0",
														typeDescriptions: {
															typeIdentifier: "t_type$_t_contract$_IERC20_$353_$",
															typeString: "type(contract IERC20)"
														}
													},
													id: 155,
													isConstant: false,
													isLValue: false,
													isPure: false,
													kind: "typeConversion",
													lValueRequested: false,
													names: [
													],
													nodeType: "FunctionCall",
													src: "2130:13:0",
													tryCall: false,
													typeDescriptions: {
														typeIdentifier: "t_contract$_IERC20_$353",
														typeString: "contract IERC20"
													}
												},
												id: 156,
												isConstant: false,
												isLValue: false,
												isPure: false,
												lValueRequested: false,
												memberName: "transfer",
												nodeType: "MemberAccess",
												referencedDeclaration: 302,
												src: "2130:22:0",
												typeDescriptions: {
													typeIdentifier: "t_function_external_nonpayable$_t_address_$_t_uint256_$returns$_t_bool_$",
													typeString: "function (address,uint256) external returns (bool)"
												}
											},
											id: 159,
											isConstant: false,
											isLValue: false,
											isPure: false,
											kind: "functionCall",
											lValueRequested: false,
											names: [
											],
											nodeType: "FunctionCall",
											src: "2130:39:0",
											tryCall: false,
											typeDescriptions: {
												typeIdentifier: "t_bool",
												typeString: "bool"
											}
										},
										{
											argumentTypes: null,
											hexValue: "417564697573436c61696d4469737472696275746f723a205472616e73666572206661696c65642e",
											id: 160,
											isConstant: false,
											isLValue: false,
											isPure: true,
											kind: "string",
											lValueRequested: false,
											nodeType: "Literal",
											src: "2171:42:0",
											subdenomination: null,
											typeDescriptions: {
												typeIdentifier: "t_stringliteral_a6ebd4450fbab8083d490c08fa5d0914a1bac0ff76772ca40012e669f531dfa3",
												typeString: "literal_string \"AudiusClaimDistributor: Transfer failed.\""
											},
											value: "AudiusClaimDistributor: Transfer failed."
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_bool",
												typeString: "bool"
											},
											{
												typeIdentifier: "t_stringliteral_a6ebd4450fbab8083d490c08fa5d0914a1bac0ff76772ca40012e669f531dfa3",
												typeString: "literal_string \"AudiusClaimDistributor: Transfer failed.\""
											}
										],
										id: 152,
										name: "require",
										nodeType: "Identifier",
										overloadedDeclarations: [
											-18,
											-18
										],
										referencedDeclaration: -18,
										src: "2122:7:0",
										typeDescriptions: {
											typeIdentifier: "t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$",
											typeString: "function (bool,string memory) pure"
										}
									},
									id: 161,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "2122:92:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_tuple$__$",
										typeString: "tuple()"
									}
								},
								id: 162,
								nodeType: "ExpressionStatement",
								src: "2122:92:0"
							},
							{
								eventCall: {
									argumentTypes: null,
									"arguments": [
										{
											argumentTypes: null,
											id: 164,
											name: "index",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 109,
											src: "2238:5:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										},
										{
											argumentTypes: null,
											id: 165,
											name: "account",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 111,
											src: "2245:7:0",
											typeDescriptions: {
												typeIdentifier: "t_address",
												typeString: "address"
											}
										},
										{
											argumentTypes: null,
											id: 166,
											name: "amount",
											nodeType: "Identifier",
											overloadedDeclarations: [
											],
											referencedDeclaration: 113,
											src: "2254:6:0",
											typeDescriptions: {
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										}
									],
									expression: {
										argumentTypes: [
											{
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											},
											{
												typeIdentifier: "t_address",
												typeString: "address"
											},
											{
												typeIdentifier: "t_uint256",
												typeString: "uint256"
											}
										],
										id: 163,
										name: "Claimed",
										nodeType: "Identifier",
										overloadedDeclarations: [
										],
										referencedDeclaration: 20,
										src: "2230:7:0",
										typeDescriptions: {
											typeIdentifier: "t_function_event_nonpayable$_t_uint256_$_t_address_$_t_uint256_$returns$__$",
											typeString: "function (uint256,address,uint256)"
										}
									},
									id: 167,
									isConstant: false,
									isLValue: false,
									isPure: false,
									kind: "functionCall",
									lValueRequested: false,
									names: [
									],
									nodeType: "FunctionCall",
									src: "2230:31:0",
									tryCall: false,
									typeDescriptions: {
										typeIdentifier: "t_tuple$__$",
										typeString: "tuple()"
									}
								},
								id: 168,
								nodeType: "EmitStatement",
								src: "2225:36:0"
							}
						]
					},
					documentation: {
						id: 107,
						nodeType: "StructuredDocumentation",
						src: "1353:266:0",
						text: " No caller permissioning needed since token is transfered to account argument,\n    and there is no incentive to call function for another account.\n Can only submit claim for full claimable amount, otherwise proof verification will fail."
					},
					functionSelector: "2e7ba6ef",
					id: 170,
					implemented: true,
					kind: "function",
					modifiers: [
					],
					name: "claim",
					nodeType: "FunctionDefinition",
					overrides: null,
					parameters: {
						id: 117,
						nodeType: "ParameterList",
						parameters: [
							{
								constant: false,
								id: 109,
								mutability: "mutable",
								name: "index",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 170,
								src: "1639:13:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 108,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "1639:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 111,
								mutability: "mutable",
								name: "account",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 170,
								src: "1654:15:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_address",
									typeString: "address"
								},
								typeName: {
									id: 110,
									name: "address",
									nodeType: "ElementaryTypeName",
									src: "1654:7:0",
									stateMutability: "nonpayable",
									typeDescriptions: {
										typeIdentifier: "t_address",
										typeString: "address"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 113,
								mutability: "mutable",
								name: "amount",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 170,
								src: "1671:14:0",
								stateVariable: false,
								storageLocation: "default",
								typeDescriptions: {
									typeIdentifier: "t_uint256",
									typeString: "uint256"
								},
								typeName: {
									id: 112,
									name: "uint256",
									nodeType: "ElementaryTypeName",
									src: "1671:7:0",
									typeDescriptions: {
										typeIdentifier: "t_uint256",
										typeString: "uint256"
									}
								},
								value: null,
								visibility: "internal"
							},
							{
								constant: false,
								id: 116,
								mutability: "mutable",
								name: "merkleProof",
								nodeType: "VariableDeclaration",
								overrides: null,
								scope: 170,
								src: "1687:30:0",
								stateVariable: false,
								storageLocation: "calldata",
								typeDescriptions: {
									typeIdentifier: "t_array$_t_bytes32_$dyn_calldata_ptr",
									typeString: "bytes32[]"
								},
								typeName: {
									baseType: {
										id: 114,
										name: "bytes32",
										nodeType: "ElementaryTypeName",
										src: "1687:7:0",
										typeDescriptions: {
											typeIdentifier: "t_bytes32",
											typeString: "bytes32"
										}
									},
									id: 115,
									length: null,
									nodeType: "ArrayTypeName",
									src: "1687:9:0",
									typeDescriptions: {
										typeIdentifier: "t_array$_t_bytes32_$dyn_storage_ptr",
										typeString: "bytes32[]"
									}
								},
								value: null,
								visibility: "internal"
							}
						],
						src: "1638:80:0"
					},
					returnParameters: {
						id: 118,
						nodeType: "ParameterList",
						parameters: [
						],
						src: "1728:0:0"
					},
					scope: 171,
					src: "1624:644:0",
					stateMutability: "nonpayable",
					virtual: false,
					visibility: "external"
				}
			],
			scope: 172,
			src: "322:1948:0"
		}
	],
	src: "39:2232:0"
};
var compiler = {
	name: "solc",
	version: "0.6.10+commit.00c0fcaf.Emscripten.clang"
};
var networks = {
	"1602784384763": {
		events: {
			"0x4ec90e965519d92681267467f775ada5bd214aa92c0dc93d90a5e880ce9ed026": {
				anonymous: false,
				inputs: [
					{
						indexed: false,
						internalType: "uint256",
						name: "index",
						type: "uint256"
					},
					{
						indexed: false,
						internalType: "address",
						name: "account",
						type: "address"
					},
					{
						indexed: false,
						internalType: "uint256",
						name: "amount",
						type: "uint256"
					}
				],
				name: "Claimed",
				type: "event"
			}
		},
		links: {
		},
		address: "0x953789fa8f967319F73B52b2492f2fd185dd7719",
		transactionHash: "0x5a1bf8010038ccb9a83a978d79b8a22f7bae9063b446aa0c830378ad4fdfdc49"
	}
};
var schemaVersion = "3.1.0";
var updatedAt = "2020-10-15T18:11:25.487Z";
var networkType = "ethereum";
var devdoc = {
	methods: {
	}
};
var userdoc = {
	methods: {
		"claim(uint256,address,uint256,bytes32[])": {
			notice: "No caller permissioning needed since token is transfered to account argument,    and there is no incentive to call function for another account. Can only submit claim for full claimable amount, otherwise proof verification will fail."
		}
	},
	notice: "Replicated from (No changes made): https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol"
};
var require$$1$K = {
	contractName: contractName$J,
	abi: abi$J,
	metadata: metadata,
	bytecode: bytecode,
	deployedBytecode: deployedBytecode,
	immutableReferences: immutableReferences,
	sourceMap: sourceMap,
	deployedSourceMap: deployedSourceMap,
	source: source,
	sourcePath: sourcePath,
	ast: ast,
	legacyAST: legacyAST,
	compiler: compiler,
	networks: networks,
	schemaVersion: schemaVersion,
	updatedAt: updatedAt,
	networkType: networkType,
	devdoc: devdoc,
	userdoc: userdoc
};

const commonjsRegister$J = commonjsRegister$1t;
commonjsRegister$J("/$$rollup_base$$/eth-contracts/ABIs/AudiusClaimDistributor.json", function (module, exports) {
  module.exports = require$$1$K;
});

var contractName$I = "AudiusToken";
var abi$I = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "MinterAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "MinterRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "Paused",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "PauserAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "PauserRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "Unpaused",
		type: "event"
	},
	{
		constant: true,
		inputs: [
		],
		name: "DOMAIN_SEPARATOR",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "PERMIT_TYPEHASH",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "addMinter",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "addPauser",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "burn",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "burnFrom",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "decimals",
		outputs: [
			{
				internalType: "uint8",
				name: "",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "subtractedValue",
				type: "uint256"
			}
		],
		name: "decreaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "addedValue",
				type: "uint256"
			}
		],
		name: "increaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "isMinter",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "isPauser",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "mint",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "name",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "nonces",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "pause",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "paused",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceMinter",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renouncePauser",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "unpause",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "string",
				name: "name",
				type: "string"
			},
			{
				internalType: "string",
				name: "symbol",
				type: "string"
			},
			{
				internalType: "uint8",
				name: "decimals",
				type: "uint8"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "governance",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "deadline",
				type: "uint256"
			},
			{
				internalType: "uint8",
				name: "v",
				type: "uint8"
			},
			{
				internalType: "bytes32",
				name: "r",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "s",
				type: "bytes32"
			}
		],
		name: "permit",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$J = {
	contractName: contractName$I,
	abi: abi$I
};

const commonjsRegister$I = commonjsRegister$1t;
commonjsRegister$I("/$$rollup_base$$/eth-contracts/ABIs/AudiusToken.json", function (module, exports) {
  module.exports = require$$1$J;
});

var contractName$H = "BaseUpgradeabilityProxy";
var abi$H = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "implementation",
				type: "address"
			}
		],
		name: "Upgraded",
		type: "event"
	},
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	}
];
var require$$1$I = {
	contractName: contractName$H,
	abi: abi$H
};

const commonjsRegister$H = commonjsRegister$1t;
commonjsRegister$H("/$$rollup_base$$/eth-contracts/ABIs/BaseUpgradeabilityProxy.json", function (module, exports) {
  module.exports = require$$1$I;
});

var contractName$G = "Checkpointing";
var abi$G = [
];
var require$$1$H = {
	contractName: contractName$G,
	abi: abi$G
};

const commonjsRegister$G = commonjsRegister$1t;
commonjsRegister$G("/$$rollup_base$$/eth-contracts/ABIs/Checkpointing.json", function (module, exports) {
  module.exports = require$$1$H;
});

var contractName$F = "ClaimsManager";
var abi$F = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_claimer",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_rewards",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_oldTotal",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newTotal",
				type: "uint256"
			}
		],
		name: "ClaimProcessed",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newCommunityPoolAddress",
				type: "address"
			}
		],
		name: "CommunityPoolAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_transferAddress",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "CommunityRewardsTransferred",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newDelegateManagerAddress",
				type: "address"
			}
		],
		name: "DelegateManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "FundingAmountUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_blockDifference",
				type: "uint256"
			}
		],
		name: "FundingRoundBlockDiffUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGovernanceAddress",
				type: "address"
			}
		],
		name: "GovernanceAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "RecurringCommunityFundingAmountUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_roundNumber",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_fundAmount",
				type: "uint256"
			}
		],
		name: "RoundInitiated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newServiceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "ServiceProviderFactoryAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newStakingAddress",
				type: "address"
			}
		],
		name: "StakingAddressUpdated",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getFundingRoundBlockDiff",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getLastFundedBlock",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getFundsPerRound",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getTotalClaimedInRound",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDelegateManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getCommunityPoolAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRecurringCommunityFundingAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_stakingAddress",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_delegateManagerAddress",
				type: "address"
			}
		],
		name: "setDelegateManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initiateRound",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_claimer",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_totalLockedForSP",
				type: "uint256"
			}
		],
		name: "processClaim",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_newAmount",
				type: "uint256"
			}
		],
		name: "updateFundingAmount",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "claimPending",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_newFundingRoundBlockDiff",
				type: "uint256"
			}
		],
		name: "updateFundingRoundBlockDiff",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_newRecurringCommunityFundingAmount",
				type: "uint256"
			}
		],
		name: "updateRecurringCommunityFundingAmount",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_newCommunityPoolAddress",
				type: "address"
			}
		],
		name: "updateCommunityPoolAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$G = {
	contractName: contractName$F,
	abi: abi$F
};

const commonjsRegister$F = commonjsRegister$1t;
commonjsRegister$F("/$$rollup_base$$/eth-contracts/ABIs/ClaimsManager.json", function (module, exports) {
  module.exports = require$$1$G;
});

var contractName$E = "Context";
var abi$E = [
	{
		inputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	}
];
var require$$1$F = {
	contractName: contractName$E,
	abi: abi$E
};

const commonjsRegister$E = commonjsRegister$1t;
commonjsRegister$E("/$$rollup_base$$/eth-contracts/ABIs/Context.json", function (module, exports) {
  module.exports = require$$1$F;
});

var contractName$D = "DelegateManager";
var abi$D = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_claimer",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_rewards",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newTotal",
				type: "uint256"
			}
		],
		name: "Claim",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newClaimsManagerAddress",
				type: "address"
			}
		],
		name: "ClaimsManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGovernanceAddress",
				type: "address"
			}
		],
		name: "GovernanceAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_increaseAmount",
				type: "uint256"
			}
		],
		name: "IncreaseDelegatedStake",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_maxDelegators",
				type: "uint256"
			}
		],
		name: "MaxDelegatorsUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_minDelegationAmount",
				type: "uint256"
			}
		],
		name: "MinDelegationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_removeDelegatorEvalDuration",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorEvalDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_removeDelegatorLockupDuration",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorLockupDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "RemoveDelegatorRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_unstakedAmount",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorRequested",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newServiceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "ServiceProviderFactoryAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_target",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newTotal",
				type: "uint256"
			}
		],
		name: "Slash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newStakingAddress",
				type: "address"
			}
		],
		name: "StakingAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_undelegateLockupDuration",
				type: "uint256"
			}
		],
		name: "UndelegateLockupDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequested",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_undelegateLockupDuration",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_targetSP",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "delegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_target",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "requestUndelegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "cancelUndelegateStakeRequest",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "undelegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "claimRewards",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_slashAddress",
				type: "address"
			}
		],
		name: "slash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "requestRemoveDelegator",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "cancelRemoveDelegatorRequest",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "removeDelegator",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateUndelegateLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_maxDelegators",
				type: "uint256"
			}
		],
		name: "updateMaxDelegators",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_minDelegationAmount",
				type: "uint256"
			}
		],
		name: "updateMinDelegationAmount",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateRemoveDelegatorLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateRemoveDelegatorEvalDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_stakingAddress",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_spFactory",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_claimsManagerAddress",
				type: "address"
			}
		],
		name: "setClaimsManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getDelegatorsList",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getTotalDelegatorStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getTotalDelegatedToServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getTotalLockedDelegationForServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getDelegatorStakeForServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getPendingUndelegateRequest",
		outputs: [
			{
				internalType: "address",
				name: "target",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "lockupExpiryBlock",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getPendingRemoveDelegatorRequest",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getUndelegateLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMaxDelegators",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMinDelegationAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRemoveDelegatorLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRemoveDelegatorEvalDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getClaimsManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$E = {
	contractName: contractName$D,
	abi: abi$D
};

const commonjsRegister$D = commonjsRegister$1t;
commonjsRegister$D("/$$rollup_base$$/eth-contracts/ABIs/DelegateManager.json", function (module, exports) {
  module.exports = require$$1$E;
});

var contractName$C = "DelegateManagerV2";
var abi$C = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_claimer",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_rewards",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newTotal",
				type: "uint256"
			}
		],
		name: "Claim",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newClaimsManagerAddress",
				type: "address"
			}
		],
		name: "ClaimsManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGovernanceAddress",
				type: "address"
			}
		],
		name: "GovernanceAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_increaseAmount",
				type: "uint256"
			}
		],
		name: "IncreaseDelegatedStake",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_maxDelegators",
				type: "uint256"
			}
		],
		name: "MaxDelegatorsUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_minDelegationAmount",
				type: "uint256"
			}
		],
		name: "MinDelegationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_removeDelegatorEvalDuration",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorEvalDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_removeDelegatorLockupDuration",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorLockupDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "RemoveDelegatorRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_unstakedAmount",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorRequested",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_spMinDelegationAmount",
				type: "uint256"
			}
		],
		name: "SPMinDelegationAmountUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newServiceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "ServiceProviderFactoryAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_target",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newTotal",
				type: "uint256"
			}
		],
		name: "Slash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newStakingAddress",
				type: "address"
			}
		],
		name: "StakingAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_undelegateLockupDuration",
				type: "uint256"
			}
		],
		name: "UndelegateLockupDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequested",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_undelegateLockupDuration",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_targetSP",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "delegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_target",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "requestUndelegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "cancelUndelegateStakeRequest",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "undelegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "claimRewards",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_slashAddress",
				type: "address"
			}
		],
		name: "slash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "requestRemoveDelegator",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "cancelRemoveDelegatorRequest",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "removeDelegator",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_spMinDelegationAmount",
				type: "uint256"
			}
		],
		name: "updateSPMinDelegationAmount",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateUndelegateLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_maxDelegators",
				type: "uint256"
			}
		],
		name: "updateMaxDelegators",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_minDelegationAmount",
				type: "uint256"
			}
		],
		name: "updateMinDelegationAmount",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateRemoveDelegatorLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateRemoveDelegatorEvalDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_stakingAddress",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_spFactory",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_claimsManagerAddress",
				type: "address"
			}
		],
		name: "setClaimsManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getDelegatorsList",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getTotalDelegatorStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getTotalDelegatedToServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getTotalLockedDelegationForServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getDelegatorStakeForServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getPendingUndelegateRequest",
		outputs: [
			{
				internalType: "address",
				name: "target",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "lockupExpiryBlock",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getPendingRemoveDelegatorRequest",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getSPMinDelegationAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getUndelegateLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMaxDelegators",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMinDelegationAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRemoveDelegatorLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRemoveDelegatorEvalDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getClaimsManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$D = {
	contractName: contractName$C,
	abi: abi$C
};

const commonjsRegister$C = commonjsRegister$1t;
commonjsRegister$C("/$$rollup_base$$/eth-contracts/ABIs/DelegateManagerV2.json", function (module, exports) {
  module.exports = require$$1$D;
});

var contractName$B = "DelegateManagerV2Bad";
var abi$B = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_claimer",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_rewards",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newTotal",
				type: "uint256"
			}
		],
		name: "Claim",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newClaimsManagerAddress",
				type: "address"
			}
		],
		name: "ClaimsManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGovernanceAddress",
				type: "address"
			}
		],
		name: "GovernanceAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_increaseAmount",
				type: "uint256"
			}
		],
		name: "IncreaseDelegatedStake",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_maxDelegators",
				type: "uint256"
			}
		],
		name: "MaxDelegatorsUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_minDelegationAmount",
				type: "uint256"
			}
		],
		name: "MinDelegationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_removeDelegatorEvalDuration",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorEvalDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_removeDelegatorLockupDuration",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorLockupDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "RemoveDelegatorRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_unstakedAmount",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "RemoveDelegatorRequested",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_spMinDelegationAmount",
				type: "uint256"
			}
		],
		name: "SPMinDelegationAmountUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newServiceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "ServiceProviderFactoryAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_target",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newTotal",
				type: "uint256"
			}
		],
		name: "Slash",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newStakingAddress",
				type: "address"
			}
		],
		name: "StakingAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_undelegateLockupDuration",
				type: "uint256"
			}
		],
		name: "UndelegateLockupDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "UndelegateStakeRequested",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_undelegateLockupDuration",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_targetSP",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "delegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_target",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "requestUndelegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "cancelUndelegateStakeRequest",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "undelegateStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "claimRewards",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_slashAddress",
				type: "address"
			}
		],
		name: "slash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "requestRemoveDelegator",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "cancelRemoveDelegatorRequest",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "removeDelegator",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_spMinDelegationAmount",
				type: "uint256"
			}
		],
		name: "updateSPMinDelegationAmount",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateUndelegateLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_maxDelegators",
				type: "uint256"
			}
		],
		name: "updateMaxDelegators",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_minDelegationAmount",
				type: "uint256"
			}
		],
		name: "updateMinDelegationAmount",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateRemoveDelegatorLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateRemoveDelegatorEvalDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_stakingAddress",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_spFactory",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_claimsManagerAddress",
				type: "address"
			}
		],
		name: "setClaimsManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getDelegatorsList",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getTotalDelegatorStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getTotalDelegatedToServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_sp",
				type: "address"
			}
		],
		name: "getTotalLockedDelegationForServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			},
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getDelegatorStakeForServiceProvider",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getPendingUndelegateRequest",
		outputs: [
			{
				internalType: "address",
				name: "target",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "lockupExpiryBlock",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegator",
				type: "address"
			}
		],
		name: "getPendingRemoveDelegatorRequest",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getSPMinDelegationAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getUndelegateLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMaxDelegators",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMinDelegationAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRemoveDelegatorLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRemoveDelegatorEvalDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getClaimsManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$C = {
	contractName: contractName$B,
	abi: abi$B
};

const commonjsRegister$B = commonjsRegister$1t;
commonjsRegister$B("/$$rollup_base$$/eth-contracts/ABIs/DelegateManagerV2Bad.json", function (module, exports) {
  module.exports = require$$1$C;
});

var contractName$A = "ERC20";
var abi$A = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "recipient",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			},
			{
				internalType: "address",
				name: "recipient",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "addedValue",
				type: "uint256"
			}
		],
		name: "increaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "subtractedValue",
				type: "uint256"
			}
		],
		name: "decreaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$B = {
	contractName: contractName$A,
	abi: abi$A
};

const commonjsRegister$A = commonjsRegister$1t;
commonjsRegister$A("/$$rollup_base$$/eth-contracts/ABIs/ERC20.json", function (module, exports) {
  module.exports = require$$1$B;
});

var contractName$z = "ERC20Burnable";
var abi$z = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "subtractedValue",
				type: "uint256"
			}
		],
		name: "decreaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "addedValue",
				type: "uint256"
			}
		],
		name: "increaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "recipient",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			},
			{
				internalType: "address",
				name: "recipient",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "burn",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "burnFrom",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$A = {
	contractName: contractName$z,
	abi: abi$z
};

const commonjsRegister$z = commonjsRegister$1t;
commonjsRegister$z("/$$rollup_base$$/eth-contracts/ABIs/ERC20Burnable.json", function (module, exports) {
  module.exports = require$$1$A;
});

var contractName$y = "ERC20Detailed";
var abi$y = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "recipient",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			},
			{
				internalType: "address",
				name: "recipient",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "string",
				name: "name",
				type: "string"
			},
			{
				internalType: "string",
				name: "symbol",
				type: "string"
			},
			{
				internalType: "uint8",
				name: "decimals",
				type: "uint8"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "name",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "decimals",
		outputs: [
			{
				internalType: "uint8",
				name: "",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$z = {
	contractName: contractName$y,
	abi: abi$y
};

const commonjsRegister$y = commonjsRegister$1t;
commonjsRegister$y("/$$rollup_base$$/eth-contracts/ABIs/ERC20Detailed.json", function (module, exports) {
  module.exports = require$$1$z;
});

var contractName$x = "ERC20Mintable";
var abi$x = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "MinterAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "MinterRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "addMinter",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "subtractedValue",
				type: "uint256"
			}
		],
		name: "decreaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "addedValue",
				type: "uint256"
			}
		],
		name: "increaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "isMinter",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceMinter",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "recipient",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			},
			{
				internalType: "address",
				name: "recipient",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "mint",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$y = {
	contractName: contractName$x,
	abi: abi$x
};

const commonjsRegister$x = commonjsRegister$1t;
commonjsRegister$x("/$$rollup_base$$/eth-contracts/ABIs/ERC20Mintable.json", function (module, exports) {
  module.exports = require$$1$y;
});

var contractName$w = "ERC20Pausable";
var abi$w = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "Paused",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "PauserAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "PauserRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "Unpaused",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "addPauser",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "isPauser",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "pause",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "paused",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renouncePauser",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "unpause",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "addedValue",
				type: "uint256"
			}
		],
		name: "increaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "subtractedValue",
				type: "uint256"
			}
		],
		name: "decreaseAllowance",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$x = {
	contractName: contractName$w,
	abi: abi$w
};

const commonjsRegister$w = commonjsRegister$1t;
commonjsRegister$w("/$$rollup_base$$/eth-contracts/ABIs/ERC20Pausable.json", function (module, exports) {
  module.exports = require$$1$x;
});

var contractName$v = "EthRewardsManager";
var abi$v = [
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_wormholeAddress",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "_recipient",
				type: "bytes32"
			},
			{
				internalType: "address[]",
				name: "_antiAbuseOracleAddresses",
				type: "address[]"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_recipient",
				type: "bytes32"
			}
		],
		name: "setRecipientAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address[]",
				name: "_antiAbuseOracleAddresses",
				type: "address[]"
			}
		],
		name: "setAntiAbuseOracleAddresses",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "arbiterFee",
				type: "uint256"
			},
			{
				internalType: "uint32",
				name: "_nonce",
				type: "uint32"
			}
		],
		name: "transferToSolana",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "token",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRecipientAddress",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getAntiAbuseOracleAddresses",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$w = {
	contractName: contractName$v,
	abi: abi$v
};

const commonjsRegister$v = commonjsRegister$1t;
commonjsRegister$v("/$$rollup_base$$/eth-contracts/ABIs/EthRewardsManager.json", function (module, exports) {
  module.exports = require$$1$w;
});

var contractName$u = "Governance";
var abi$u = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newExecutionDelay",
				type: "uint256"
			}
		],
		name: "ExecutionDelayUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_targetContractAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				indexed: true,
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "_returnData",
				type: "bytes"
			}
		],
		name: "GuardianTransactionExecuted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGuardianAddress",
				type: "address"
			}
		],
		name: "GuardianshipTransferred",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newMaxInProgressProposals",
				type: "uint256"
			}
		],
		name: "MaxInProgressProposalsUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "enum Governance.Outcome",
				name: "_outcome",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voteMagnitudeYes",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voteMagnitudeNo",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_numVotes",
				type: "uint256"
			}
		],
		name: "ProposalOutcomeEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_proposer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_name",
				type: "string"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_description",
				type: "string"
			}
		],
		name: "ProposalSubmitted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bool",
				name: "_success",
				type: "bool"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "_returnData",
				type: "bytes"
			}
		],
		name: "ProposalTransactionExecuted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "ProposalVetoed",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_voter",
				type: "address"
			},
			{
				indexed: true,
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voterStake",
				type: "uint256"
			}
		],
		name: "ProposalVoteSubmitted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_voter",
				type: "address"
			},
			{
				indexed: true,
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voterStake",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "enum Governance.Vote",
				name: "_previousVote",
				type: "uint8"
			}
		],
		name: "ProposalVoteUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newRegistryAddress",
				type: "address"
			}
		],
		name: "RegistryAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newVotingPeriod",
				type: "uint256"
			}
		],
		name: "VotingPeriodUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newVotingQuorumPercent",
				type: "uint256"
			}
		],
		name: "VotingQuorumPercentUpdated",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_registryAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_votingPeriod",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_executionDelay",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_votingQuorumPercent",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "_maxInProgressProposals",
				type: "uint16"
			},
			{
				internalType: "address",
				name: "_guardianAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			},
			{
				internalType: "string",
				name: "_name",
				type: "string"
			},
			{
				internalType: "string",
				name: "_description",
				type: "string"
			}
		],
		name: "submitProposal",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			}
		],
		name: "submitVote",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			}
		],
		name: "updateVote",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "evaluateProposalOutcome",
		outputs: [
			{
				internalType: "enum Governance.Outcome",
				name: "",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "vetoProposal",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_stakingAddress",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_delegateManagerAddress",
				type: "address"
			}
		],
		name: "setDelegateManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_votingPeriod",
				type: "uint256"
			}
		],
		name: "setVotingPeriod",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_votingQuorumPercent",
				type: "uint256"
			}
		],
		name: "setVotingQuorumPercent",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint16",
				name: "_newMaxInProgressProposals",
				type: "uint16"
			}
		],
		name: "setMaxInProgressProposals",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_newExecutionDelay",
				type: "uint256"
			}
		],
		name: "setExecutionDelay",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			}
		],
		name: "guardianExecuteTransaction",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_newGuardianAddress",
				type: "address"
			}
		],
		name: "transferGuardianship",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "getProposalById",
		outputs: [
			{
				internalType: "uint256",
				name: "proposalId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "proposer",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "submissionBlockNumber",
				type: "uint256"
			},
			{
				internalType: "bytes32",
				name: "targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "targetContractAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "callData",
				type: "bytes"
			},
			{
				internalType: "enum Governance.Outcome",
				name: "outcome",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "voteMagnitudeYes",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "voteMagnitudeNo",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "numVotes",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "getProposalTargetContractHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_voter",
				type: "address"
			}
		],
		name: "getVoteInfoByProposalAndVoter",
		outputs: [
			{
				internalType: "enum Governance.Vote",
				name: "vote",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "voteMagnitude",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGuardianAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDelegateManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getVotingPeriod",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getVotingQuorumPercent",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRegistryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isGovernanceAddress",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "pure",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMaxInProgressProposals",
		outputs: [
			{
				internalType: "uint16",
				name: "",
				type: "uint16"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getExecutionDelay",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getInProgressProposals",
		outputs: [
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "inProgressProposalsAreUpToDate",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$v = {
	contractName: contractName$u,
	abi: abi$u
};

const commonjsRegister$u = commonjsRegister$1t;
commonjsRegister$u("/$$rollup_base$$/eth-contracts/ABIs/Governance.json", function (module, exports) {
  module.exports = require$$1$v;
});

var contractName$t = "GovernanceUpgraded";
var abi$t = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newExecutionDelay",
				type: "uint256"
			}
		],
		name: "ExecutionDelayUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_targetContractAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				indexed: true,
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "_returnData",
				type: "bytes"
			}
		],
		name: "GuardianTransactionExecuted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGuardianAddress",
				type: "address"
			}
		],
		name: "GuardianshipTransferred",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newMaxInProgressProposals",
				type: "uint256"
			}
		],
		name: "MaxInProgressProposalsUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "enum Governance.Outcome",
				name: "_outcome",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voteMagnitudeYes",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voteMagnitudeNo",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_numVotes",
				type: "uint256"
			}
		],
		name: "ProposalOutcomeEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_proposer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_name",
				type: "string"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_description",
				type: "string"
			}
		],
		name: "ProposalSubmitted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bool",
				name: "_success",
				type: "bool"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "_returnData",
				type: "bytes"
			}
		],
		name: "ProposalTransactionExecuted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "ProposalVetoed",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_voter",
				type: "address"
			},
			{
				indexed: true,
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voterStake",
				type: "uint256"
			}
		],
		name: "ProposalVoteSubmitted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_voter",
				type: "address"
			},
			{
				indexed: true,
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voterStake",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "enum Governance.Vote",
				name: "_previousVote",
				type: "uint8"
			}
		],
		name: "ProposalVoteUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newRegistryAddress",
				type: "address"
			}
		],
		name: "RegistryAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newVotingPeriod",
				type: "uint256"
			}
		],
		name: "VotingPeriodUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newVotingQuorumPercent",
				type: "uint256"
			}
		],
		name: "VotingQuorumPercentUpdated",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "evaluateProposalOutcome",
		outputs: [
			{
				internalType: "enum Governance.Outcome",
				name: "",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDelegateManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getExecutionDelay",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGuardianAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getInProgressProposals",
		outputs: [
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMaxInProgressProposals",
		outputs: [
			{
				internalType: "uint16",
				name: "",
				type: "uint16"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "getProposalById",
		outputs: [
			{
				internalType: "uint256",
				name: "proposalId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "proposer",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "submissionBlockNumber",
				type: "uint256"
			},
			{
				internalType: "bytes32",
				name: "targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "targetContractAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "callData",
				type: "bytes"
			},
			{
				internalType: "enum Governance.Outcome",
				name: "outcome",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "voteMagnitudeYes",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "voteMagnitudeNo",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "numVotes",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "getProposalTargetContractHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRegistryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_voter",
				type: "address"
			}
		],
		name: "getVoteInfoByProposalAndVoter",
		outputs: [
			{
				internalType: "enum Governance.Vote",
				name: "vote",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "voteMagnitude",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getVotingPeriod",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getVotingQuorumPercent",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			}
		],
		name: "guardianExecuteTransaction",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "inProgressProposalsAreUpToDate",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_registryAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_votingPeriod",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_executionDelay",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_votingQuorumPercent",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "_maxInProgressProposals",
				type: "uint16"
			},
			{
				internalType: "address",
				name: "_guardianAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isGovernanceAddress",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "pure",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_delegateManagerAddress",
				type: "address"
			}
		],
		name: "setDelegateManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_newExecutionDelay",
				type: "uint256"
			}
		],
		name: "setExecutionDelay",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint16",
				name: "_newMaxInProgressProposals",
				type: "uint16"
			}
		],
		name: "setMaxInProgressProposals",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_stakingAddress",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_votingPeriod",
				type: "uint256"
			}
		],
		name: "setVotingPeriod",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_votingQuorumPercent",
				type: "uint256"
			}
		],
		name: "setVotingQuorumPercent",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			},
			{
				internalType: "string",
				name: "_name",
				type: "string"
			},
			{
				internalType: "string",
				name: "_description",
				type: "string"
			}
		],
		name: "submitProposal",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			}
		],
		name: "submitVote",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_newGuardianAddress",
				type: "address"
			}
		],
		name: "transferGuardianship",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "enum Governance.Vote",
				name: "_vote",
				type: "uint8"
			}
		],
		name: "updateVote",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "vetoProposal",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "newFunction",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$u = {
	contractName: contractName$t,
	abi: abi$t
};

const commonjsRegister$t = commonjsRegister$1t;
commonjsRegister$t("/$$rollup_base$$/eth-contracts/ABIs/GovernanceUpgraded.json", function (module, exports) {
  module.exports = require$$1$u;
});

var contractName$s = "GovernanceV2";
var abi$s = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newExecutionDelay",
				type: "uint256"
			}
		],
		name: "ExecutionDelayUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_targetContractAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				indexed: true,
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "_returnData",
				type: "bytes"
			}
		],
		name: "GuardianTransactionExecuted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGuardianAddress",
				type: "address"
			}
		],
		name: "GuardianshipTransferred",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newMaxInProgressProposals",
				type: "uint256"
			}
		],
		name: "MaxInProgressProposalsUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "enum GovernanceV2.Outcome",
				name: "_outcome",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voteMagnitudeYes",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voteMagnitudeNo",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_numVotes",
				type: "uint256"
			}
		],
		name: "ProposalOutcomeEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_proposer",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_name",
				type: "string"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_description",
				type: "string"
			}
		],
		name: "ProposalSubmitted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bool",
				name: "_success",
				type: "bool"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "_returnData",
				type: "bytes"
			}
		],
		name: "ProposalTransactionExecuted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "ProposalVetoed",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_voter",
				type: "address"
			},
			{
				indexed: true,
				internalType: "enum GovernanceV2.Vote",
				name: "_vote",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voterStake",
				type: "uint256"
			}
		],
		name: "ProposalVoteSubmitted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_voter",
				type: "address"
			},
			{
				indexed: true,
				internalType: "enum GovernanceV2.Vote",
				name: "_vote",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_voterStake",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "enum GovernanceV2.Vote",
				name: "_previousVote",
				type: "uint8"
			}
		],
		name: "ProposalVoteUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newRegistryAddress",
				type: "address"
			}
		],
		name: "RegistryAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newVotingPeriod",
				type: "uint256"
			}
		],
		name: "VotingPeriodUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_newVotingQuorumPercent",
				type: "uint256"
			}
		],
		name: "VotingQuorumPercentUpdated",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_registryAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_votingPeriod",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_executionDelay",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_votingQuorumPercent",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "_maxInProgressProposals",
				type: "uint16"
			},
			{
				internalType: "address",
				name: "_guardianAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			},
			{
				internalType: "string",
				name: "_name",
				type: "string"
			},
			{
				internalType: "string",
				name: "_description",
				type: "string"
			}
		],
		name: "submitProposal",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "enum GovernanceV2.Vote",
				name: "_vote",
				type: "uint8"
			}
		],
		name: "submitVote",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "enum GovernanceV2.Vote",
				name: "_vote",
				type: "uint8"
			}
		],
		name: "updateVote",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "evaluateProposalOutcome",
		outputs: [
			{
				internalType: "enum GovernanceV2.Outcome",
				name: "",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "vetoProposal",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_stakingAddress",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProviderFactoryAddress",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_delegateManagerAddress",
				type: "address"
			}
		],
		name: "setDelegateManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_votingPeriod",
				type: "uint256"
			}
		],
		name: "setVotingPeriod",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_votingQuorumPercent",
				type: "uint256"
			}
		],
		name: "setVotingQuorumPercent",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_registryAddress",
				type: "address"
			}
		],
		name: "setRegistryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint16",
				name: "_newMaxInProgressProposals",
				type: "uint16"
			}
		],
		name: "setMaxInProgressProposals",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_newExecutionDelay",
				type: "uint256"
			}
		],
		name: "setExecutionDelay",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "_functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "_callData",
				type: "bytes"
			}
		],
		name: "guardianExecuteTransaction",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_newGuardianAddress",
				type: "address"
			}
		],
		name: "transferGuardianship",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "getProposalById",
		outputs: [
			{
				internalType: "uint256",
				name: "proposalId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "proposer",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "submissionBlockNumber",
				type: "uint256"
			},
			{
				internalType: "bytes32",
				name: "targetContractRegistryKey",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "targetContractAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "callValue",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "functionSignature",
				type: "string"
			},
			{
				internalType: "bytes",
				name: "callData",
				type: "bytes"
			},
			{
				internalType: "enum GovernanceV2.Outcome",
				name: "outcome",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "voteMagnitudeYes",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "voteMagnitudeNo",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "numVotes",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			}
		],
		name: "getProposalTargetContractHash",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_proposalId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_voter",
				type: "address"
			}
		],
		name: "getVoteInfoByProposalAndVoter",
		outputs: [
			{
				internalType: "enum GovernanceV2.Vote",
				name: "vote",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "voteMagnitude",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGuardianAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDelegateManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getVotingPeriod",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getVotingQuorumPercent",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getRegistryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isGovernanceAddress",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "pure",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getMaxInProgressProposals",
		outputs: [
			{
				internalType: "uint16",
				name: "",
				type: "uint16"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getExecutionDelay",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getInProgressProposals",
		outputs: [
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "inProgressProposalsAreUpToDate",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$t = {
	contractName: contractName$s,
	abi: abi$s
};

const commonjsRegister$s = commonjsRegister$1t;
commonjsRegister$s("/$$rollup_base$$/eth-contracts/ABIs/GovernanceV2.json", function (module, exports) {
  module.exports = require$$1$t;
});

var contractName$r = "IERC20";
var abi$r = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "recipient",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			},
			{
				internalType: "address",
				name: "recipient",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$s = {
	contractName: contractName$r,
	abi: abi$r
};

const commonjsRegister$r = commonjsRegister$1t;
commonjsRegister$r("/$$rollup_base$$/eth-contracts/ABIs/IERC20.json", function (module, exports) {
  module.exports = require$$1$s;
});

var contractName$q = "Initializable";
var abi$q = [
];
var require$$1$r = {
	contractName: contractName$q,
	abi: abi$q
};

const commonjsRegister$q = commonjsRegister$1t;
commonjsRegister$q("/$$rollup_base$$/eth-contracts/ABIs/Initializable.json", function (module, exports) {
  module.exports = require$$1$r;
});

var contractName$p = "InitializableV2";
var abi$p = [
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$q = {
	contractName: contractName$p,
	abi: abi$p
};

const commonjsRegister$p = commonjsRegister$1t;
commonjsRegister$p("/$$rollup_base$$/eth-contracts/ABIs/InitializableV2.json", function (module, exports) {
  module.exports = require$$1$q;
});

var contractName$o = "Migrations";
var abi$o = [
	{
		inputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		constant: true,
		inputs: [
		],
		name: "lastCompletedMigration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_completed",
				type: "uint256"
			}
		],
		name: "setCompleted",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_newAddress",
				type: "address"
			}
		],
		name: "upgrade",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$p = {
	contractName: contractName$o,
	abi: abi$o
};

const commonjsRegister$o = commonjsRegister$1t;
commonjsRegister$o("/$$rollup_base$$/eth-contracts/ABIs/Migrations.json", function (module, exports) {
  module.exports = require$$1$p;
});

var contractName$n = "MinterRole";
var abi$n = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "MinterAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "MinterRemoved",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "isMinter",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "addMinter",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceMinter",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$o = {
	contractName: contractName$n,
	abi: abi$n
};

const commonjsRegister$n = commonjsRegister$1t;
commonjsRegister$n("/$$rollup_base$$/eth-contracts/ABIs/MinterRole.json", function (module, exports) {
  module.exports = require$$1$o;
});

var contractName$m = "MockAccount";
var abi$m = [
	{
		inputs: [
			{
				internalType: "address payable",
				name: "_owner",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_owner",
				type: "address"
			}
		],
		name: "setOwner",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address payable",
				name: "recipient",
				type: "address"
			}
		],
		name: "destroy",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$n = {
	contractName: contractName$m,
	abi: abi$m
};

const commonjsRegister$m = commonjsRegister$1t;
commonjsRegister$m("/$$rollup_base$$/eth-contracts/ABIs/MockAccount.json", function (module, exports) {
  module.exports = require$$1$n;
});

var contractName$l = "MockDelegateManager";
var abi$l = [
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_claimsManagerAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_claimer",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_totalLockedForSP",
				type: "uint256"
			}
		],
		name: "testProcessClaim",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$m = {
	contractName: contractName$l,
	abi: abi$l
};

const commonjsRegister$l = commonjsRegister$1t;
commonjsRegister$l("/$$rollup_base$$/eth-contracts/ABIs/MockDelegateManager.json", function (module, exports) {
  module.exports = require$$1$m;
});

var contractName$k = "MockStakingCaller";
var abi$k = [
	{
		constant: false,
		inputs: [
			{
				internalType: "address payable",
				name: "_stakingAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_staker",
				type: "address"
			}
		],
		name: "stakeRewards",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "stakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "unstakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_slashAddress",
				type: "address"
			}
		],
		name: "slash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bool",
				name: "_withinBounds",
				type: "bool"
			}
		],
		name: "updateBounds",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "getServiceProviderDetails",
		outputs: [
			{
				internalType: "uint256",
				name: "deployerStake",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "deployerCut",
				type: "uint256"
			},
			{
				internalType: "bool",
				name: "validBounds",
				type: "bool"
			},
			{
				internalType: "uint256",
				name: "numberOfEndpoints",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "minAccountStake",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "maxAccountStake",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isInitialized",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "configurePermissions",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_newImplementation",
				type: "address"
			}
		],
		name: "upgradeStakingTo",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setStakingAudiusProxyAdminAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isGovernanceAddress",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "pure",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getAudiusProxyAdminAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$l = {
	contractName: contractName$k,
	abi: abi$k
};

const commonjsRegister$k = commonjsRegister$1t;
commonjsRegister$k("/$$rollup_base$$/eth-contracts/ABIs/MockStakingCaller.json", function (module, exports) {
  module.exports = require$$1$l;
});

var contractName$j = "MockWormhole";
var abi$j = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint16",
				name: "recipientChain",
				type: "uint16"
			},
			{
				indexed: false,
				internalType: "uint16",
				name: "tokenChain",
				type: "uint16"
			},
			{
				indexed: false,
				internalType: "uint8",
				name: "tokenDecimals",
				type: "uint8"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "token",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "sender",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "bytes32",
				name: "recipient",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "arbiterFee",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint32",
				name: "nonce",
				type: "uint32"
			}
		],
		name: "LogTokensTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "recipientChain",
				type: "uint16"
			},
			{
				internalType: "bytes32",
				name: "recipient",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "arbiterFee",
				type: "uint256"
			},
			{
				internalType: "uint32",
				name: "nonce",
				type: "uint32"
			}
		],
		name: "transferTokens",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$k = {
	contractName: contractName$j,
	abi: abi$j
};

const commonjsRegister$j = commonjsRegister$1t;
commonjsRegister$j("/$$rollup_base$$/eth-contracts/ABIs/MockWormhole.json", function (module, exports) {
  module.exports = require$$1$k;
});

var contractName$i = "OpenZeppelinUpgradesAddress";
var abi$i = [
];
var require$$1$j = {
	contractName: contractName$i,
	abi: abi$i
};

const commonjsRegister$i = commonjsRegister$1t;
commonjsRegister$i("/$$rollup_base$$/eth-contracts/ABIs/OpenZeppelinUpgradesAddress.json", function (module, exports) {
  module.exports = require$$1$j;
});

var contractName$h = "Ownable";
var abi$h = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$i = {
	contractName: contractName$h,
	abi: abi$h
};

const commonjsRegister$h = commonjsRegister$1t;
commonjsRegister$h("/$$rollup_base$$/eth-contracts/ABIs/Ownable.json", function (module, exports) {
  module.exports = require$$1$i;
});

var contractName$g = "Pausable";
var abi$g = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "Paused",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "PauserAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "PauserRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "Unpaused",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "addPauser",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "isPauser",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renouncePauser",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "paused",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "pause",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "unpause",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$h = {
	contractName: contractName$g,
	abi: abi$g
};

const commonjsRegister$g = commonjsRegister$1t;
commonjsRegister$g("/$$rollup_base$$/eth-contracts/ABIs/Pausable.json", function (module, exports) {
  module.exports = require$$1$h;
});

var contractName$f = "PauserRole";
var abi$f = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "PauserAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "PauserRemoved",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "isPauser",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "addPauser",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renouncePauser",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$g = {
	contractName: contractName$f,
	abi: abi$f
};

const commonjsRegister$f = commonjsRegister$1t;
commonjsRegister$f("/$$rollup_base$$/eth-contracts/ABIs/PauserRole.json", function (module, exports) {
  module.exports = require$$1$g;
});

var contractName$e = "Proxy";
var abi$e = [
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	}
];
var require$$1$f = {
	contractName: contractName$e,
	abi: abi$e
};

const commonjsRegister$e = commonjsRegister$1t;
commonjsRegister$e("/$$rollup_base$$/eth-contracts/ABIs/Proxy.json", function (module, exports) {
  module.exports = require$$1$f;
});

var contractName$d = "Registry";
var abi$d = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "ContractAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "ContractRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_oldAddress",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_newAddress",
				type: "address"
			}
		],
		name: "ContractUpgraded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		constant: true,
		inputs: [
		],
		name: "isOwner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "addContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			}
		],
		name: "removeContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "_newAddress",
				type: "address"
			}
		],
		name: "upgradeContract",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_version",
				type: "uint256"
			}
		],
		name: "getContract",
		outputs: [
			{
				internalType: "address",
				name: "contractAddr",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			}
		],
		name: "getContract",
		outputs: [
			{
				internalType: "address",
				name: "contractAddr",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_name",
				type: "bytes32"
			}
		],
		name: "getContractVersionCount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$e = {
	contractName: contractName$d,
	abi: abi$d
};

const commonjsRegister$d = commonjsRegister$1t;
commonjsRegister$d("/$$rollup_base$$/eth-contracts/ABIs/Registry.json", function (module, exports) {
  module.exports = require$$1$e;
});

var contractName$c = "Roles";
var abi$c = [
];
var require$$1$d = {
	contractName: contractName$c,
	abi: abi$c
};

const commonjsRegister$c = commonjsRegister$1t;
commonjsRegister$c("/$$rollup_base$$/eth-contracts/ABIs/Roles.json", function (module, exports) {
  module.exports = require$$1$d;
});

var contractName$b = "SafeERC20";
var abi$b = [
];
var require$$1$c = {
	contractName: contractName$b,
	abi: abi$b
};

const commonjsRegister$b = commonjsRegister$1t;
commonjsRegister$b("/$$rollup_base$$/eth-contracts/ABIs/SafeERC20.json", function (module, exports) {
  module.exports = require$$1$c;
});

var contractName$a = "SafeMath";
var abi$a = [
];
var require$$1$b = {
	contractName: contractName$a,
	abi: abi$a
};

const commonjsRegister$a = commonjsRegister$1t;
commonjsRegister$a("/$$rollup_base$$/eth-contracts/ABIs/SafeMath.json", function (module, exports) {
  module.exports = require$$1$b;
});

var contractName$9 = "ServiceProviderFactory";
var abi$9 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newClaimsManagerAddress",
				type: "address"
			}
		],
		name: "ClaimsManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupDuration",
				type: "uint256"
			}
		],
		name: "DecreaseStakeLockupDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_decreaseAmount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "DecreaseStakeRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_decreaseAmount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newStakeAmount",
				type: "uint256"
			}
		],
		name: "DecreaseStakeRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_decreaseAmount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "DecreaseStakeRequested",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newDelegateManagerAddress",
				type: "address"
			}
		],
		name: "DelegateManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_spID",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "address",
				name: "_updatedWallet",
				type: "address"
			}
		],
		name: "DelegateOwnerWalletUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_requestedCut",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_finalCut",
				type: "uint256"
			}
		],
		name: "DeployerCutUpdateRequestCancelled",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_updatedCut",
				type: "uint256"
			}
		],
		name: "DeployerCutUpdateRequestEvaluated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_updatedCut",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupExpiryBlock",
				type: "uint256"
			}
		],
		name: "DeployerCutUpdateRequested",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_spID",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_endpoint",
				type: "string"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_unstakeAmount",
				type: "uint256"
			}
		],
		name: "DeregisteredServiceProvider",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_oldEndpoint",
				type: "string"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_newEndpoint",
				type: "string"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_spID",
				type: "uint256"
			}
		],
		name: "EndpointUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newGovernanceAddress",
				type: "address"
			}
		],
		name: "GovernanceAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_increaseAmount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_newStakeAmount",
				type: "uint256"
			}
		],
		name: "IncreasedStake",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_spID",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "_owner",
				type: "address"
			},
			{
				indexed: false,
				internalType: "string",
				name: "_endpoint",
				type: "string"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "_stakeAmount",
				type: "uint256"
			}
		],
		name: "RegisteredServiceProvider",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newServiceTypeManagerAddress",
				type: "address"
			}
		],
		name: "ServiceTypeManagerAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "_newStakingAddress",
				type: "address"
			}
		],
		name: "StakingAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "_lockupDuration",
				type: "uint256"
			}
		],
		name: "UpdateDeployerCutLockupDurationUpdated",
		type: "event"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_claimsManagerAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_decreaseStakeLockupDuration",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_deployerCutLockupDuration",
				type: "uint256"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			},
			{
				internalType: "uint256",
				name: "_stakeAmount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_delegateOwnerWallet",
				type: "address"
			}
		],
		name: "register",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			}
		],
		name: "deregister",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_increaseStakeAmount",
				type: "uint256"
			}
		],
		name: "increaseStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_decreaseStakeAmount",
				type: "uint256"
			}
		],
		name: "requestDecreaseStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_account",
				type: "address"
			}
		],
		name: "cancelDecreaseStakeRequest",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "decreaseStake",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			},
			{
				internalType: "address",
				name: "_updatedDelegateOwnerWallet",
				type: "address"
			}
		],
		name: "updateDelegateOwnerWallet",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "string",
				name: "_oldEndpoint",
				type: "string"
			},
			{
				internalType: "string",
				name: "_newEndpoint",
				type: "string"
			}
		],
		name: "updateEndpoint",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_cut",
				type: "uint256"
			}
		],
		name: "requestUpdateDeployerCut",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "cancelUpdateDeployerCut",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "updateDeployerCut",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "updateServiceProviderStake",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateDecreaseStakeLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_duration",
				type: "uint256"
			}
		],
		name: "updateDeployerCutLockupDuration",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderDeployerCutBase",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDeployerCutLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "getTotalServiceTypeProviders",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			}
		],
		name: "getServiceProviderIdFromEndpoint",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_ownerAddress",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "getServiceProviderIdsFromAddress",
		outputs: [
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_serviceId",
				type: "uint256"
			}
		],
		name: "getServiceEndpointInfo",
		outputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "string",
				name: "endpoint",
				type: "string"
			},
			{
				internalType: "uint256",
				name: "blockNumber",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "delegateOwnerWallet",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getServiceProviderDetails",
		outputs: [
			{
				internalType: "uint256",
				name: "deployerStake",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "deployerCut",
				type: "uint256"
			},
			{
				internalType: "bool",
				name: "validBounds",
				type: "bool"
			},
			{
				internalType: "uint256",
				name: "numberOfEndpoints",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "minAccountStake",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "maxAccountStake",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getPendingDecreaseStakeRequest",
		outputs: [
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "lockupExpiryBlock",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "getPendingUpdateDeployerCutRequest",
		outputs: [
			{
				internalType: "uint256",
				name: "newDeployerCut",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "lockupExpiryBlock",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDecreaseStakeLockupDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_serviceProvider",
				type: "address"
			}
		],
		name: "validateAccountStakeBalance",
		outputs: [
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getStakingAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDelegateManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceTypeManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getClaimsManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "setStakingAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "setDelegateManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "setServiceTypeManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_address",
				type: "address"
			}
		],
		name: "setClaimsManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$a = {
	contractName: contractName$9,
	abi: abi$9
};

const commonjsRegister$9 = commonjsRegister$1t;
commonjsRegister$9("/$$rollup_base$$/eth-contracts/ABIs/ServiceProviderFactory.json", function (module, exports) {
  module.exports = require$$1$a;
});

var contractName$8 = "ServiceTypeManager";
var abi$8 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_serviceTypeMin",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "_serviceTypeMax",
				type: "uint256"
			}
		],
		name: "ServiceTypeAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "ServiceTypeRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "_serviceVersion",
				type: "bytes32"
			}
		],
		name: "SetServiceVersion",
		type: "event"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_serviceTypeMin",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "_serviceTypeMax",
				type: "uint256"
			}
		],
		name: "addServiceType",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "removeServiceType",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "getServiceTypeInfo",
		outputs: [
			{
				internalType: "bool",
				name: "isValid",
				type: "bool"
			},
			{
				internalType: "uint256",
				name: "minStake",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "maxStake",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getValidServiceTypes",
		outputs: [
			{
				internalType: "bytes32[]",
				name: "",
				type: "bytes32[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "serviceTypeIsValid",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_serviceVersion",
				type: "bytes32"
			}
		],
		name: "setServiceVersion",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "_versionIndex",
				type: "uint256"
			}
		],
		name: "getVersion",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "getCurrentVersion",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			}
		],
		name: "getNumberOfVersions",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "bytes32",
				name: "_serviceType",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "_serviceVersion",
				type: "bytes32"
			}
		],
		name: "serviceVersionIsValid",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$9 = {
	contractName: contractName$8,
	abi: abi$8
};

const commonjsRegister$8 = commonjsRegister$1t;
commonjsRegister$8("/$$rollup_base$$/eth-contracts/ABIs/ServiceTypeManager.json", function (module, exports) {
  module.exports = require$$1$9;
});

var contractName$7 = "Staking";
var abi$7 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "total",
				type: "uint256"
			}
		],
		name: "Slashed",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "total",
				type: "uint256"
			}
		],
		name: "Staked",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "total",
				type: "uint256"
			}
		],
		name: "Unstaked",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_claimsManager",
				type: "address"
			}
		],
		name: "setClaimsManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_spFactory",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_delegateManager",
				type: "address"
			}
		],
		name: "setDelegateManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_stakerAccount",
				type: "address"
			}
		],
		name: "stakeRewards",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_stakerAccount",
				type: "address"
			}
		],
		name: "updateClaimHistory",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_slashAddress",
				type: "address"
			}
		],
		name: "slash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "stakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "unstakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegatorAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "delegateStakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegatorAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "undelegateStakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "token",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "supportsHistory",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "lastStakedFor",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "lastClaimedFor",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			}
		],
		name: "totalStakedForAt",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			}
		],
		name: "totalStakedAt",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getClaimsManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDelegateManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "isStaker",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "totalStakedFor",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalStaked",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$8 = {
	contractName: contractName$7,
	abi: abi$7
};

const commonjsRegister$7 = commonjsRegister$1t;
commonjsRegister$7("/$$rollup_base$$/eth-contracts/ABIs/Staking.json", function (module, exports) {
  module.exports = require$$1$8;
});

var contractName$6 = "StakingUpgraded";
var abi$6 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "total",
				type: "uint256"
			}
		],
		name: "Slashed",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "total",
				type: "uint256"
			}
		],
		name: "Staked",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "total",
				type: "uint256"
			}
		],
		name: "Unstaked",
		type: "event"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegatorAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "delegateStakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getClaimsManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getDelegateManagerAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getServiceProviderFactoryAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "isStaker",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "lastClaimedFor",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "lastStakedFor",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_claimsManager",
				type: "address"
			}
		],
		name: "setClaimsManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_delegateManager",
				type: "address"
			}
		],
		name: "setDelegateManagerAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_spFactory",
				type: "address"
			}
		],
		name: "setServiceProviderFactoryAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_slashAddress",
				type: "address"
			}
		],
		name: "slash",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "stakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_stakerAccount",
				type: "address"
			}
		],
		name: "stakeRewards",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "supportsHistory",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "token",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalStaked",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			}
		],
		name: "totalStakedAt",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			}
		],
		name: "totalStakedFor",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_blockNumber",
				type: "uint256"
			}
		],
		name: "totalStakedForAt",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_delegatorAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "undelegateStakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_accountAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			}
		],
		name: "unstakeFor",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_amount",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_stakerAccount",
				type: "address"
			}
		],
		name: "updateClaimHistory",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "newFunction",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];
var require$$1$7 = {
	contractName: contractName$6,
	abi: abi$6
};

const commonjsRegister$6 = commonjsRegister$1t;
commonjsRegister$6("/$$rollup_base$$/eth-contracts/ABIs/StakingUpgraded.json", function (module, exports) {
  module.exports = require$$1$7;
});

var contractName$5 = "TestContract";
var abi$5 = [
	{
		constant: true,
		inputs: [
		],
		name: "x",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "uint256",
				name: "_x",
				type: "uint256"
			}
		],
		name: "setX",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$6 = {
	contractName: contractName$5,
	abi: abi$5
};

const commonjsRegister$5 = commonjsRegister$1t;
commonjsRegister$5("/$$rollup_base$$/eth-contracts/ABIs/TestContract.json", function (module, exports) {
  module.exports = require$$1$6;
});

var contractName$4 = "TrustedNotifierManager";
var abi$4 = [
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_initialNotifierWallet",
				type: "address"
			},
			{
				internalType: "string",
				name: "_initialNotiferEndpoint",
				type: "string"
			},
			{
				internalType: "string",
				name: "_initialNotiferEmail",
				type: "string"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_wallet",
				type: "address"
			},
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			},
			{
				internalType: "string",
				name: "_email",
				type: "string"
			}
		],
		name: "registerNotifier",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_wallet",
				type: "address"
			}
		],
		name: "deregisterNotifier",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getLatestNotifierID",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "uint256",
				name: "_ID",
				type: "uint256"
			}
		],
		name: "getNotifierForID",
		outputs: [
			{
				internalType: "address",
				name: "wallet",
				type: "address"
			},
			{
				internalType: "string",
				name: "endpoint",
				type: "string"
			},
			{
				internalType: "string",
				name: "email",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "_wallet",
				type: "address"
			}
		],
		name: "getNotifierForWallet",
		outputs: [
			{
				internalType: "uint256",
				name: "ID",
				type: "uint256"
			},
			{
				internalType: "string",
				name: "endpoint",
				type: "string"
			},
			{
				internalType: "string",
				name: "email",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "string",
				name: "_endpoint",
				type: "string"
			}
		],
		name: "getNotifierForEndpoint",
		outputs: [
			{
				internalType: "uint256",
				name: "ID",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "wallet",
				type: "address"
			},
			{
				internalType: "string",
				name: "email",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "string",
				name: "_email",
				type: "string"
			}
		],
		name: "getNotifierForEmail",
		outputs: [
			{
				internalType: "uint256",
				name: "ID",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "wallet",
				type: "address"
			},
			{
				internalType: "string",
				name: "endpoint",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getGovernanceAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_governanceAddress",
				type: "address"
			}
		],
		name: "setGovernanceAddress",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$5 = {
	contractName: contractName$4,
	abi: abi$4
};

const commonjsRegister$4 = commonjsRegister$1t;
commonjsRegister$4("/$$rollup_base$$/eth-contracts/ABIs/TrustedNotifierManager.json", function (module, exports) {
  module.exports = require$$1$5;
});

var contractName$3 = "Uint256Helpers";
var abi$3 = [
];
var require$$1$4 = {
	contractName: contractName$3,
	abi: abi$3
};

const commonjsRegister$3 = commonjsRegister$1t;
commonjsRegister$3("/$$rollup_base$$/eth-contracts/ABIs/Uint256Helpers.json", function (module, exports) {
  module.exports = require$$1$4;
});

var contractName$2 = "UpgradeabilityProxy";
var abi$2 = [
	{
		inputs: [
			{
				internalType: "address",
				name: "_logic",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "_data",
				type: "bytes"
			}
		],
		payable: true,
		stateMutability: "payable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "implementation",
				type: "address"
			}
		],
		name: "Upgraded",
		type: "event"
	},
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	}
];
var require$$1$3 = {
	contractName: contractName$2,
	abi: abi$2
};

const commonjsRegister$2 = commonjsRegister$1t;
commonjsRegister$2("/$$rollup_base$$/eth-contracts/ABIs/UpgradeabilityProxy.json", function (module, exports) {
  module.exports = require$$1$3;
});

var contractName$1 = "Wormhole";
var abi$1 = [
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "recipientChain",
				type: "uint16"
			},
			{
				internalType: "bytes32",
				name: "recipient",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "arbiterFee",
				type: "uint256"
			},
			{
				internalType: "uint32",
				name: "nonce",
				type: "uint32"
			}
		],
		name: "transferTokens",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$2 = {
	contractName: contractName$1,
	abi: abi$1
};

const commonjsRegister$1 = commonjsRegister$1t;
commonjsRegister$1("/$$rollup_base$$/eth-contracts/ABIs/Wormhole.json", function (module, exports) {
  module.exports = require$$1$2;
});

var contractName = "WormholeClient";
var abi = [
	{
		constant: true,
		inputs: [
		],
		name: "DOMAIN_SEPARATOR",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "TRANSFER_TOKENS_TYPEHASH",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "nonces",
		outputs: [
			{
				internalType: "uint32",
				name: "",
				type: "uint32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "token",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "_tokenAddress",
				type: "address"
			},
			{
				internalType: "address",
				name: "_wormholeAddress",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint16",
				name: "recipientChain",
				type: "uint16"
			},
			{
				internalType: "bytes32",
				name: "recipient",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "arbiterFee",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "deadline",
				type: "uint256"
			},
			{
				internalType: "uint8",
				name: "v",
				type: "uint8"
			},
			{
				internalType: "bytes32",
				name: "r",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "s",
				type: "bytes32"
			}
		],
		name: "transferTokens",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	}
];
var require$$1$1 = {
	contractName: contractName,
	abi: abi
};

const commonjsRegister = commonjsRegister$1t;
commonjsRegister("/$$rollup_base$$/eth-contracts/ABIs/WormholeClient.json", function (module, exports) {
  module.exports = require$$1$1;
});

var name = "@audius/libs";
var version = "1.2.118";
var description = "";
var main = "dist/index.js";
var types = "dist/index.d.ts";
var core = "dist/core.js";
var coreTypes = "dist/core.d.ts";
var browser = {
	fs: false,
	"node-localstorage": false,
	crypto: false,
	web3: false,
	esm: false,
	"ipfs-unixfs-importer": false,
	stream: false,
	"interface-blockstore": false,
	"interface-store": false,
	"multiformats/cid": false
};
var scripts = {
	"init-local": "ts-node initScripts/local.js",
	test: "./scripts/test.sh",
	"test-circle-ci": "./scripts/circleci-test.sh",
	"test:unit": "ts-mocha 'src/**/*.test.{js,ts}' --exit",
	"test:unit:watch": "ts-mocha 'src/**/*.test.{js,ts}' --watch",
	"test:integration": "ts-mocha tests/index.js",
	setup: "./scripts/migrate_contracts.sh",
	build: "rollup -c",
	dev: "rollup -c -w",
	lint: "eslint ./src ./types",
	"lint:fix": "npm run lint -- --fix",
	typecheck: "tsc --noEmit"
};
var dependencies = {
	"@audius/anchor-audius-data": "0.0.2",
	"@audius/hedgehog": "1.0.12",
	"@certusone/wormhole-sdk": "0.1.1",
	"@ethersproject/solidity": "5.0.5",
	"@improbable-eng/grpc-web-node-http-transport": "0.15.0",
	"@project-serum/anchor": "0.24.1",
	"@solana/spl-token": "0.1.6",
	"@solana/web3.js": "1.37.1",
	"abi-decoder": "1.2.0",
	ajv: "6.12.2",
	"async-retry": "1.3.1",
	axios: "0.19.2",
	borsh: "0.4.0",
	bs58: "4.0.1",
	elliptic: "6.5.4",
	esm: "3.2.25",
	"eth-sig-util": "2.5.4",
	"ethereumjs-tx": "2.1.2",
	ethers: "5.4.7",
	"form-data": "3.0.0",
	hashids: "2.2.10",
	"interface-blockstore": "^2.0.3",
	"interface-store": "^2.0.2",
	"ipfs-unixfs-importer": "^9.0.6",
	jsonschema: "1.2.6",
	keccak256: "1.0.2",
	lodash: "4.17.21",
	"node-localstorage": "^1.3.1",
	"proper-url-join": "1.2.0",
	secp256k1: "4.0.2",
	semver: "6.3.0",
	web3: "1.7.1"
};
var devDependencies = {
	"@babel/preset-env": "7.16.11",
	"@openzeppelin/test-helpers": "0.5.6",
	"@rollup/plugin-babel": "5.3.1",
	"@rollup/plugin-commonjs": "21.0.2",
	"@rollup/plugin-json": "4.1.0",
	"@rollup/plugin-node-resolve": "13.1.3",
	"@rollup/plugin-typescript": "8.3.1",
	"@tsconfig/node16-strictest": "1.0.0",
	"@types/async-retry": "1.4.3",
	"@types/bn.js": "5.1.0",
	"@types/bs58": "4.0.1",
	"@types/eth-sig-util": "^2.1.1",
	"@types/expect": "24.3.0",
	"@types/form-data": "^2.5.0",
	"@types/hashids": "2.0.1",
	"@types/mocha": "9.1.0",
	"@types/node-localstorage": "1.3.0",
	"@types/proper-url-join": "2.1.1",
	"@types/semver": "7.3.9",
	"@typescript-eslint/eslint-plugin": "4.33.0",
	eslint: "7.32.0",
	"eslint-config-prettier": "^8.5.0",
	"eslint-config-standard-with-typescript": "21.0.1",
	"eslint-plugin-import": "2.25.4",
	"eslint-plugin-mocha": "10.0.3",
	"eslint-plugin-node": "11.1.0",
	"eslint-plugin-prettier": "^4.0.0",
	"eslint-plugin-promise": "5.2.0",
	"ethereumjs-wallet": "^1.0.2",
	mocha: "9.2.2",
	nock: "13.1.2",
	nyc: "15.1.0",
	prettier: "^2.6.1",
	"prettier-config-standard": "^5.0.0",
	rollup: "2.70.1",
	"rollup-plugin-dts": "4.2.0",
	sinon: "9.0.2",
	standard: "16.0.4",
	"ts-mocha": "9.0.2",
	"ts-node": "10.7.0",
	typescript: "4.6.2"
};
var repository = {
	type: "git",
	url: "git+https://github.com/AudiusProject/audius-protocol/tree/master/libs"
};
var engines = {
	node: ">=14.0.0"
};
var author = "Audius";
var license = "Apache-2.0";
var bugs = {
	url: "https://github.com/AudiusProject/audius-protocol/issues"
};
var homepage = "https://github.com/AudiusProject/audius-protocol/tree/master/libs";
var require$$0$2 = {
	name: name,
	version: version,
	description: description,
	main: main,
	types: types,
	core: core,
	coreTypes: coreTypes,
	browser: browser,
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies,
	repository: repository,
	engines: engines,
	author: author,
	license: license,
	bugs: bugs,
	homepage: homepage
};

var Web3;

if (typeof window !== 'undefined' && window && window.Web3) {
  Web3 = window.Web3;
} else {
  Web3 = require$$0__default["default"];
}

var web3 = Web3;

var getSendMethod = function getSendMethod(provider) {
  if ('sendAsync' in provider) {
    return provider.sendAsync;
  }

  return provider.send;
};
/**
 * web3 consumes a provider object on initialization
 * ref: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3/types/index.d.ts#L31
 * which references: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3-core/types/index.d.ts#L436
 * MultiProvider implements HttpProvider which can be consumed by web3
 * ref for HttpProvider: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3-providers-http/types/index.d.ts#L46-L66
 */


var MultiProvider = /*#__PURE__*/function (_Web3$providers$HttpP) {
  _inherits(MultiProvider, _Web3$providers$HttpP);

  var _super = _createSuper(MultiProvider);

  /**
   * Creates a MultiProvider
   * @param {Array<string | Provider> | string} - The providers to use.
   */
  function MultiProvider(providers) {
    var _web3ProviderInstance;

    var _this;

    _classCallCheck(this, MultiProvider);

    var web3Providers;

    if (typeof providers === 'string') {
      web3Providers = providers.split(',');
    } else if (!Array.isArray(providers)) {
      web3Providers = [providers];
    } else {
      web3Providers = providers;
    } // The below line ensures that we support different types of providers i.e. comma separated strings, an array of strings or an array of providers.


    var web3ProviderInstances = web3Providers.map(function (provider) {
      return new web3(provider).eth.currentProvider;
    });
    _this = _super.call(this, (_web3ProviderInstance = web3ProviderInstances[0]) === null || _web3ProviderInstance === void 0 ? void 0 : _web3ProviderInstance.host);

    if (!web3ProviderInstances.every(getSendMethod)) {
      throw new Error('Some providers do not have a send method to use.');
    }

    _this.providers = web3ProviderInstances; // We replace HttpProvider.send with a custom function that supports fallback providers.

    _this.send = util.callbackify(_this._send.bind(_assertThisInitialized(_this))); // web3 only supports callback functions and not async

    return _this;
  }
  /**
   * @method _send
   * @param {Object} payload
   */


  _createClass(MultiProvider, [{
    key: "_send",
    value: function () {
      var _send2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(payload) {
        var _iterator, _step, provider, send, result;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _iterator = _createForOfIteratorHelper(require$$0$4.shuffle(this.providers));
                _context.prev = 1;

                _iterator.s();

              case 3:
                if ((_step = _iterator.n()).done) {
                  _context.next = 18;
                  break;
                }

                provider = _step.value;
                _context.prev = 5;
                send = util.promisify(getSendMethod(provider).bind(provider));
                _context.next = 9;
                return send(payload);

              case 9:
                result = _context.sent;
                return _context.abrupt("return", result);

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](5);
                console.log(_context.t0);

              case 16:
                _context.next = 3;
                break;

              case 18:
                _context.next = 23;
                break;

              case 20:
                _context.prev = 20;
                _context.t1 = _context["catch"](1);

                _iterator.e(_context.t1);

              case 23:
                _context.prev = 23;

                _iterator.f();

                return _context.finish(23);

              case 26:
                throw new Error('All requests failed');

              case 27:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 20, 23, 26], [5, 13]]);
      }));

      function _send(_x) {
        return _send2.apply(this, arguments);
      }

      return _send;
    }()
  }]);

  return MultiProvider;
}(web3.providers.HttpProvider);

var uuid = function uuid() {
  // https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/873856#873856
  var s = [];
  var hexDigits = '0123456789abcdef';

  for (var i = 0; i < 36; i++) {
    s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
  }

  s[14] = '4'; // bits 12-15 of the time_hi_and_version field to 0010

  s[19] = hexDigits.substr(s[19] | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01

  s[8] = s[13] = s[18] = s[23] = '-';
  var uuid = s.join('');
  return uuid;
};

var importDataContractABIs = function importDataContractABIs(pathStr) {
  // need to specify part of path here because of https://github.com/webpack/webpack/issues/4921#issuecomment-357147299
  var importFile = commonjsRequire("../../data-contracts/ABIs/".concat(pathStr), "/$$rollup_base$$/src/utils");
  if (importFile) return importFile;else throw new Error("Data contract ABI not found ".concat(pathStr));
};

var importEthContractABIs = function importEthContractABIs(pathStr) {
  // need to specify part of path here because of https://github.com/webpack/webpack/issues/4921#issuecomment-357147299
  var importFile = commonjsRequire("../../eth-contracts/ABIs/".concat(pathStr), "/$$rollup_base$$/src/utils");
  if (importFile) return importFile;else throw new Error("Eth contract ABI not found ".concat(pathStr));
};

var importContractABI = {
  importDataContractABIs: importDataContractABIs,
  importEthContractABIs: importEthContractABIs
};

var block = {
  get: function () {
    var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, _options) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              throw new Error("unexpected block API get for ".concat(key));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function get(_x, _x2) {
      return _get.apply(this, arguments);
    }

    return get;
  }(),
  put: function () {
    var _put = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_key, _val, _options) {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              throw new Error('unexpected block API put');

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function put(_x3, _x4, _x5) {
      return _put.apply(this, arguments);
    }

    return put;
  }(),
  open: function () {
    var _open = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function open() {
      return _open.apply(this, arguments);
    }

    return open;
  }(),
  close: function () {
    var _close = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function close() {
      return _close.apply(this, arguments);
    }

    return close;
  }(),
  has: function () {
    var _has = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_key, _options) {
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function has(_x6, _x7) {
      return _has.apply(this, arguments);
    }

    return has;
  }(),
  "delete": function () {
    var _delete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_key, _options) {
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              throw new Error('Function not implemented.');

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    function _delete(_x8, _x9) {
      return _delete2.apply(this, arguments);
    }

    return _delete;
  }(),
  putMany: function putMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  getMany: function getMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  deleteMany: function deleteMany(_source, _options) {
    throw new Error('Function not implemented.');
  },
  batch: function batch() {
    throw new Error('Function not implemented.');
  },
  query: function query(_query, _options) {
    throw new Error('Function not implemented.');
  },
  queryKeys: function queryKeys(_query, _options) {
    throw new Error('Function not implemented.');
  }
};
var fileHasher = {
  convertNanosToMillis: function convertNanosToMillis(nanoSeconds) {
    return nanoSeconds / BigInt(1000000);
  },

  /**
   * Used to initalize the only hash fns. See Alan Shaw's reference code for more context.
   */
  initImageHasher: function initImageHasher(content, options) {
    options = options || {};
    options.onlyHash = true;
    options.cidVersion = 0;
    return {
      options: options,
      content: content
    };
  },

  /**
   * Used to iniitalize the only hash fns. See Alan Shaw's reference code for more context.
   */
  initNonImageHasher: function initNonImageHasher(content, options) {
    options = options || {};
    options.onlyHash = true;
    options.cidVersion = 0;
    return {
      options: options,
      content: content
    };
  },

  /**
   * Convert content to a buffer; used in `generateNonImageCid()`.
   * @param {ReadStream|Buffer|string} content if string, should be file path
   * @param {Object} logger
   * @returns buffer version of content
   */
  convertToBuffer: function convertToBuffer(content, logger) {
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
      var buffer, fsReadFile, errMsg;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!Buffer.isBuffer(content)) {
                _context7.next = 2;
                break;
              }

              return _context7.abrupt("return", content);

            case 2:
              _context7.prev = 2;

              if (!(content instanceof stream.Stream.Readable)) {
                _context7.next = 8;
                break;
              }

              _context7.next = 6;
              return new Promise(function (resolve, reject) {
                content.on('data', function (chunk) {
                  return buffer.push(chunk);
                });
                content.on('end', function () {
                  return resolve(Buffer.concat(buffer));
                });
                content.on('error', function (err) {
                  return reject(err);
                });
              });

            case 6:
              _context7.next = 12;
              break;

            case 8:
              fsReadFile = util.promisify(fs__default["default"].readFile);
              _context7.next = 11;
              return fsReadFile(content);

            case 11:
              buffer = _context7.sent;

            case 12:
              _context7.next = 19;
              break;

            case 14:
              _context7.prev = 14;
              _context7.t0 = _context7["catch"](2);
              errMsg = "[fileHasher - convertToBuffer()] Could not convert content into buffer: ".concat(_context7.t0.toString());
              logger.error(errMsg);
              throw new Error(errMsg);

            case 19:
              return _context7.abrupt("return", buffer);

            case 20:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, null, [[2, 14]]);
    }))();
  },

  /**
   * Custom fn to generate the content-hashing logic
   * @param content a buffer of the content
   * @param options options for importer
   * @returns the CID from content addressing logic
   */
  hashNonImages: function hashNonImages(content) {
    var _arguments = arguments;
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
      var options, _fileHasher$initNonIm, lastCid, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, cid;

      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};
              _fileHasher$initNonIm = fileHasher.initNonImageHasher(content, options);
              options = _fileHasher$initNonIm.options;
              content = _fileHasher$initNonIm.content;
              lastCid = '';
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context8.prev = 8;
              _iterator = _asyncIterator(ipfsUnixfsImporter.importer([{
                content: content
              }], block, options));

            case 10:
              _context8.next = 12;
              return _iterator.next();

            case 12:
              if (!(_iteratorAbruptCompletion = !(_step = _context8.sent).done)) {
                _context8.next = 18;
                break;
              }

              cid = _step.value.cid;
              lastCid = "".concat(cid);

            case 15:
              _iteratorAbruptCompletion = false;
              _context8.next = 10;
              break;

            case 18:
              _context8.next = 24;
              break;

            case 20:
              _context8.prev = 20;
              _context8.t0 = _context8["catch"](8);
              _didIteratorError = true;
              _iteratorError = _context8.t0;

            case 24:
              _context8.prev = 24;
              _context8.prev = 25;

              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context8.next = 29;
                break;
              }

              _context8.next = 29;
              return _iterator["return"]();

            case 29:
              _context8.prev = 29;

              if (!_didIteratorError) {
                _context8.next = 32;
                break;
              }

              throw _iteratorError;

            case 32:
              return _context8.finish(29);

            case 33:
              return _context8.finish(24);

            case 34:
              return _context8.abrupt("return", lastCid);

            case 35:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, null, [[8, 20, 24, 34], [25,, 29, 33]]);
    }))();
  },

  /**
   * Custom fn to generate the content-hashing logic
   * @param content an Object[] with the structure [{ path: string, content: buffer }, ...]
   * @param options options for importer
   * @returns an Object[] with the structure [{path: <string>, cid: <string>, size: <number>}]
   *
   * Example with adding a profile picture:
   * [
      {
        "cid": "QmSRyKvnXwoxPZ9UxqxXPR8NXjcPYBEf1qbNrXyo5USqLL",
        "path": "blob/150x150.jpg",
        "size": 3091
      },
      {
        "cid": "QmQQMV9TXxRmDKafZiRvMVkqUNtUu9WGAfukUBS1yCk2ht",
        "path": "blob/480x480.jpg",
        "size": 20743
      },
      {
        "cid": "Qmd8cDdDGcWVaLEoJPVFtkKhYMqvHXZTvXcisYjubFxv1F",
        "path": "blob/1000x1000.jpg",
        "size": 72621
      },
      {
        "cid": "QmaYCPUH8G14yxetsMgW5J5tpTqPaTp3HMd3EAyffZKSvm",
        "path": "blob/original.jpg",
        "size": 185844
      },
      {
        "cid": "QmW8FUFhvaxv1MZmVcUcmR7Tg9WZhGf8xDNBesT9XepwrK",
        "path": "blob",
        "size": 282525
      }
    ]
  */
  hashImages: function hashImages(content) {
    var _arguments2 = arguments;
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
      var options, _fileHasher$initImage, result, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, file;

      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};
              _fileHasher$initImage = fileHasher.initImageHasher(content, options);
              options = _fileHasher$initImage.options;
              content = _fileHasher$initImage.content;
              result = [];
              _iteratorAbruptCompletion2 = false;
              _didIteratorError2 = false;
              _context9.prev = 8;
              _iterator2 = _asyncIterator(ipfsUnixfsImporter.importer(content, block, options));

            case 10:
              _context9.next = 12;
              return _iterator2.next();

            case 12:
              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context9.sent).done)) {
                _context9.next = 18;
                break;
              }

              file = _step2.value;
              result.push({
                path: file.path,
                cid: "".concat(file.cid),
                size: file.size
              });

            case 15:
              _iteratorAbruptCompletion2 = false;
              _context9.next = 10;
              break;

            case 18:
              _context9.next = 24;
              break;

            case 20:
              _context9.prev = 20;
              _context9.t0 = _context9["catch"](8);
              _didIteratorError2 = true;
              _iteratorError2 = _context9.t0;

            case 24:
              _context9.prev = 24;
              _context9.prev = 25;

              if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                _context9.next = 29;
                break;
              }

              _context9.next = 29;
              return _iterator2["return"]();

            case 29:
              _context9.prev = 29;

              if (!_didIteratorError2) {
                _context9.next = 32;
                break;
              }

              throw _iteratorError2;

            case 32:
              return _context9.finish(29);

            case 33:
              return _context9.finish(24);

            case 34:
              return _context9.abrupt("return", result);

            case 35:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, null, [[8, 20, 24, 34], [25,, 29, 33]]);
    }))();
  },

  /**
   * Generates CID for a non-image file (track segment, track transcode, metadata)
   * @param {Buffer|ReadStream|string} content a single Buffer, a ReadStream, or path to an existing file
   * @param {Object?} logger
   * @returns {string} only hash response cid
   */
  generateNonImageCid: function generateNonImageCid(content) {
    var _arguments3 = arguments;
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
      var logger, buffer, startHashing, cid, hashDurationMs;
      return regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              logger = _arguments3.length > 1 && _arguments3[1] !== undefined ? _arguments3[1] : console;
              _context10.next = 3;
              return fileHasher.convertToBuffer(content, logger);

            case 3:
              buffer = _context10.sent;
              startHashing = process.hrtime.bigint();
              _context10.next = 7;
              return fileHasher.hashNonImages(buffer);

            case 7:
              cid = _context10.sent;
              hashDurationMs = fileHasher.convertNanosToMillis(process.hrtime.bigint() - startHashing);
              logger.info("[fileHasher - generateNonImageCid()] CID=".concat(cid, " hashDurationMs=").concat(hashDurationMs, "ms"));
              return _context10.abrupt("return", cid);

            case 11:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }))();
  },

  /**
   * Wrapper that generates multihashes for image files
   * @param {Object[]} content an Object[] with the structure [{ path: string, content: buffer }, ...]
   * @param {Object?} logger
   * @returns {HashedImage[]} only hash responses with the structure [{path: <string>, cid: <string>, size: <number>}]
   */
  generateImageCids: function generateImageCids(content) {
    var _arguments4 = arguments;
    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
      var logger, startHashing, hashedImages, hashDurationMs, hashedImagesStr;
      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              logger = _arguments4.length > 1 && _arguments4[1] !== undefined ? _arguments4[1] : console;
              startHashing = process.hrtime.bigint();
              _context11.next = 4;
              return fileHasher.hashImages(content);

            case 4:
              hashedImages = _context11.sent;
              hashDurationMs = fileHasher.convertNanosToMillis(process.hrtime.bigint() - startHashing);
              hashedImagesStr = JSON.stringify(hashedImages);
              logger.info("[fileHasher - generateImageCids()] hashedImages=".concat(hashedImagesStr, " hashImagesDurationMs=").concat(hashDurationMs, "ms"));
              return _context11.abrupt("return", hashedImages);

            case 9:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }))();
  }
};

var HASH_SALT = 'azowernasdfoia';
var MIN_LENGTH = 5;
var hashids = new Hashids__default["default"](HASH_SALT, MIN_LENGTH);
var ZeroAddress = '0x0000000000000000000000000000000000000000'; // eslint-disable-next-line @typescript-eslint/no-extraneous-class -- this should just be esm

var Utils$b = /*#__PURE__*/function () {
  function Utils() {
    _classCallCheck(this, Utils);
  }

  _createClass(Utils, null, [{
    key: "importDataContractABI",
    value: function importDataContractABI(pathStr) {
      return importContractABI.importDataContractABIs(pathStr);
    }
  }, {
    key: "importEthContractABI",
    value: function importEthContractABI(pathStr) {
      return importContractABI.importEthContractABIs(pathStr);
    }
  }, {
    key: "utf8ToHex",
    value: function utf8ToHex(utf8Str) {
      return web3.utils.utf8ToHex(utf8Str);
    }
  }, {
    key: "padRight",
    value: function padRight(hexStr, size) {
      return web3.utils.padRight(hexStr, size);
    }
  }, {
    key: "hexToUtf8",
    value: function hexToUtf8(hexStr) {
      return web3.utils.hexToUtf8(hexStr);
    }
  }, {
    key: "keccak256",
    value: function keccak256(utf8Str) {
      return web3.utils.keccak256(utf8Str);
    }
  }, {
    key: "isBN",
    value: function isBN(number) {
      return web3.utils.isBN(number);
    }
  }, {
    key: "toBN",
    value: function toBN(number, base) {
      return new web3.utils.BN(number, base);
    }
  }, {
    key: "BN",
    value: function BN() {
      return web3.utils.BN;
    }
  }, {
    key: "checkStrLen",
    value: function checkStrLen(str, maxLen) {
      var minLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      if (str === undefined || str === null || str.length > maxLen || str.length < minLen) {
        throw new Error("String '".concat(str, "' must be between ").concat(minLen, "-").concat(maxLen, " characters"));
      }
    }
  }, {
    key: "wait",
    value: function () {
      var _wait = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(milliseconds) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, milliseconds);
                });

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function wait(_x) {
        return _wait.apply(this, arguments);
      }

      return wait;
    }() // Regular expression to check if endpoint is a FQDN. https://regex101.com/r/kIowvx/2

  }, {
    key: "isFQDN",
    value: function isFQDN(url) {
      var FQDN = /(?:^|[ \t])((https?:\/\/)?(?:localhost|[\w-]+(?:\.[\w-]+)+)(:\d+)?(\/\S*)?)/gm;
      return FQDN.test(url);
    }
  }, {
    key: "isHttps",
    value: function isHttps(url) {
      var https = /^https:\/\//;
      return https.test(url);
    } // Function to check if the endpont/health_check returns JSON object [ {'healthy':true} ]

  }, {
    key: "isHealthy",
    value: function () {
      var _isHealthy = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url) {
        var _yield$axios$get, body;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return axios__default["default"].get(url + '/health_check');

              case 3:
                _yield$axios$get = _context2.sent;
                body = _yield$axios$get.data;
                return _context2.abrupt("return", body.data.healthy);

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](0);
                return _context2.abrupt("return", false);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[0, 8]]);
      }));

      function isHealthy(_x2) {
        return _isHealthy.apply(this, arguments);
      }

      return isHealthy;
    }()
  }, {
    key: "formatOptionalMultihash",
    value: function formatOptionalMultihash(multihash) {
      if (multihash) {
        return this.decodeMultihash(multihash).digest;
      } else {
        return this.utf8ToHex('');
      }
    }
  }, {
    key: "decodeMultihash",
    value: function decodeMultihash(multihash) {
      var base16Multihash = bs58__default["default"].decode(multihash);
      return {
        digest: "0x".concat(base16Multihash.slice(2).toString('hex')),
        hashFn: parseInt(base16Multihash[0]),
        size: parseInt(base16Multihash[1])
      };
    }
    /**
     * Given a digest value (written on chain, obtained through AudiusABIDecoder.decodeMethod),
     * convert back to a IFPS CIDv0
     * @param multihashDigest digest value from decodeMultihash
     * @returns String CID value
     */

  }, {
    key: "encodeMultihash",
    value: function encodeMultihash(multihashDigest) {
      // the 1220 is from reconstructing the hashFn and size with digest, the opposite of decodeMultihash
      // since IPFS CIDv0 has a fixed hashFn and size, the first two values are always 12 and 20
      // concat them together with digest and encode back to base58
      var digestStr = "1220".concat(multihashDigest.replace('0x', '')); // convert digestStr from hex to base 58

      return bs58__default["default"].encode(Buffer.from(digestStr, 'hex'));
    }
  }, {
    key: "parseDataFromResponse",
    value: function parseDataFromResponse(response) {
      if (!response || !response.data) return null;
      var obj = response.data; // adapted from https://github.com/jashkenas/underscore/blob/master/underscore.js _.isEmpty function

      if (obj == null) return null;
      if ((Array.isArray(obj) || typeof obj === 'string') && obj.length === 0) return null;
      if (Object.keys(obj).length === 0) return null;
      return obj;
    }
  }, {
    key: "configureWeb3",
    value: function () {
      var _configureWeb = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(web3Provider, chainNetworkId) {
        var requiresAccount,
            web3Instance,
            networkId,
            accounts,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                requiresAccount = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : true;
                // Initializing web3 with a HttpProvider wrapper for multiple providers
                // ref: https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3/types/index.d.ts#L31.
                web3Instance = new web3(new MultiProvider(web3Provider));
                _context3.prev = 2;
                _context3.next = 5;
                return web3Instance.eth.net.getId();

              case 5:
                networkId = _context3.sent;

                if (!(chainNetworkId && networkId.toString() !== chainNetworkId)) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", false);

              case 8:
                if (!requiresAccount) {
                  _context3.next = 14;
                  break;
                }

                _context3.next = 11;
                return web3Instance.eth.getAccounts();

              case 11:
                accounts = _context3.sent;

                if (!(!accounts || accounts.length < 1)) {
                  _context3.next = 14;
                  break;
                }

                return _context3.abrupt("return", false);

              case 14:
                _context3.next = 19;
                break;

              case 16:
                _context3.prev = 16;
                _context3.t0 = _context3["catch"](2);
                return _context3.abrupt("return", false);

              case 19:
                return _context3.abrupt("return", web3Instance);

              case 20:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[2, 16]]);
      }));

      function configureWeb3(_x3, _x4) {
        return _configureWeb.apply(this, arguments);
      }

      return configureWeb3;
    }()
  }, {
    key: "zeroAddress",
    get: function get() {
      return ZeroAddress;
    }
  }, {
    key: "isZeroAddress",
    value: function isZeroAddress(address) {
      return address === Utils.zeroAddress;
    }
  }, {
    key: "makeUuid",
    value: function makeUuid() {
      return uuid();
    }
    /**
     * Decodes a string id into an int. Returns null if an invalid ID.
     */

  }, {
    key: "decodeHashId",
    value: function decodeHashId(id) {
      try {
        var ids = hashids.decode(id);
        if (!ids.length) return null;
        var num = Number(ids[0]);
        if (isNaN(num)) return null;
        return num;
      } catch (e) {
        console.error("Failed to decode ".concat(id), e);
        return null;
      }
    }
    /**
     * Encodes an int to a string based hashid
     */

  }, {
    key: "encodeHashId",
    value: function encodeHashId(id) {
      try {
        if (id === null) return null;
        var encodedId = hashids.encode(id);
        return encodedId;
      } catch (e) {
        console.error("Failed to encode ".concat(id), e);
        return null;
      }
    }
    /**
     * If `promise` responds before `timeoutMs`,
     * this function returns its response; else rejects with `timeoutMessage`
     */

  }, {
    key: "racePromiseWithTimeout",
    value: function () {
      var _racePromiseWithTimeout = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(promise, timeoutMs, timeoutMessage) {
        var timeoutPromise;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // eslint-disable-next-line promise/param-names
                timeoutPromise = new Promise(function (_promise, reject) {
                  setTimeout(function () {
                    return reject(new Error(timeoutMessage));
                  }, timeoutMs);
                });
                _context4.next = 3;
                return Promise.race([promise, timeoutPromise]);

              case 3:
                return _context4.abrupt("return", _context4.sent);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function racePromiseWithTimeout(_x5, _x6, _x7) {
        return _racePromiseWithTimeout.apply(this, arguments);
      }

      return racePromiseWithTimeout;
    }()
  }]);

  return Utils;
}();
Utils$b.fileHasher = fileHasher;

var utils$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Utils: Utils$b
});

/**
 * Recover the public wallet address given the response contains the signature and timestamp
 * @param {object} response entire service provider response (not axios)
 */

function recoverWallet(web3, response) {
  var recoveredDelegateWallet = null;
  var dataForRecovery = JSON.parse(JSON.stringify(response));
  delete dataForRecovery.signature;
  var dataForRecoveryStr = JSON.stringify(sortObjectKeys(dataForRecovery));

  try {
    var hashedData = web3.utils.keccak256(dataForRecoveryStr);
    recoveredDelegateWallet = web3.eth.accounts.recover(hashedData, response.signature);
    assert__default["default"].strictEqual(response.signer, recoveredDelegateWallet);
  } catch (e) {
    console.error("Issue with recovering public wallet address: ".concat(e));
  }

  return recoveredDelegateWallet;
}
/**
 * Recursively sorts object keys alphabetically
 */

function sortObjectKeys(x) {
  if (_typeof(x) !== 'object' || !x) {
    return x;
  }

  if (Array.isArray(x)) {
    return x.map(sortObjectKeys);
  }

  return Object.keys(x).sort().reduce(function (o, k) {
    return _objectSpread2(_objectSpread2({}, o), {}, _defineProperty({}, k, sortObjectKeys(x[k])));
  }, {});
}

var VERIFY_ENDPOINT = 'https://www.google.com/recaptcha/api/siteverify';
var IS_BROWSER = typeof window !== 'undefined' && window !== null;
var Captcha = /*#__PURE__*/function () {
  function Captcha(_ref) {
    var siteKey = _ref.siteKey,
        serviceKey = _ref.serviceKey;

    _classCallCheck(this, Captcha);

    this.siteKey = siteKey;
    this.serviceKey = serviceKey;
    this.generate = this.generate.bind(this);
    this.verify = this.verify.bind(this);
  }
  /**
   * Intended to be called by clients. Will generate a token used to calculate recaptcha score.
   * @param action name for this "action" for grouping
   */


  _createClass(Captcha, [{
    key: "generate",
    value: function () {
      var _generate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(action) {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.siteKey) {
                  _context.next = 2;
                  break;
                }

                throw new Error('No siteKey provided');

              case 2:
                if (IS_BROWSER) {
                  _context.next = 4;
                  break;
                }

                throw new Error('Expected a browser/client context');

              case 4:
                if (window.grecaptcha) {
                  _context.next = 6;
                  break;
                }

                throw new Error('No captcha found, did you forget to import it?');

              case 6:
                _context.next = 8;
                return new Promise(function (resolve) {
                  window.grecaptcha.ready(function () {
                    window.grecaptcha.execute(_this.siteKey, {
                      action: action
                    }).then(function (token) {
                      resolve(token);
                    });
                  });
                });

              case 8:
                return _context.abrupt("return", _context.sent);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function generate(_x) {
        return _generate.apply(this, arguments);
      }

      return generate;
    }()
    /**
     * Intended to be called by services. According to recaptcha v3 docs:
     * A score of 1.0 is very likely a good interaction, 0.0 is very likely a bot
     * @param token
     * @param minScore score must be >= minScore to be ok
     * @returns
     *    {boolean | null} ok - whether score > minScore (false if something went wrong)
     *    {number | null} score - the raw score [0, 1] (or null if a score was not computed)
     */

  }, {
    key: "verify",
    value: function () {
      var _verify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(token) {
        var minScore,
            score,
            ok,
            hostname,
            formData,
            resp,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                minScore = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0.5;

                if (this.serviceKey) {
                  _context2.next = 3;
                  break;
                }

                throw new Error('No serviceKey provided');

              case 3:
                formData = new FormData__default["default"]();
                formData.append('response', token);
                formData.append('secret', this.serviceKey);
                _context2.prev = 6;
                _context2.next = 9;
                return axios__default["default"].post(VERIFY_ENDPOINT, formData, {
                  headers: formData.getHeaders(),
                  adapter: IS_BROWSER ? require('axios/lib/adapters/xhr') : require('axios/lib/adapters/http')
                });

              case 9:
                resp = _context2.sent;
                score = resp.data.score;
                ok = score >= minScore;
                hostname = resp.data.hostname;
                _context2.next = 21;
                break;

              case 15:
                _context2.prev = 15;
                _context2.t0 = _context2["catch"](6);
                console.error('Error with verifying captcha request', _context2.t0);
                score = null;
                ok = true;
                hostname = null;

              case 21:
                return _context2.abrupt("return", {
                  score: score,
                  ok: ok,
                  hostname: hostname
                });

              case 22:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 15]]);
      }));

      function verify(_x2) {
        return _verify.apply(this, arguments);
      }

      return verify;
    }()
  }]);

  return Captcha;
}();

// Default multiplier on top of gas estimate to be extra safe that txns
// will go through
var GAS_LIMIT_MULTIPLIER = 1.05;
/**
 * Returns estimated gas use for a txn for a contract method
 * @param options
 * @param options.method the contract method
 * @param options.from address the method will be sent from (required if the contract requires a certain sender, e.g. guardian)
 * @param options.gasLimitMaximum the maximum amount of gas we will allow
 * (likely will return a number much smaller than this)
 * @param options.multipler the multiplier to safe-guard against estimates that are too low
 */

var estimateGas = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
    var method, from, gasLimitMaximum, _ref$multiplier, multiplier, estimatedGas, safeEstimatedGas;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            method = _ref.method, from = _ref.from, gasLimitMaximum = _ref.gasLimitMaximum, _ref$multiplier = _ref.multiplier, multiplier = _ref$multiplier === void 0 ? GAS_LIMIT_MULTIPLIER : _ref$multiplier;
            _context.prev = 1;
            _context.next = 4;
            return method.estimateGas({
              from: from,
              gas: gasLimitMaximum
            });

          case 4:
            estimatedGas = _context.sent;
            // Rounding is necessary here as fractional gas limits will break
            safeEstimatedGas = Math.ceil(estimatedGas * multiplier);
            console.info("Estimated gas limit ".concat(safeEstimatedGas, " for method ").concat(method._method.name));
            return _context.abrupt("return", safeEstimatedGas);

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](1);
            console.error("Unable to estimate gas for transaction ".concat(method._method.name, ", using ").concat(gasLimitMaximum));
            return _context.abrupt("return", gasLimitMaximum);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 10]]);
  }));

  return function estimateGas(_x) {
    return _ref2.apply(this, arguments);
  };
}();

function promiseFight(_x, _x2) {
  return _promiseFight.apply(this, arguments);
}

function _promiseFight() {
  _promiseFight = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(promises, captureErrored) {
    var errored;
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            errored = [];
            _context6.next = 3;
            return Promise.all(promises.map( /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(p) {
                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return p.then( /*#__PURE__*/function () {
                          var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(val) {
                            return regeneratorRuntime.wrap(function _callee$(_context) {
                              while (1) {
                                switch (_context.prev = _context.next) {
                                  case 0:
                                    _context.next = 2;
                                    return Promise.reject(val);

                                  case 2:
                                    return _context.abrupt("return", _context.sent);

                                  case 3:
                                  case "end":
                                    return _context.stop();
                                }
                              }
                            }, _callee);
                          }));

                          return function (_x4) {
                            return _ref2.apply(this, arguments);
                          };
                        }(), /*#__PURE__*/function () {
                          var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(err) {
                            return regeneratorRuntime.wrap(function _callee2$(_context2) {
                              while (1) {
                                switch (_context2.prev = _context2.next) {
                                  case 0:
                                    if (captureErrored) errored.push(err);
                                    _context2.next = 3;
                                    return Promise.resolve(err);

                                  case 3:
                                    return _context2.abrupt("return", _context2.sent);

                                  case 4:
                                  case "end":
                                    return _context2.stop();
                                }
                              }
                            }, _callee2);
                          }));

                          return function (_x5) {
                            return _ref3.apply(this, arguments);
                          };
                        }());

                      case 2:
                        return _context3.abrupt("return", _context3.sent);

                      case 3:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x3) {
                return _ref.apply(this, arguments);
              };
            }())).then( /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(errors) {
                return regeneratorRuntime.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return Promise.reject(errors);

                      case 2:
                        return _context4.abrupt("return", _context4.sent);

                      case 3:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));

              return function (_x6) {
                return _ref4.apply(this, arguments);
              };
            }(), /*#__PURE__*/function () {
              var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(val) {
                return regeneratorRuntime.wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        if (!captureErrored) {
                          _context5.next = 6;
                          break;
                        }

                        _context5.next = 3;
                        return Promise.resolve({
                          val: val,
                          errored: errored
                        });

                      case 3:
                        return _context5.abrupt("return", _context5.sent);

                      case 6:
                        _context5.next = 8;
                        return Promise.resolve(val);

                      case 8:
                        return _context5.abrupt("return", _context5.sent);

                      case 9:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5);
              }));

              return function (_x7) {
                return _ref5.apply(this, arguments);
              };
            }());

          case 3:
            return _context6.abrupt("return", _context6.sent);

          case 4:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _promiseFight.apply(this, arguments);
}

var sign$2 = function sign(digest, privateKey) {
  var buffer = require$$1$1u.toBuffer(digest);
  var signature = require$$1$1u.ecsign(buffer, privateKey);
  return signature;
}; // lazyload permitTypehash to avoid a web3 race

var _permitTypehash = null;

var getPermitTypehash = function getPermitTypehash() {
  if (!_permitTypehash) {
    _permitTypehash = Utils$b.keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');
  }

  return _permitTypehash;
};

var _transferTokensTypehash = null;

var getTransferTokensTypeHash = function getTransferTokensTypeHash() {
  if (!_transferTokensTypehash) {
    _transferTokensTypehash = Utils$b.keccak256('TransferTokens(address from,uint256 amount,uint16 recipientChain,bytes32 recipient,uint256 artbiterFee,uint32 nonce,uint256 deadline)');
  }

  return _transferTokensTypehash;
}; // Returns the EIP712 hash which should be signed by the user
// in order to make a call to `permit`


function getPermitDigest$1(web3, name, address, chainId, approve, nonce, deadline) {
  var DOMAIN_SEPARATOR = getDomainSeparator(web3, name, address, chainId);
  var innerEncoded = web3.eth.abi.encodeParameters(['bytes32', 'address', 'address', 'uint256', 'uint256', 'uint256'], [getPermitTypehash(), approve.owner, approve.spender, approve.value, nonce, deadline]);
  var encoded = solidity.pack(['bytes1', 'bytes1', 'bytes32', 'bytes32'], ['0x19', '0x01', DOMAIN_SEPARATOR, Utils$b.keccak256(innerEncoded)]);
  return Utils$b.keccak256(encoded);
} // Returns the EIP712 hash which should be signed by the user
// in order to make a call to `transferTokens`

function getTransferTokensDigest$1(web3, name, address, chainId, transferTokens, nonce, deadline) {
  var DOMAIN_SEPARATOR = getDomainSeparator(web3, name, address, chainId);
  var innerEncoded = web3.eth.abi.encodeParameters(['bytes32', 'address', 'uint256', 'uint16', 'bytes32', 'uint256', 'uint32', 'uint256'], [getTransferTokensTypeHash(), transferTokens.from, transferTokens.amount, transferTokens.recipientChain, transferTokens.recipient, transferTokens.arbiterFee, nonce, deadline]);
  var encoded = solidity.pack(['bytes1', 'bytes1', 'bytes32', 'bytes32'], ['0x19', '0x01', DOMAIN_SEPARATOR, Utils$b.keccak256(innerEncoded)]);
  return Utils$b.keccak256(encoded);
} // Gets the EIP712 domain separator

function getDomainSeparator(web3, name, contractAddress, chainId) {
  var encoded = web3.eth.abi.encodeParameters(['bytes32', 'bytes32', 'bytes32', 'uint256', 'address'], [Utils$b.keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'), Utils$b.keccak256(name), Utils$b.keccak256('1'), chainId, contractAddress]);
  return Utils$b.keccak256(encoded);
}

var signatures = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sign: sign$2,
  getPermitDigest: getPermitDigest$1,
  getTransferTokensDigest: getTransferTokensDigest$1
});

/**
 * Fetches a url and times how long it took the request to complete.
 */

function timeRequest(_x, _x2) {
  return _timeRequest.apply(this, arguments);
}
/**
 * Custom sort for `serviceTimings`, the response from `timeRequest()` function above
 */


function _timeRequest() {
  _timeRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(request, timeout) {
    var startTime, config, response, millis;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // This is non-perfect because of the js event loop, but enough
            // of a proximation. Don't use for mission-critical timing.
            startTime = new Date().getTime();
            config = {};

            if (timeout !== null && timeout !== undefined) {
              config.timeout = timeout;
            }

            _context.prev = 3;
            _context.next = 6;
            return axios__default["default"].get(request.url, config);

          case 6:
            response = _context.sent;
            _context.next = 13;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](3);
            console.debug("Error with request for ".concat(request.url, ": ").concat(_context.t0));
            return _context.abrupt("return", {
              request: request,
              response: null,
              millis: null
            });

          case 13:
            millis = new Date().getTime() - startTime;
            return _context.abrupt("return", {
              request: request,
              response: response,
              millis: millis
            });

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 9]]);
  }));
  return _timeRequest.apply(this, arguments);
}

function sortServiceTimings(_ref) {
  var serviceTimings = _ref.serviceTimings,
      sortByVersion = _ref.sortByVersion,
      _ref$currentVersion = _ref.currentVersion,
      currentVersion = _ref$currentVersion === void 0 ? null : _ref$currentVersion,
      _ref$equivalencyDelta = _ref.equivalencyDelta,
      equivalencyDelta = _ref$equivalencyDelta === void 0 ? null : _ref$equivalencyDelta;
  return serviceTimings.sort(function (a, b) {
    var _a$millis, _b$millis;

    // If health check failed, send to back of timings
    if (a.response == null) return 1;
    if (b.response == null) return -1;
    var aVersion = a.response.data.data.version;
    var bVersion = b.response.data.data.version;

    if (sortByVersion) {
      // Always sort by version desc
      if (semver__default["default"].gt(aVersion, bVersion)) return -1;
      if (semver__default["default"].lt(aVersion, bVersion)) return 1;
    } else if (!sortByVersion && currentVersion) {
      // Only sort by version if behind current on-chain version
      if (semver__default["default"].gt(currentVersion, aVersion) && semver__default["default"].gt(currentVersion, bVersion)) {
        if (semver__default["default"].gt(aVersion, bVersion)) return -1;
        if (semver__default["default"].lt(aVersion, bVersion)) return 1;
      } else if (semver__default["default"].gt(currentVersion, aVersion)) {
        return 1;
      } else if (semver__default["default"].gt(currentVersion, bVersion)) {
        return -1;
      }
    } // If same version and transcode queue load, do a tie breaker on the response time
    // If the requests are near eachother (delta < equivalencyDelta), pick randomly


    var delta = ((_a$millis = a.millis) !== null && _a$millis !== void 0 ? _a$millis : 0) - ((_b$millis = b.millis) !== null && _b$millis !== void 0 ? _b$millis : 0);

    if (equivalencyDelta !== null && delta < equivalencyDelta) {
      return 1 - 2 * Math.random(); // [-1, 1]
    }

    return delta;
  });
}
/**
 * Fetches multiple urls and times each request and returns the results sorted
 * first by version and then by lowest-latency.
 */


function timeRequests$1(_x3) {
  return _timeRequests.apply(this, arguments);
}
/**
 * Races multiple requests
 * @param urls
 * @param callback invoked with the first successful url
 * @param axiosConfig extra axios config for each request
 * @param timeout timeout for any requests to be considered bad
 * @param timeBetweenRequests time between requests being dispatched to free up client network interface
 */


function _timeRequests() {
  _timeRequests = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref2) {
    var requests, _ref2$sortByVersion, sortByVersion, _ref2$currentVersion, currentVersion, _ref2$filterNonRespon, filterNonResponsive, _ref2$timeout, timeout, _ref2$equivalencyDelt, equivalencyDelta, serviceTimings;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            requests = _ref2.requests, _ref2$sortByVersion = _ref2.sortByVersion, sortByVersion = _ref2$sortByVersion === void 0 ? false : _ref2$sortByVersion, _ref2$currentVersion = _ref2.currentVersion, currentVersion = _ref2$currentVersion === void 0 ? null : _ref2$currentVersion, _ref2$filterNonRespon = _ref2.filterNonResponsive, filterNonResponsive = _ref2$filterNonRespon === void 0 ? false : _ref2$filterNonRespon, _ref2$timeout = _ref2.timeout, timeout = _ref2$timeout === void 0 ? null : _ref2$timeout, _ref2$equivalencyDelt = _ref2.equivalencyDelta, equivalencyDelta = _ref2$equivalencyDelt === void 0 ? null : _ref2$equivalencyDelt;
            _context3.next = 3;
            return Promise.all(requests.map( /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(request) {
                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return timeRequest(request, timeout);

                      case 2:
                        return _context2.abrupt("return", _context2.sent);

                      case 3:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));

              return function (_x8) {
                return _ref4.apply(this, arguments);
              };
            }()));

          case 3:
            serviceTimings = _context3.sent;

            if (filterNonResponsive) {
              serviceTimings = serviceTimings.filter(function (timing) {
                return timing.response !== null;
              });
            }

            return _context3.abrupt("return", sortServiceTimings({
              serviceTimings: serviceTimings,
              currentVersion: currentVersion,
              sortByVersion: sortByVersion,
              equivalencyDelta: equivalencyDelta
            }));

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _timeRequests.apply(this, arguments);
}

function raceRequests$1(_x4, _x5, _x6) {
  return _raceRequests.apply(this, arguments);
}
/**
 * Gets the response for many requests with a timeout to each
 */


function _raceRequests() {
  _raceRequests = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(urls, callback, axiosConfig) {
    var timeout,
        timeBetweenRequests,
        validationCheck,
        CancelToken,
        sources,
        hasFinished,
        requests,
        response,
        errored,
        _yield$promiseFight,
        val,
        e,
        _args5 = arguments;

    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            timeout = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : 3000;
            timeBetweenRequests = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : 100;
            validationCheck = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : function (_) {
              return true;
            };
            CancelToken = axios__default["default"].CancelToken;
            sources = [];
            hasFinished = false;
            requests = urls.map( /*#__PURE__*/function () {
              var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(url, i) {
                var source;
                return regeneratorRuntime.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        source = CancelToken.source();
                        sources.push(source); // Slightly offset requests by their order, so:
                        // 1. We try creator node gateways first
                        // 2. We give requests the opportunity to get canceled if other's are very fast

                        _context4.next = 4;
                        return Utils$b.wait(timeBetweenRequests * i);

                      case 4:
                        if (!hasFinished) {
                          _context4.next = 6;
                          break;
                        }

                        return _context4.abrupt("return");

                      case 6:
                        _context4.next = 8;
                        return new Promise(function (resolve, reject) {
                          axios__default["default"](_objectSpread2({
                            method: 'get',
                            url: url,
                            cancelToken: source.token
                          }, axiosConfig)).then(function (response) {
                            var isValid = validationCheck(response);

                            if (isValid) {
                              hasFinished = true;
                              resolve({
                                blob: response,
                                url: url
                              });
                            } else {
                              // Invalid because of validity check
                              reject(response);
                            }
                          })["catch"](function (thrown) {
                            reject(thrown); // no-op.
                            // If debugging `axios.isCancel(thrown)`
                            // can be used to check if the throw was from a cancel.
                          });
                        });

                      case 8:
                        return _context4.abrupt("return", _context4.sent);

                      case 9:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));

              return function (_x9, _x10) {
                return _ref5.apply(this, arguments);
              };
            }());

            if (timeout !== null) {
              requests.push(Utils$b.wait(timeout));
            }

            _context5.prev = 8;
            _context5.next = 11;
            return promiseFight(requests, true);

          case 11:
            _yield$promiseFight = _context5.sent;
            val = _yield$promiseFight.val;
            e = _yield$promiseFight.errored;
            response = val;
            errored = e;
            _context5.next = 22;
            break;

          case 18:
            _context5.prev = 18;
            _context5.t0 = _context5["catch"](8);
            response = null;
            errored = _context5.t0;

          case 22:
            sources.forEach(function (source) {
              source.cancel('Fetch already succeeded');
            });

            if (!(response && 'url' in response && 'blob' in response)) {
              _context5.next = 26;
              break;
            }

            callback(response.url);
            return _context5.abrupt("return", {
              response: response.blob,
              errored: errored
            });

          case 26:
            return _context5.abrupt("return", {
              response: null,
              errored: errored
            });

          case 27:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[8, 18]]);
  }));
  return _raceRequests.apply(this, arguments);
}

function allRequests(_x7) {
  return _allRequests.apply(this, arguments);
}

function _allRequests() {
  _allRequests = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(_ref3) {
    var urlMap, timeout, validationCheck, urls, requests, responses;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            urlMap = _ref3.urlMap, timeout = _ref3.timeout, validationCheck = _ref3.validationCheck;
            urls = Object.keys(urlMap);
            requests = urls.map( /*#__PURE__*/function () {
              var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(url) {
                return regeneratorRuntime.wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.next = 2;
                        return new Promise(function (resolve) {
                          axios__default["default"]({
                            method: 'get',
                            timeout: timeout,
                            url: url
                          }).then(function (response) {
                            var isValid = validationCheck(response);

                            if (isValid) {
                              resolve(urlMap[url]);
                            } else {
                              resolve(null);
                            }
                          })["catch"](function () {
                            resolve(null);
                          });
                        });

                      case 2:
                        return _context6.abrupt("return", _context6.sent);

                      case 3:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6);
              }));

              return function (_x11) {
                return _ref6.apply(this, arguments);
              };
            }());
            _context7.next = 5;
            return Promise.all(requests);

          case 5:
            responses = _context7.sent.filter(Boolean);
            return _context7.abrupt("return", responses);

          case 7:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _allRequests.apply(this, arguments);
}

var network = /*#__PURE__*/Object.freeze({
  __proto__: null,
  timeRequest: timeRequest,
  timeRequests: timeRequests$1,
  raceRequests: raceRequests$1,
  allRequests: allRequests,
  sortServiceTimings: sortServiceTimings
});

var utils$1 = /*#__PURE__*/_mergeNamespaces({
  __proto__: null,
  Utils: Utils$b,
  recoverWallet: recoverWallet,
  sortObjectKeys: sortObjectKeys,
  Captcha: Captcha,
  estimateGas: estimateGas,
  MultiProvider: MultiProvider,
  promiseFight: promiseFight,
  sign: sign$2,
  getPermitDigest: getPermitDigest$1,
  getTransferTokensDigest: getTransferTokensDigest$1,
  uuid: uuid,
  timeRequest: timeRequest,
  timeRequests: timeRequests$1,
  raceRequests: raceRequests$1,
  allRequests: allRequests,
  sortServiceTimings: sortServiceTimings
}, [importContractABI]);

var MIN_GAS_PRICE = Math.pow(10, 9); // 1 GWei, ETH minimum allowed gas price

var HIGH_GAS_PRICE = 250 * MIN_GAS_PRICE; // 250 GWei

var DEFAULT_GAS_PRICE = 100 * MIN_GAS_PRICE; // 100 Gwei is a reasonably average gas price

var MAX_GAS_LIMIT = 5000000; // We've seen prod tx's take up to 4M. Set to the highest we've observed + a buffer

/** Singleton state-manager for Audius Eth Contracts */

var EthWeb3Manager = /*#__PURE__*/function () {
  function EthWeb3Manager(web3Config, identityService, hedgehog) {
    _classCallCheck(this, EthWeb3Manager);

    if (!web3Config) throw new Error('web3Config object not passed in');
    if (!web3Config.providers) throw new Error('missing web3Config property: providers'); // MultiProvider implements a web3 provider with fallback.

    var provider = new MultiProvider(web3Config.providers);
    this.web3Config = web3Config;
    this.web3 = new web3(provider);
    this.identityService = identityService;
    this.hedgehog = hedgehog;

    if (this.web3Config.ownerWallet) {
      this.ownerWallet = this.web3Config.ownerWallet;
    } else {
      var storedWallet = this.hedgehog.getWallet();

      if (storedWallet) {
        this.ownerWallet = storedWallet;
      }
    }
  }

  _createClass(EthWeb3Manager, [{
    key: "getWeb3",
    value: function getWeb3() {
      return this.web3;
    }
  }, {
    key: "getWalletAddress",
    value: function getWalletAddress() {
      if (this.ownerWallet) {
        // @ts-expect-error TODO extend ethereum-js-wallet to include toLowerCase
        return this.ownerWallet.toLowerCase();
      }

      throw new Error('Owner wallet not set');
    }
    /**
     * Signs provided string data (should be timestamped).
     */

  }, {
    key: "sign",
    value: function () {
      var _sign = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.web3.eth.personal.sign(this.web3.utils.fromUtf8(data), this.getWalletAddress());

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function sign(_x) {
        return _sign.apply(this, arguments);
      }

      return sign;
    }()
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(contractMethod) {
        var _this = this;

        var contractAddress,
            privateKey,
            txRetries,
            txGasLimit,
            gasLimit,
            _gasPrice,
            gasPriceStr,
            privateKeyBuffer,
            walletAddress,
            txCount,
            encodedABI,
            txParams,
            tx,
            signedTx,
            response,
            gasPrice,
            _args3 = arguments;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                contractAddress = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;
                privateKey = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : null;
                txRetries = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 5;
                txGasLimit = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : null;

                if (!(txGasLimit !== null && txGasLimit !== void 0)) {
                  _context3.next = 8;
                  break;
                }

                _context3.t0 = txGasLimit;
                _context3.next = 11;
                break;

              case 8:
                _context3.next = 10;
                return estimateGas({
                  method: contractMethod,
                  from: this.ownerWallet,
                  gasLimitMaximum: MAX_GAS_LIMIT
                });

              case 10:
                _context3.t0 = _context3.sent;

              case 11:
                gasLimit = _context3.t0;

                if (!(contractAddress && privateKey)) {
                  _context3.next = 34;
                  break;
                }

                _context3.t1 = parseInt;
                _context3.next = 16;
                return this.web3.eth.getGasPrice();

              case 16:
                _context3.t2 = _context3.sent;
                _gasPrice = (0, _context3.t1)(_context3.t2);

                if (isNaN(_gasPrice) || _gasPrice > HIGH_GAS_PRICE) {
                  _gasPrice = DEFAULT_GAS_PRICE;
                } else if (_gasPrice === 0) {
                  // If the gas is zero, the txn will likely never get mined.
                  _gasPrice = MIN_GAS_PRICE;
                }

                gasPriceStr = '0x' + _gasPrice.toString(16);
                privateKeyBuffer = Buffer.from(privateKey, 'hex');
                walletAddress = this.getWalletAddress();
                _context3.next = 24;
                return this.web3.eth.getTransactionCount(walletAddress);

              case 24:
                txCount = _context3.sent;
                encodedABI = contractMethod.encodeABI();
                txParams = {
                  nonce: this.web3.utils.toHex(txCount),
                  gasPrice: gasPriceStr,
                  gasLimit: gasLimit,
                  data: encodedABI,
                  to: contractAddress,
                  value: '0x00'
                };
                tx = new ethereumjsTx.Transaction(txParams);
                tx.sign(privateKeyBuffer);
                signedTx = '0x' + tx.serialize().toString('hex'); // Send the tx with retries

                _context3.next = 32;
                return retry__default["default"]( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.next = 2;
                          return _this.web3.eth.sendSignedTransaction(signedTx);

                        case 2:
                          return _context2.abrupt("return", _context2.sent);

                        case 3:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })), {
                  // Retry function 5x by default
                  // 1st retry delay = 500ms, 2nd = 1500ms, 3rd...nth retry = 4000 ms (capped)
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: txRetries,
                  onRetry: function onRetry(err) {
                    if (err) {
                      console.log( // eslint-disable-next-line @typescript-eslint/no-base-to-string -- TODO
                      "libs ethWeb3Manager transaction send retry error : ".concat(err));
                    }
                  }
                });

              case 32:
                response = _context3.sent;
                return _context3.abrupt("return", response);

              case 34:
                _context3.t3 = parseInt;
                _context3.next = 37;
                return this.web3.eth.getGasPrice();

              case 37:
                _context3.t4 = _context3.sent;
                gasPrice = (0, _context3.t3)(_context3.t4);
                _context3.next = 41;
                return contractMethod.send({
                  from: this.ownerWallet,
                  gas: gasLimit,
                  gasPrice: gasPrice
                });

              case 41:
                return _context3.abrupt("return", _context3.sent);

              case 42:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function sendTransaction(_x2) {
        return _sendTransaction.apply(this, arguments);
      }

      return sendTransaction;
    }()
    /**
     * Relays an eth transaction via the identity service with retries
     * The relay pays for the transaction fee on behalf of the user
     * The gas Limit is estimated if not provided
     */

  }, {
    key: "relayTransaction",
    value: function () {
      var _relayTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(contractMethod, contractAddress, ownerWallet, relayerWallet) {
        var _this2 = this;

        var txRetries,
            txGasLimit,
            encodedABI,
            gasLimit,
            response,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                txRetries = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : 5;
                txGasLimit = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : null;
                encodedABI = contractMethod.encodeABI();

                if (!(txGasLimit !== null && txGasLimit !== void 0)) {
                  _context5.next = 7;
                  break;
                }

                _context5.t0 = txGasLimit;
                _context5.next = 10;
                break;

              case 7:
                _context5.next = 9;
                return estimateGas({
                  from: relayerWallet,
                  method: contractMethod,
                  gasLimitMaximum: MAX_GAS_LIMIT
                });

              case 9:
                _context5.t0 = _context5.sent;

              case 10:
                gasLimit = _context5.t0;
                _context5.next = 13;
                return retry__default["default"]( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(bail) {
                    var attempt, _error$response, error;

                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.prev = 0;
                            _context4.next = 3;
                            return _this2.identityService.ethRelay(contractAddress, ownerWallet, encodedABI, gasLimit.toString());

                          case 3:
                            attempt = _context4.sent;
                            return _context4.abrupt("return", attempt);

                          case 7:
                            _context4.prev = 7;
                            _context4.t0 = _context4["catch"](0);
                            error = _context4.t0;

                            if (!(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 429)) {
                              _context4.next = 13;
                              break;
                            }

                            // Don't retry in the case we are getting rate limited
                            bail(new Error('Please wait before trying again'));
                            return _context4.abrupt("return");

                          case 13:
                            throw error;

                          case 14:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4, null, [[0, 7]]);
                  }));

                  return function (_x7) {
                    return _ref2.apply(this, arguments);
                  };
                }(), {
                  // Retry function 5x by default
                  // 1st retry delay = 500ms, 2nd = 1500ms, 3rd...nth retry = 4000 ms (capped)
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: txRetries,
                  onRetry: function onRetry(err) {
                    if (err) {
                      console.log( // eslint-disable-next-line @typescript-eslint/no-base-to-string -- TODO
                      "libs ethWeb3Manager transaction relay retry error : ".concat(err));
                    }
                  }
                });

              case 13:
                response = _context5.sent;
                return _context5.abrupt("return", response === null || response === void 0 ? void 0 : response.resp);

              case 15:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function relayTransaction(_x3, _x4, _x5, _x6) {
        return _relayTransaction.apply(this, arguments);
      }

      return relayTransaction;
    }()
  }, {
    key: "getRelayMethodParams",
    value: function () {
      var _getRelayMethodParams = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(contractAddress, contractMethod, relayerWallet) {
        var encodedABI, gasLimit;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                encodedABI = contractMethod.encodeABI();
                _context6.next = 3;
                return estimateGas({
                  from: relayerWallet,
                  method: contractMethod,
                  gasLimitMaximum: HIGH_GAS_PRICE
                });

              case 3:
                gasLimit = _context6.sent;
                return _context6.abrupt("return", {
                  contractAddress: contractAddress,
                  encodedABI: encodedABI,
                  gasLimit: gasLimit
                });

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function getRelayMethodParams(_x8, _x9, _x10) {
        return _getRelayMethodParams.apply(this, arguments);
      }

      return getRelayMethodParams;
    }()
  }]);

  return EthWeb3Manager;
}();

var ethWeb3Manager = /*#__PURE__*/Object.freeze({
  __proto__: null,
  EthWeb3Manager: EthWeb3Manager
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(ethWeb3Manager);

/**
 * Converts a BN to a Uint8Array of length 8, in little endian notation.
 * Useful for when Rust wants a u64 (8 * 8) represented as a byte array.
 * Ex: https://github.com/AudiusProject/audius-protocol/blob/master/solana-programs/reward-manager/program/src/processor.rs#L389
 */
var padBNToUint8Array$1 = function padBNToUint8Array(bn) {
  return bn.toArray('le', 8);
};

var padBNToUint8Array$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  padBNToUint8Array: padBNToUint8Array$1
});

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(padBNToUint8Array$2);

var bn = createModule("/$$rollup_base$$/node_modules/bn.js/lib");

(function (module) {
  (function (module, exports) {

    function assert(val, msg) {
      if (!val) throw new Error(msg || 'Assertion failed');
    } // Could use `inherits` module, but don't want to move from single file
    // architecture yet.


    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function TempCtor() {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    } // BN


    function BN(number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }

      this.negative = 0;
      this.words = null;
      this.length = 0; // Reduction context

      this.red = null;

      if (number !== null) {
        if (base === 'le' || base === 'be') {
          endian = base;
          base = 10;
        }

        this._init(number || 0, base || 10, endian || 'be');
      }
    }

    if (_typeof(module) === 'object') {
      module.exports = BN;
    } else {
      exports.BN = BN;
    }

    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;

    try {
      if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
        Buffer = window.Buffer;
      } else {
        Buffer = require('buffer').Buffer;
      }
    } catch (e) {}

    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }

      return num !== null && _typeof(num) === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };

    BN.max = function max(left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };

    BN.min = function min(left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };

    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === 'number') {
        return this._initNumber(number, base, endian);
      }

      if (_typeof(number) === 'object') {
        return this._initArray(number, base, endian);
      }

      if (base === 'hex') {
        base = 16;
      }

      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, '');
      var start = 0;

      if (number[0] === '-') {
        start++;
        this.negative = 1;
      }

      if (start < number.length) {
        if (base === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base, start);

          if (endian === 'le') {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };

    BN.prototype._initNumber = function _initNumber(number, base, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }

      if (number < 0x4000000) {
        this.words = [number & 0x3ffffff];
        this.length = 1;
      } else if (number < 0x10000000000000) {
        this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
        this.length = 2;
      } else {
        assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)

        this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
        this.length = 3;
      }

      if (endian !== 'le') return; // Reverse the bytes

      this._initArray(this.toArray(), base, endian);
    };

    BN.prototype._initArray = function _initArray(number, base, endian) {
      // Perhaps a Uint8Array
      assert(typeof number.length === 'number');

      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }

      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);

      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }

      var j, w;
      var off = 0;

      if (endian === 'be') {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j] |= w << off & 0x3ffffff;
          this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === 'le') {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j] |= w << off & 0x3ffffff;
          this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }

      return this.strip();
    };

    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index); // 'A' - 'F'

      if (c >= 65 && c <= 70) {
        return c - 55; // 'a' - 'f'
      } else if (c >= 97 && c <= 102) {
        return c - 87; // '0' - '9'
      } else {
        return c - 48 & 0xf;
      }
    }

    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);

      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }

      return r;
    }

    BN.prototype._parseHex = function _parseHex(number, start, endian) {
      // Create possibly bigger array to ensure that it fits the number
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);

      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      } // 24-bits chunks


      var off = 0;
      var j = 0;
      var w;

      if (endian === 'be') {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 0x3ffffff;

          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;

        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 0x3ffffff;

          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }

      this.strip();
    };

    function parseBase(str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);

      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul; // 'a'

        if (c >= 49) {
          r += c - 49 + 0xa; // 'A'
        } else if (c >= 17) {
          r += c - 17 + 0xa; // '0' - '9'
        } else {
          r += c;
        }
      }

      return r;
    }

    BN.prototype._parseBase = function _parseBase(number, base, start) {
      // Initialize as zero
      this.words = [0];
      this.length = 1; // Find length of limb in base

      for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
        limbLen++;
      }

      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;

      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);

        if (this.words[0] + word < 0x4000000) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }

      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);

        for (i = 0; i < mod; i++) {
          pow *= base;
        }

        this.imuln(pow);

        if (this.words[0] + word < 0x4000000) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }

      this.strip();
    };

    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);

      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }

      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };

    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };

    BN.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }

      return this;
    }; // Remove leading `0` from `this`


    BN.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }

      return this._normSign();
    };

    BN.prototype._normSign = function _normSign() {
      // -0 = 0
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }

      return this;
    };

    BN.prototype.inspect = function inspect() {
      return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    };
    /*
     var zeros = [];
    var groupSizes = [];
    var groupBases = [];
     var s = '';
    var i = -1;
    while (++i < BN.wordSize) {
      zeros[i] = s;
      s += '0';
    }
    groupSizes[0] = 0;
    groupSizes[1] = 0;
    groupBases[0] = 0;
    groupBases[1] = 0;
    var base = 2 - 1;
    while (++base < 36 + 1) {
      var groupSize = 0;
      var groupBase = 1;
      while (groupBase < (1 << BN.wordSize) / base) {
        groupBase *= base;
        groupSize += 1;
      }
      groupSizes[base] = groupSize;
      groupBases[base] = groupBase;
    }
     */


    var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
    var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
    var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;

      if (base === 16 || base === 'hex') {
        out = '';
        var off = 0;
        var carry = 0;

        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 0xffffff).toString(16);
          carry = w >>> 24 - off & 0xffffff;

          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }

          off += 2;

          if (off >= 26) {
            off -= 26;
            i--;
          }
        }

        if (carry !== 0) {
          out = carry.toString(16) + out;
        }

        while (out.length % padding !== 0) {
          out = '0' + out;
        }

        if (this.negative !== 0) {
          out = '-' + out;
        }

        return out;
      }

      if (base === (base | 0) && base >= 2 && base <= 36) {
        // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
        var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

        var groupBase = groupBases[base];
        out = '';
        var c = this.clone();
        c.negative = 0;

        while (!c.isZero()) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);

          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }

        if (this.isZero()) {
          out = '0' + out;
        }

        while (out.length % padding !== 0) {
          out = '0' + out;
        }

        if (this.negative !== 0) {
          out = '-' + out;
        }

        return out;
      }

      assert(false, 'Base should be between 2 and 36');
    };

    BN.prototype.toNumber = function toNumber() {
      var ret = this.words[0];

      if (this.length === 2) {
        ret += this.words[1] * 0x4000000;
      } else if (this.length === 3 && this.words[2] === 0x01) {
        // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
      } else if (this.length > 2) {
        assert(false, 'Number can only safely store up to 53 bits');
      }

      return this.negative !== 0 ? -ret : ret;
    };

    BN.prototype.toJSON = function toJSON() {
      return this.toString(16);
    };

    BN.prototype.toBuffer = function toBuffer(endian, length) {
      assert(typeof Buffer !== 'undefined');
      return this.toArrayLike(Buffer, endian, length);
    };

    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };

    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, 'byte array longer than desired length');
      assert(reqLength > 0, 'Requested array length <= 0');
      this.strip();
      var littleEndian = endian === 'le';
      var res = new ArrayType(reqLength);
      var b, i;
      var q = this.clone();

      if (!littleEndian) {
        // Assume big-endian
        for (i = 0; i < reqLength - byteLength; i++) {
          res[i] = 0;
        }

        for (i = 0; !q.isZero(); i++) {
          b = q.andln(0xff);
          q.iushrn(8);
          res[reqLength - i - 1] = b;
        }
      } else {
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(0xff);
          q.iushrn(8);
          res[i] = b;
        }

        for (; i < reqLength; i++) {
          res[i] = 0;
        }
      }

      return res;
    };

    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;

        if (t >= 0x1000) {
          r += 13;
          t >>>= 13;
        }

        if (t >= 0x40) {
          r += 7;
          t >>>= 7;
        }

        if (t >= 0x8) {
          r += 4;
          t >>>= 4;
        }

        if (t >= 0x02) {
          r += 2;
          t >>>= 2;
        }

        return r + t;
      };
    }

    BN.prototype._zeroBits = function _zeroBits(w) {
      // Short-cut
      if (w === 0) return 26;
      var t = w;
      var r = 0;

      if ((t & 0x1fff) === 0) {
        r += 13;
        t >>>= 13;
      }

      if ((t & 0x7f) === 0) {
        r += 7;
        t >>>= 7;
      }

      if ((t & 0xf) === 0) {
        r += 4;
        t >>>= 4;
      }

      if ((t & 0x3) === 0) {
        r += 2;
        t >>>= 2;
      }

      if ((t & 0x1) === 0) {
        r++;
      }

      return r;
    }; // Return number of used bits in a BN


    BN.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];

      var hi = this._countBits(w);

      return (this.length - 1) * 26 + hi;
    };

    function toBitArray(num) {
      var w = new Array(num.bitLength());

      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }

      return w;
    } // Number of trailing zero bits


    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero()) return 0;
      var r = 0;

      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);

        r += b;
        if (b !== 26) break;
      }

      return r;
    };

    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };

    BN.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }

      return this.clone();
    };

    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }

      return this.clone();
    };

    BN.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    }; // Return negative clone of `this`


    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };

    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }

      return this;
    }; // Or `num` with `this` in-place


    BN.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }

      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }

      return this.strip();
    };

    BN.prototype.ior = function ior(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuor(num);
    }; // Or `num` with `this`


    BN.prototype.or = function or(num) {
      if (this.length > num.length) return this.clone().ior(num);
      return num.clone().ior(this);
    };

    BN.prototype.uor = function uor(num) {
      if (this.length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this);
    }; // And `num` with `this` in-place


    BN.prototype.iuand = function iuand(num) {
      // b = min-length(num, this)
      var b;

      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }

      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }

      this.length = b.length;
      return this.strip();
    };

    BN.prototype.iand = function iand(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuand(num);
    }; // And `num` with `this`


    BN.prototype.and = function and(num) {
      if (this.length > num.length) return this.clone().iand(num);
      return num.clone().iand(this);
    };

    BN.prototype.uand = function uand(num) {
      if (this.length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this);
    }; // Xor `num` with `this` in-place


    BN.prototype.iuxor = function iuxor(num) {
      // a.length > b.length
      var a;
      var b;

      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }

      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }

      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }

      this.length = a.length;
      return this.strip();
    };

    BN.prototype.ixor = function ixor(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuxor(num);
    }; // Xor `num` with `this`


    BN.prototype.xor = function xor(num) {
      if (this.length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this);
    };

    BN.prototype.uxor = function uxor(num) {
      if (this.length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    }; // Not ``this`` with ``width`` bitwidth


    BN.prototype.inotn = function inotn(width) {
      assert(typeof width === 'number' && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26; // Extend the buffer with leading zeroes

      this._expand(bytesNeeded);

      if (bitsLeft > 0) {
        bytesNeeded--;
      } // Handle complete words


      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 0x3ffffff;
      } // Handle the residue


      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
      } // And remove leading zeroes


      return this.strip();
    };

    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    }; // Set `bit` of `this`


    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === 'number' && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;

      this._expand(off + 1);

      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }

      return this.strip();
    }; // Add `num` to `this` in-place


    BN.prototype.iadd = function iadd(num) {
      var r; // negative + positive

      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign(); // positive + negative
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      } // a.length > b.length


      var a, b;

      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }

      var carry = 0;

      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }

      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }

      this.length = a.length;

      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++; // Copy the rest of the words
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }

      return this;
    }; // Add `num` to `this`


    BN.prototype.add = function add(num) {
      var res;

      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }

      if (this.length > num.length) return this.clone().iadd(num);
      return num.clone().iadd(this);
    }; // Subtract `num` from `this` in-place


    BN.prototype.isub = function isub(num) {
      // this - (-num) = this + num
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign(); // -this - num = -(this + num)
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      } // At this point both numbers are positive


      var cmp = this.cmp(num); // Optimization - zeroify

      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      } // a > b


      var a, b;

      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }

      var carry = 0;

      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      }

      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      } // Copy rest of the words


      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }

      this.length = Math.max(this.length, i);

      if (a !== this) {
        this.negative = 1;
      }

      return this.strip();
    }; // Subtract `num` from `this`


    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };

    function smallMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      var len = self.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

      var a = self.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 0x3ffffff;
      var carry = r / 0x4000000 | 0;
      out.words[0] = lo;

      for (var k = 1; k < len; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = carry >>> 26;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);

        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += r / 0x4000000 | 0;
          rword = r & 0x3ffffff;
        }

        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }

      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }

      return out.strip();
    } // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).


    var comb10MulTo = function comb10MulTo(self, num, out) {
      var a = self.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 0x1fff;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 0x1fff;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 0x1fff;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 0x1fff;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 0x1fff;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 0x1fff;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 0x1fff;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 0x1fff;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 0x1fff;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 0x1fff;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 0x1fff;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 0x1fff;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 0x1fff;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 0x1fff;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 0x1fff;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 0x1fff;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 0x1fff;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 0x1fff;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 0x1fff;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 0x1fff;
      var bh9 = b9 >>> 13;
      out.negative = self.negative ^ num.negative;
      out.length = 19;
      /* k = 0 */

      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 0x3ffffff;
      /* k = 1 */

      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 0x3ffffff;
      /* k = 2 */

      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 0x3ffffff;
      /* k = 3 */

      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 0x3ffffff;
      /* k = 4 */

      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 0x3ffffff;
      /* k = 5 */

      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 0x3ffffff;
      /* k = 6 */

      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 0x3ffffff;
      /* k = 7 */

      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 0x3ffffff;
      /* k = 8 */

      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 0x3ffffff;
      /* k = 9 */

      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 0x3ffffff;
      /* k = 10 */

      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 0x3ffffff;
      /* k = 11 */

      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 0x3ffffff;
      /* k = 12 */

      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 0x3ffffff;
      /* k = 13 */

      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 0x3ffffff;
      /* k = 14 */

      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 0x3ffffff;
      /* k = 15 */

      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 0x3ffffff;
      /* k = 16 */

      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 0x3ffffff;
      /* k = 17 */

      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 0x3ffffff;
      /* k = 18 */

      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 0x3ffffff;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;

      if (c !== 0) {
        o[19] = c;
        out.length++;
      }

      return out;
    }; // Polyfill comb


    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }

    function bigMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      out.length = self.length + num.length;
      var carry = 0;
      var hncarry = 0;

      for (var k = 0; k < out.length - 1; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);

        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 0x3ffffff;
          ncarry = ncarry + (r / 0x4000000 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 0x3ffffff;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 0x3ffffff;
        }

        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }

      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }

      return out.strip();
    }

    function jumboMulTo(self, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self, num, out);
    }

    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;

      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }

      return res;
    }; // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion


    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }

    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;

      for (var i = 0; i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }

      return t;
    }; // Returns binary-reversed representation of `x`


    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1) return x;
      var rb = 0;

      for (var i = 0; i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }

      return rb;
    }; // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm


    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0; i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };

    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);

      for (var s = 1; s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);

        for (var p = 0; p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;

          for (var j = 0; j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            /* jshint maxdepth : false */

            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };

    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;

      for (N = N / 2 | 0; N; N = N >>> 1) {
        i++;
      }

      return 1 << i + 1 + odd;
    };

    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1) return;

      for (var i = 0; i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };

    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;

      for (var i = 0; i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 0x3ffffff;

        if (w < 0x4000000) {
          carry = 0;
        } else {
          carry = w / 0x4000000 | 0;
        }
      }

      return ws;
    };

    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;

      for (var i = 0; i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 0x1fff;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 0x1fff;
        carry = carry >>> 13;
      } // Pad with zeroes


      for (i = 2 * len; i < N; ++i) {
        rws[i] = 0;
      }

      assert(carry === 0);
      assert((carry & ~0x1fff) === 0);
    };

    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);

      for (var i = 0; i < N; i++) {
        ph[i] = 0;
      }

      return ph;
    };

    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);

      var _ = this.stub(N);

      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);

      for (var i = 0; i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }

      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    }; // Multiply `this` by `num`


    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    }; // Multiply employing FFT


    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    }; // In-place Multiplication


    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };

    BN.prototype.imuln = function imuln(num) {
      assert(typeof num === 'number');
      assert(num < 0x4000000); // Carry

      var carry = 0;

      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
        carry >>= 26;
        carry += w / 0x4000000 | 0; // NOTE: lo is 27bit maximum

        carry += lo >>> 26;
        this.words[i] = lo & 0x3ffffff;
      }

      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }

      return this;
    };

    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    }; // `this` * `this`


    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    }; // `this` * `this` in-place


    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    }; // Math.pow(`this`, `num`)


    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0) return new BN(1); // Skip leading zeroes

      var res = this;

      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0) break;
      }

      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0) continue;
          res = res.mul(q);
        }
      }

      return res;
    }; // Shift-left in-place


    BN.prototype.iushln = function iushln(bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
      var i;

      if (r !== 0) {
        var carry = 0;

        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }

        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }

      if (s !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }

        for (i = 0; i < s; i++) {
          this.words[i] = 0;
        }

        this.length += s;
      }

      return this.strip();
    };

    BN.prototype.ishln = function ishln(bits) {
      // TODO(indutny): implement me
      assert(this.negative === 0);
      return this.iushln(bits);
    }; // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits


    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert(typeof bits === 'number' && bits >= 0);
      var h;

      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }

      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h); // Extended mode, copy masked part

      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }

        maskedWords.length = s;
      }

      if (s === 0) ; else if (this.length > s) {
        this.length -= s;

        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }

      var carry = 0;

      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
      } // Push carried bits as a mask


      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }

      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }

      return this.strip();
    };

    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      // TODO(indutny): implement me
      assert(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    }; // Shift-left


    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };

    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    }; // Shift-right


    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };

    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    }; // Test if n bit is set


    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === 'number' && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r; // Fast case: bit is much higher than all existing words

      if (this.length <= s) return false; // Check bit and return

      var w = this.words[s];
      return !!(w & q);
    }; // Return only lowers bits of number (in-place)


    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert(this.negative === 0, 'imaskn works only with positive numbers');

      if (this.length <= s) {
        return this;
      }

      if (r !== 0) {
        s++;
      }

      this.length = Math.min(s, this.length);

      if (r !== 0) {
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        this.words[this.length - 1] &= mask;
      }

      return this.strip();
    }; // Return only lowers bits of number


    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    }; // Add plain number `num` to `this`


    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === 'number');
      assert(num < 0x4000000);
      if (num < 0) return this.isubn(-num); // Possible sign change

      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }

        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      } // Add without checks


      return this._iaddn(num);
    };

    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num; // Carry

      for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
        this.words[i] -= 0x4000000;

        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }

      this.length = Math.max(this.length, i + 1);
      return this;
    }; // Subtract plain number `num` from `this`


    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === 'number');
      assert(num < 0x4000000);
      if (num < 0) return this.iaddn(-num);

      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }

      this.words[0] -= num;

      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        // Carry
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 0x4000000;
          this.words[i + 1] -= 1;
        }
      }

      return this.strip();
    };

    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };

    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };

    BN.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };

    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };

    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;

      this._expand(len);

      var w;
      var carry = 0;

      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 0x3ffffff;
        carry = (w >> 26) - (right / 0x4000000 | 0);
        this.words[i + shift] = w & 0x3ffffff;
      }

      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 0x3ffffff;
      }

      if (carry === 0) return this.strip(); // Subtraction overflow

      assert(carry === -1);
      carry = 0;

      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 0x3ffffff;
      }

      this.negative = 1;
      return this.strip();
    };

    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num; // Normalize

      var bhi = b.words[b.length - 1] | 0;

      var bhiBits = this._countBits(bhi);

      shift = 26 - bhiBits;

      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      } // Initialize quotient


      var m = a.length - b.length;
      var q;

      if (mode !== 'mod') {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);

        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }

      var diff = a.clone()._ishlnsubmul(b, 1, m);

      if (diff.negative === 0) {
        a = diff;

        if (q) {
          q.words[m] = 1;
        }
      }

      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
        // (0x7ffffff)

        qj = Math.min(qj / bhi | 0, 0x3ffffff);

        a._ishlnsubmul(b, qj, j);

        while (a.negative !== 0) {
          qj--;
          a.negative = 0;

          a._ishlnsubmul(b, 1, j);

          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }

        if (q) {
          q.words[j] = qj;
        }
      }

      if (q) {
        q.strip();
      }

      a.strip(); // Denormalize

      if (mode !== 'div' && shift !== 0) {
        a.iushrn(shift);
      }

      return {
        div: q || null,
        mod: a
      };
    }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested


    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert(!num.isZero());

      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }

      var div, mod, res;

      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);

        if (mode !== 'mod') {
          div = res.div.neg();
        }

        if (mode !== 'div') {
          mod = res.mod.neg();

          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }

        return {
          div: div,
          mod: mod
        };
      }

      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);

        if (mode !== 'mod') {
          div = res.div.neg();
        }

        return {
          div: div,
          mod: res.mod
        };
      }

      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);

        if (mode !== 'div') {
          mod = res.mod.neg();

          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }

        return {
          div: res.div,
          mod: mod
        };
      } // Both numbers are positive at this point
      // Strip both numbers to approximate shift value


      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this
        };
      } // Very short reduction


      if (num.length === 1) {
        if (mode === 'div') {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }

        if (mode === 'mod') {
          return {
            div: null,
            mod: new BN(this.modn(num.words[0]))
          };
        }

        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return this._wordDiv(num, mode);
    }; // Find `this` / `num`


    BN.prototype.div = function div(num) {
      return this.divmod(num, 'div', false).div;
    }; // Find `this` % `num`


    BN.prototype.mod = function mod(num) {
      return this.divmod(num, 'mod', false).mod;
    };

    BN.prototype.umod = function umod(num) {
      return this.divmod(num, 'mod', true).mod;
    }; // Find Round(`this` / `num`)


    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num); // Fast case - exact division

      if (dm.mod.isZero()) return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half); // Round down

      if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };

    BN.prototype.modn = function modn(num) {
      assert(num <= 0x3ffffff);
      var p = (1 << 26) % num;
      var acc = 0;

      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }

      return acc;
    }; // In-place division by number


    BN.prototype.idivn = function idivn(num) {
      assert(num <= 0x3ffffff);
      var carry = 0;

      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 0x4000000;
        this.words[i] = w / num | 0;
        carry = w % num;
      }

      return this.strip();
    };

    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };

    BN.prototype.egcd = function egcd(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var x = this;
      var y = p.clone();

      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      } // A * x + B * y = x


      var A = new BN(1);
      var B = new BN(0); // C * x + D * y = y

      var C = new BN(0);
      var D = new BN(1);
      var g = 0;

      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }

      var yp = y.clone();
      var xp = x.clone();

      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
        }

        if (i > 0) {
          x.iushrn(i);

          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }

            A.iushrn(1);
            B.iushrn(1);
          }
        }

        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
        }

        if (j > 0) {
          y.iushrn(j);

          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }

            C.iushrn(1);
            D.iushrn(1);
          }
        }

        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }

      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    }; // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed


    BN.prototype._invmp = function _invmp(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var a = this;
      var b = p.clone();

      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }

      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();

      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
        }

        if (i > 0) {
          a.iushrn(i);

          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }

            x1.iushrn(1);
          }
        }

        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
        }

        if (j > 0) {
          b.iushrn(j);

          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }

            x2.iushrn(1);
          }
        }

        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }

      var res;

      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }

      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }

      return res;
    };

    BN.prototype.gcd = function gcd(num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0; // Remove common factor of two

      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }

      do {
        while (a.isEven()) {
          a.iushrn(1);
        }

        while (b.isEven()) {
          b.iushrn(1);
        }

        var r = a.cmp(b);

        if (r < 0) {
          // Swap `a` and `b` to make `a` always bigger than `b`
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }

        a.isub(b);
      } while (true);

      return b.iushln(shift);
    }; // Invert number in the field F(num)


    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };

    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };

    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    }; // And first word and num


    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    }; // Increment at the bit position in-line


    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === 'number');
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r; // Fast case: bit is much higher than all existing words

      if (this.length <= s) {
        this._expand(s + 1);

        this.words[s] |= q;
        return this;
      } // Add bit and propagate, if needed


      var carry = q;

      for (var i = s; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 0x3ffffff;
        this.words[i] = w;
      }

      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }

      return this;
    };

    BN.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };

    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative) return -1;
      if (this.negative === 0 && negative) return 1;
      this.strip();
      var res;

      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }

        assert(num <= 0x3ffffff, 'Number is too big');
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }

      if (this.negative !== 0) return -res | 0;
      return res;
    }; // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`


    BN.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0) return -1;
      if (this.negative === 0 && num.negative !== 0) return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0) return -res | 0;
      return res;
    }; // Unsigned comparison


    BN.prototype.ucmp = function ucmp(num) {
      // At this point both numbers have the same sign
      if (this.length > num.length) return 1;
      if (this.length < num.length) return -1;
      var res = 0;

      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;

        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }

        break;
      }

      return res;
    };

    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };

    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };

    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };

    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };

    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };

    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };

    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };

    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };

    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };

    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    }; //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //


    BN.red = function red(num) {
      return new Red(num);
    };

    BN.prototype.toRed = function toRed(ctx) {
      assert(!this.red, 'Already a number in reduction context');
      assert(this.negative === 0, 'red works only with positives');
      return ctx.convertTo(this)._forceRed(ctx);
    };

    BN.prototype.fromRed = function fromRed() {
      assert(this.red, 'fromRed works only with numbers in reduction context');
      return this.red.convertFrom(this);
    };

    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };

    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!this.red, 'Already a number in reduction context');
      return this._forceRed(ctx);
    };

    BN.prototype.redAdd = function redAdd(num) {
      assert(this.red, 'redAdd works only with red numbers');
      return this.red.add(this, num);
    };

    BN.prototype.redIAdd = function redIAdd(num) {
      assert(this.red, 'redIAdd works only with red numbers');
      return this.red.iadd(this, num);
    };

    BN.prototype.redSub = function redSub(num) {
      assert(this.red, 'redSub works only with red numbers');
      return this.red.sub(this, num);
    };

    BN.prototype.redISub = function redISub(num) {
      assert(this.red, 'redISub works only with red numbers');
      return this.red.isub(this, num);
    };

    BN.prototype.redShl = function redShl(num) {
      assert(this.red, 'redShl works only with red numbers');
      return this.red.shl(this, num);
    };

    BN.prototype.redMul = function redMul(num) {
      assert(this.red, 'redMul works only with red numbers');

      this.red._verify2(this, num);

      return this.red.mul(this, num);
    };

    BN.prototype.redIMul = function redIMul(num) {
      assert(this.red, 'redMul works only with red numbers');

      this.red._verify2(this, num);

      return this.red.imul(this, num);
    };

    BN.prototype.redSqr = function redSqr() {
      assert(this.red, 'redSqr works only with red numbers');

      this.red._verify1(this);

      return this.red.sqr(this);
    };

    BN.prototype.redISqr = function redISqr() {
      assert(this.red, 'redISqr works only with red numbers');

      this.red._verify1(this);

      return this.red.isqr(this);
    }; // Square root over p


    BN.prototype.redSqrt = function redSqrt() {
      assert(this.red, 'redSqrt works only with red numbers');

      this.red._verify1(this);

      return this.red.sqrt(this);
    };

    BN.prototype.redInvm = function redInvm() {
      assert(this.red, 'redInvm works only with red numbers');

      this.red._verify1(this);

      return this.red.invm(this);
    }; // Return negative clone of `this` % `red modulo`


    BN.prototype.redNeg = function redNeg() {
      assert(this.red, 'redNeg works only with red numbers');

      this.red._verify1(this);

      return this.red.neg(this);
    };

    BN.prototype.redPow = function redPow(num) {
      assert(this.red && !num.red, 'redPow(normalNum)');

      this.red._verify1(this);

      return this.red.pow(this, num);
    }; // Prime numbers with efficient reduction


    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    }; // Pseudo-Mersenne prime

    function MPrime(name, p) {
      // P = 2 ^ N - K
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }

    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };

    MPrime.prototype.ireduce = function ireduce(num) {
      // Assumes that `num` is less than `P^2`
      // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
      var r = num;
      var rlen;

      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);

      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);

      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== undefined) {
          // r is BN v4 instance
          r.strip();
        } else {
          // r is BN v5 instance
          r._strip();
        }
      }

      return r;
    };

    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };

    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };

    function K256() {
      MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }

    inherits(K256, MPrime);

    K256.prototype.split = function split(input, output) {
      // 256 = 9 * 26 + 22
      var mask = 0x3fffff;
      var outLen = Math.min(input.length, 9);

      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }

      output.length = outLen;

      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      } // Shift by 9 limbs


      var prev = input.words[9];
      output.words[output.length++] = prev & mask;

      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }

      prev >>>= 22;
      input.words[i - 10] = prev;

      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };

    K256.prototype.imulK = function imulK(num) {
      // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

      var lo = 0;

      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 0x3d1;
        num.words[i] = lo & 0x3ffffff;
        lo = w * 0x40 + (lo / 0x4000000 | 0);
      } // Fast length reduction


      if (num.words[num.length - 1] === 0) {
        num.length--;

        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }

      return num;
    };

    function P224() {
      MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }

    inherits(P224, MPrime);

    function P192() {
      MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }

    inherits(P192, MPrime);

    function P25519() {
      // 2 ^ 255 - 19
      MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }

    inherits(P25519, MPrime);

    P25519.prototype.imulK = function imulK(num) {
      // K = 0x13
      var carry = 0;

      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 0x13 + carry;
        var lo = hi & 0x3ffffff;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }

      if (carry !== 0) {
        num.words[num.length++] = carry;
      }

      return num;
    }; // Exported mostly for testing purposes, use plain name instead


    BN._prime = function prime(name) {
      // Cached version of prime
      if (primes[name]) return primes[name];
      var prime;

      if (name === 'k256') {
        prime = new K256();
      } else if (name === 'p224') {
        prime = new P224();
      } else if (name === 'p192') {
        prime = new P192();
      } else if (name === 'p25519') {
        prime = new P25519();
      } else {
        throw new Error('Unknown prime ' + name);
      }

      primes[name] = prime;
      return prime;
    }; //
    // Base reduction engine
    //


    function Red(m) {
      if (typeof m === 'string') {
        var prime = BN._prime(m);

        this.m = prime.p;
        this.prime = prime;
      } else {
        assert(m.gtn(1), 'modulus must be greater than 1');
        this.m = m;
        this.prime = null;
      }
    }

    Red.prototype._verify1 = function _verify1(a) {
      assert(a.negative === 0, 'red works only with positives');
      assert(a.red, 'red works only with red numbers');
    };

    Red.prototype._verify2 = function _verify2(a, b) {
      assert((a.negative | b.negative) === 0, 'red works only with positives');
      assert(a.red && a.red === b.red, 'red works only with red numbers');
    };

    Red.prototype.imod = function imod(a) {
      if (this.prime) return this.prime.ireduce(a)._forceRed(this);
      return a.umod(this.m)._forceRed(this);
    };

    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }

      return this.m.sub(a)._forceRed(this);
    };

    Red.prototype.add = function add(a, b) {
      this._verify2(a, b);

      var res = a.add(b);

      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }

      return res._forceRed(this);
    };

    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);

      var res = a.iadd(b);

      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }

      return res;
    };

    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);

      var res = a.sub(b);

      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }

      return res._forceRed(this);
    };

    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);

      var res = a.isub(b);

      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }

      return res;
    };

    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);

      return this.imod(a.ushln(num));
    };

    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);

      return this.imod(a.imul(b));
    };

    Red.prototype.mul = function mul(a, b) {
      this._verify2(a, b);

      return this.imod(a.mul(b));
    };

    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };

    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };

    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero()) return a.clone();
      var mod3 = this.m.andln(3);
      assert(mod3 % 2 === 1); // Fast case

      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
      } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
      //
      // Find Q and S, that Q * 2 ^ S = (P - 1)


      var q = this.m.subn(1);
      var s = 0;

      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }

      assert(!q.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg(); // Find quadratic non-residue
      // NOTE: Max is such because of generalized Riemann hypothesis.

      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN(2 * z * z).toRed(this);

      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }

      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;

      while (t.cmp(one) !== 0) {
        var tmp = t;

        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }

        assert(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }

      return r;
    };

    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);

      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };

    Red.prototype.pow = function pow(a, num) {
      if (num.isZero()) return new BN(1).toRed(this);
      if (num.cmpn(1) === 0) return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;

      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }

      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;

      if (start === 0) {
        start = 26;
      }

      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];

        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;

          if (res !== wnd[0]) {
            res = this.sqr(res);
          }

          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }

          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }

        start = 26;
      }

      return res;
    };

    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };

    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    }; //
    // Montgomery method engine
    //


    BN.mont = function mont(num) {
      return new Mont(num);
    };

    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();

      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }

      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }

    inherits(Mont, Red);

    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };

    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };

    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }

      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;

      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }

      return res._forceRed(this);
    };

    Mont.prototype.mul = function mul(a, b) {
      if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;

      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }

      return res._forceRed(this);
    };

    Mont.prototype.invm = function invm(a) {
      // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn);

var AUDIO_DECMIALS$1 = 18;
var WAUDIO_DECMIALS$3 = 8;
var CURRENT_USER_EXISTS_LOCAL_STORAGE_KEY = '@audius/libs:found-user';
var AuthHeaders$1;

(function (AuthHeaders) {
  AuthHeaders["MESSAGE"] = "Encoded-Data-Message";
  AuthHeaders["SIGNATURE"] = "Encoded-Data-Signature";
})(AuthHeaders$1 || (AuthHeaders$1 = {}));

var constants = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AUDIO_DECMIALS: AUDIO_DECMIALS$1,
  WAUDIO_DECMIALS: WAUDIO_DECMIALS$3,
  CURRENT_USER_EXISTS_LOCAL_STORAGE_KEY: CURRENT_USER_EXISTS_LOCAL_STORAGE_KEY,
  get AuthHeaders () { return AuthHeaders$1; }
});

var require$$5 = /*@__PURE__*/getAugmentedNamespace(constants);

var padBNToUint8Array = require$$0$1.padBNToUint8Array;
var PublicKey$6 = require$$1__default["default"].PublicKey;
var BN$4 = bn.exports;
var keccak256 = require$$3__default["default"];
var secp256k1$1 = require$$4__default["default"];
var WAUDIO_DECMIALS$2 = require$$5.WAUDIO_DECMIALS;

var SolanaUtils$5 = /*#__PURE__*/function () {
  function SolanaUtils() {
    _classCallCheck(this, SolanaUtils);
  }

  _createClass(SolanaUtils, null, [{
    key: "signBytes",
    value:
    /**
     * Signs arbitrary bytes
     *
     * @param {*} bytes
     * @param {string} ethPrivateKey
     */
    function signBytes(bytes, ethPrivateKey) {
      var msgHash = keccak256(bytes);
      var ethPrivateKeyArr = Buffer.from(ethPrivateKey, 'hex');
      var signatureObj = secp256k1$1.ecdsaSign(Uint8Array.from(msgHash), ethPrivateKeyArr);
      var signature = Buffer.from(signatureObj.signature);
      return {
        signature: signature,
        recoveryId: signatureObj.recid
      };
    }
    /**
     * Puts an instruction in a serializable form that our relay can understand.
     *
     * @param {TransactionInstruction} instruction
     */

  }, {
    key: "prepareInstructionForRelay",
    value: function prepareInstructionForRelay(instruction) {
      return {
        programId: instruction.programId.toString(),
        data: instruction.data,
        keys: instruction.keys.map(function (_ref) {
          var isSigner = _ref.isSigner,
              pubkey = _ref.pubkey,
              isWritable = _ref.isWritable;
          return {
            pubkey: pubkey.toString(),
            isSigner: isSigner,
            isWritable: isWritable
          };
        })
      };
    }
    /**
     * Constructs a transfer ID
     * @param {string} challengeId
     * @param {string} specifier
     * @returns {string}
     */

  }, {
    key: "constructTransferId",
    value: function constructTransferId(challengeId, specifier) {
      return "".concat(challengeId, ":").concat(specifier);
    }
    /**
     * Constructs an attestation from inputs.
     *
     * @param {string} recipientEthAddress
     * @param {BN} tokenAmount
     * @param {string} transferId
     * @param {string} [oracleAddress] optional oracle address, only used for DN attestations
     * @returns {Uint8Array}
     */

  }, {
    key: "constructAttestation",
    value: function constructAttestation(recipientEthAddress, tokenAmount, transferId, oracleAddress) {
      var encoder = new TextEncoder();
      var userBytes = SolanaUtils.ethAddressToArray(recipientEthAddress);
      var transferIdBytes = encoder.encode(transferId);
      var amountBytes = padBNToUint8Array(tokenAmount);
      var items = oracleAddress ? [userBytes, amountBytes, transferIdBytes, SolanaUtils.ethAddressToArray(oracleAddress)] : [userBytes, amountBytes, transferIdBytes];
      var sep = encoder.encode('_');
      var res = items.slice(1).reduce(function (prev, cur, i) {
        return Uint8Array.of.apply(Uint8Array, _toConsumableArray(prev).concat(_toConsumableArray(sep), _toConsumableArray(cur)));
      }, Uint8Array.from(items[0]));
      return res;
    }
    /**
     * Converts "UI" wAudio (i.e. 5) into properly denominated BN representation - (i.e. 5 * 10 ^ 8)
     *
     * @param {number} amount
     * @returns BN
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "uiAudioToBNWaudio",
    value: function uiAudioToBNWaudio(amount) {
      return new BN$4(amount * Math.pow(10, WAUDIO_DECMIALS$2));
    }
    /**
     * Derives a program address from a program ID and pubkey as seed.
     * Optionally takes in seeds.
     * Returns the new pubkey and bump seeds.
     *
     * @param {PublicKey} programId
     * @param {PublicKey} pubkey
     * @param {Uint8Array} [seed] optionally include a seed
     * @returns {Promise<[PublicKey, number]>}
     */

  }, {
    key: "findProgramAddressFromPubkey",
    value: function () {
      var _findProgramAddressFromPubkey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(programId, pubkey, seed) {
        var seedsArr;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                seedsArr = [pubkey.toBytes().slice(0, 32)];

                if (seed) {
                  seedsArr.push(seed);
                }

                return _context.abrupt("return", PublicKey$6.findProgramAddress(seedsArr, programId));

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function findProgramAddressFromPubkey(_x, _x2, _x3) {
        return _findProgramAddressFromPubkey.apply(this, arguments);
      }

      return findProgramAddressFromPubkey;
    }()
    /**
     * Finds a program address, using both seeds, pubkey, and the derived authority.
     * Return [authority, derivedAddress, and bumpSeeds]
     *
     * @param {PublicKey} programId
     * @param {PublicKey} address
     * @param {Uint8Array} seed
     * @returns {Promise<[PublicKey, PublicKey, number]>}
     */

  }, {
    key: "findProgramAddressWithAuthority",
    value: function () {
      var _findProgramAddressWithAuthority = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(programId, address, seed) {
        var _yield$SolanaUtils$fi, _yield$SolanaUtils$fi2, authority, _yield$SolanaUtils$fi3, _yield$SolanaUtils$fi4, derivedAddress, bumpSeed;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return SolanaUtils.findProgramAddressFromPubkey(programId, address);

              case 2:
                _yield$SolanaUtils$fi = _context2.sent;
                _yield$SolanaUtils$fi2 = _slicedToArray(_yield$SolanaUtils$fi, 1);
                authority = _yield$SolanaUtils$fi2[0];
                _context2.next = 7;
                return SolanaUtils.findProgramAddressFromPubkey(programId, authority, seed);

              case 7:
                _yield$SolanaUtils$fi3 = _context2.sent;
                _yield$SolanaUtils$fi4 = _slicedToArray(_yield$SolanaUtils$fi3, 2);
                derivedAddress = _yield$SolanaUtils$fi4[0];
                bumpSeed = _yield$SolanaUtils$fi4[1];
                return _context2.abrupt("return", [authority, derivedAddress, bumpSeed]);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function findProgramAddressWithAuthority(_x4, _x5, _x6) {
        return _findProgramAddressWithAuthority.apply(this, arguments);
      }

      return findProgramAddressWithAuthority;
    }()
    /**
     * Converts an eth address hex represenatation to an array of Uint8s in big endian notation
     * @param {string} ethAddress
     * @returns {Uint8Array}
     */

  }, {
    key: "ethAddressToArray",
    value: function ethAddressToArray(ethAddress) {
      var strippedEthAddress = ethAddress.replace('0x', ''); // Need to pad the array to length 20 - otherwise, hex eth keys starting with '0' would
      // result in truncated arrays, while eth spec is always 20 bytes

      return Uint8Array.of.apply(Uint8Array, _toConsumableArray(new BN$4(strippedEthAddress, 'hex').toArray('be', 20)));
    } // Safely create pubkey from nullable val

  }, {
    key: "newPublicKeyNullable",
    value: function newPublicKeyNullable(val) {
      return val ? new PublicKey$6(val) : null;
    }
  }]);

  return SolanaUtils;
}();

var utils = SolanaUtils$5;

/**
 * All errors returned by Anchor Audius Data
 */

var CustomAudiusDataErrors = new Map(AudiusData__namespace.idl.errors.map(function (_ref) {
  var code = _ref.code,
      msg = _ref.msg;
  return [code, msg];
}));
var audiusDataErrorMapping = {
  fromErrorCode: function fromErrorCode(errorCode) {
    var programError = anchor$1.ProgramError.parse("\"Custom\":".concat(errorCode.toString(), "}"), CustomAudiusDataErrors);
    if (programError === null) return 'UNKNOWN';
    return programError.msg;
  }
};

/**
 * SolanaAudiusData acts as the interface to solana audius data programs from a client.
 * It wraps methods to create transactions.
 */

var SolanaAudiusData = /*#__PURE__*/function () {
  /**
   * @param {Object} anchorAudiusDataConfig The config object
   * @param {string} anchorAudiusDataConfig.programId Program ID of the audius data program
   * @param {string} anchorAudiusDataConfig.adminAccount Public Key of admin storage account
   * @param {SolanaWeb3Manager} solanaWeb3Manager Solana web3 Manager
   * @param {Web3Manager} web3Manager
   */
  function SolanaAudiusData(anchorAudiusDataConfig, solanaWeb3Manager, web3Manager) {
    _classCallCheck(this, SolanaAudiusData);

    this.anchorAudiusDataConfig = anchorAudiusDataConfig;
    this.solanaWeb3Manager = solanaWeb3Manager;
    this.web3Manager = web3Manager;
    this.AudiusData = AudiusData__namespace;
  }

  _createClass(SolanaAudiusData, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this$anchorAudiusDat, programId, adminAccount;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this$anchorAudiusDat = this.anchorAudiusDataConfig, programId = _this$anchorAudiusDat.programId, adminAccount = _this$anchorAudiusDat.adminAccount;
                this.programId = utils.newPublicKeyNullable(programId);
                this.adminAccount = utils.newPublicKeyNullable(adminAccount);
                this.provider = new anchor__default["default"].AnchorProvider(this.solanaWeb3Manager.connection, // NOTE: Method requests type wallet, but because signtransaction is not used, keypair is fine
                require$$1$1v.Keypair.generate(), anchor__default["default"].AnchorProvider.defaultOptions());
                this.program = new anchor__default["default"].Program(AudiusData__namespace.idl, this.programId, this.provider);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }() // Setters

  }, {
    key: "setAdminAccount",
    value: function setAdminAccount(AdminAccount) {
      this.adminAccount = AdminAccount;
    } // ============================= HELPERS =============================

    /**
     * Validate that the program, provider and base variables were initted
     * @returns {boolean} True if the class was initted
     */

  }, {
    key: "didInit",
    value: function didInit() {
      return Boolean(this.programId && this.adminAccount && this.solanaWeb3Manager.feePayerKey && this.program);
    }
    /**
     * Encodes and derives the user account, bump seed, and base authority
     */

  }, {
    key: "getUserIdSeed",
    value: function () {
      var _getUserIdSeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(userId) {
        var userIdSeed, _yield$this$solanaWeb, baseAuthorityAccount, bumpSeed, userAccount;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // @ts-expect-error
                userIdSeed = userId.toArrayLike(Uint8Array, 'le', 4);
                _context2.next = 3;
                return this.solanaWeb3Manager.findDerivedPair(this.programId, this.adminAccount, userIdSeed);

              case 3:
                _yield$this$solanaWeb = _context2.sent;
                baseAuthorityAccount = _yield$this$solanaWeb.baseAuthorityAccount;
                bumpSeed = _yield$this$solanaWeb.bumpSeed;
                userAccount = _yield$this$solanaWeb.derivedAddress;
                return _context2.abrupt("return", {
                  userId: userId,
                  userIdSeed: userIdSeed,
                  userAccount: userAccount,
                  bumpSeed: bumpSeed,
                  baseAuthorityAccount: baseAuthorityAccount
                });

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getUserIdSeed(_x) {
        return _getUserIdSeed.apply(this, arguments);
      }

      return getUserIdSeed;
    }()
    /**
     * Derives the user solana keypair using the user's eth private key
     */

  }, {
    key: "getUserKeyPair",
    value: function getUserKeyPair() {
      return anchor__default["default"].web3.Keypair.fromSeed(this.web3Manager.ownerWallet.getPrivateKey());
    }
    /**
     * Encodes and derives the content node account and bump seed
     */

  }, {
    key: "getContentNodeSeedAddress",
    value: function () {
      var _getContentNodeSeedAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(spId) {
        var enc, baseSpIdSeed, spIdValue, _yield$this$solanaWeb2, bumpSeed, derivedAddress;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                enc = new TextEncoder(); // always utf-8

                baseSpIdSeed = enc.encode('sp_id');
                spIdValue = new anchor__default["default"].BN(spId).toArray('le', 2);
                _context3.next = 5;
                return this.solanaWeb3Manager.findDerivedPair(this.programId, this.adminAccount, new Uint8Array([].concat(_toConsumableArray(baseSpIdSeed), _toConsumableArray(spIdValue))));

              case 5:
                _yield$this$solanaWeb2 = _context3.sent;
                bumpSeed = _yield$this$solanaWeb2.bumpSeed;
                derivedAddress = _yield$this$solanaWeb2.derivedAddress;
                return _context3.abrupt("return", {
                  bumpSeed: bumpSeed,
                  derivedAddress: derivedAddress
                });

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getContentNodeSeedAddress(_x2) {
        return _getContentNodeSeedAddress.apply(this, arguments);
      }

      return getContentNodeSeedAddress;
    }()
    /**
     * Signs a transaction using the user's key pair
     * NOTE: The blockhash and feepayer must be set when signing and passed along
     * with the transaction for further signatures for consitency or the signature
     * will be invalide
     */

  }, {
    key: "signTransaction",
    value: function () {
      var _signTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(tx, userKeyPair) {
        var latestBlockHash;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.solanaWeb3Manager.connection.getLatestBlockhash('confirmed');

              case 2:
                latestBlockHash = _context4.sent;
                tx.recentBlockhash = latestBlockHash.blockhash;
                tx.feePayer = this.solanaWeb3Manager.feePayerKey;
                tx.partialSign(userKeyPair);
                return _context4.abrupt("return", tx);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function signTransaction(_x3, _x4) {
        return _signTransaction.apply(this, arguments);
      }

      return signTransaction;
    }()
    /**
     * Submits a transaction via the solanaWeb3Manager transactionHandler passing along
     * the signtures.
     * This base method is used to send all transactions in this class
     */

  }, {
    key: "sendTx",
    value: function () {
      var _sendTx = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(tx) {
        var signatures, response;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                signatures = tx.signatures.filter(function (s) {
                  return s.signature && s.publicKey;
                }).map(function (s) {
                  return {
                    publicKey: s.publicKey.toBase58(),
                    signature: s.signature
                  };
                });
                _context5.next = 3;
                return this.solanaWeb3Manager.transactionHandler.handleTransaction({
                  instructions: tx.instructions,
                  errorMapping: audiusDataErrorMapping,
                  feePayerOverride: this.solanaWeb3Manager.feePayerKey,
                  recentBlockhash: tx.recentBlockhash,
                  logger: console,
                  sendBlockhash: true,
                  signatures: signatures
                });

              case 3:
                response = _context5.sent;
                return _context5.abrupt("return", response);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function sendTx(_x5) {
        return _sendTx.apply(this, arguments);
      }

      return sendTx;
    }() // ============================= PROGRAM METHODS =============================

    /**
     * Creates an admin account
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "initAdmin",
    value: function () {
      var _initAdmin = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params) {
        var tx;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(!this.program || !this.solanaWeb3Manager.feePayerKey)) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return");

              case 2:
                tx = AudiusData__namespace.initAdmin(_objectSpread2({
                  payer: this.solanaWeb3Manager.feePayerKey,
                  program: this.program
                }, params));
                _context6.next = 5;
                return this.sendTx(tx);

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function initAdmin(_x6) {
        return _initAdmin.apply(this, arguments);
      }

      return initAdmin;
    }()
    /**
     * Creates a user account to be claimed.
     * NOTE: This transaction needs to be signed by the admin account
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "initUser",
    value: function () {
      var _initUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params) {
        var tx;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this.didInit()) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return");

              case 2:
                tx = AudiusData__namespace.initUser(_objectSpread2({
                  payer: this.solanaWeb3Manager.feePayerKey,
                  program: this.program,
                  adminAccount: this.adminAccount
                }, params));
                _context7.next = 5;
                return this.sendTx(tx);

              case 5:
                return _context7.abrupt("return", _context7.sent);

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function initUser(_x7) {
        return _initUser.apply(this, arguments);
      }

      return initUser;
    }()
    /**
     * Claims a user account that is created via init user using secp
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "initUserSolPubkey",
    value: function () {
      var _initUserSolPubkey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params) {
        var userSolKeypair, _yield$this$getUserId, userAccount, tx;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (this.didInit()) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return");

              case 2:
                userSolKeypair = this.getUserKeyPair();
                _context8.next = 5;
                return this.getUserIdSeed(params.userId);

              case 5:
                _yield$this$getUserId = _context8.sent;
                userAccount = _yield$this$getUserId.userAccount;
                tx = AudiusData__namespace.initUserSolPubkey({
                  program: this.program,
                  ethPrivateKey: this.web3Manager.ownerWallet.getPrivateKeyString(),
                  message: userSolKeypair.publicKey.toBytes(),
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey
                });
                _context8.next = 10;
                return this.sendTx(tx);

              case 10:
                return _context8.abrupt("return", _context8.sent);

              case 11:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function initUserSolPubkey(_x8) {
        return _initUserSolPubkey.apply(this, arguments);
      }

      return initUserSolPubkey;
    }()
    /**
     * Creates a content node account
     * NOTE: This transaction must be signed by the admin account
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "createContentNode",
    value: function () {
      var _createContentNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(params) {
        var tx;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (this.program) {
                  _context9.next = 2;
                  break;
                }

                return _context9.abrupt("return");

              case 2:
                tx = AudiusData__namespace.createContentNode(_objectSpread2({
                  program: this.program
                }, params));
                _context9.next = 5;
                return this.sendTx(tx);

              case 5:
                return _context9.abrupt("return", _context9.sent);

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function createContentNode(_x9) {
        return _createContentNode.apply(this, arguments);
      }

      return createContentNode;
    }()
    /**
     * Updates the user replica set in the user account
     * NOTE: This transaction must be signed by a replica or the user's authority
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "updateUserReplicaSet",
    value: function () {
      var _updateUserReplicaSet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params) {
        var tx;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (!(!this.program || !this.solanaWeb3Manager.feePayerKey)) {
                  _context10.next = 2;
                  break;
                }

                return _context10.abrupt("return");

              case 2:
                tx = AudiusData__namespace.updateUserReplicaSet(_objectSpread2({
                  payer: this.solanaWeb3Manager.feePayerKey,
                  program: this.program
                }, params));
                _context10.next = 5;
                return this.sendTx(tx);

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function updateUserReplicaSet(_x10) {
        return _updateUserReplicaSet.apply(this, arguments);
      }

      return updateUserReplicaSet;
    }()
    /**
     * Create or update a content node using attestations from multiple content nodes
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "publicCreateOrUpdateContentNode",
    value: function () {
      var _publicCreateOrUpdateContentNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(params) {
        var tx;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                tx = AudiusData__namespace.publicCreateOrUpdateContentNode(_objectSpread2({
                  program: this.program,
                  payer: this.solanaWeb3Manager.feePayerKey
                }, params));
                _context11.next = 3;
                return this.sendTx(tx);

              case 3:
                return _context11.abrupt("return", _context11.sent);

              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function publicCreateOrUpdateContentNode(_x11) {
        return _publicCreateOrUpdateContentNode.apply(this, arguments);
      }

      return publicCreateOrUpdateContentNode;
    }()
    /**
     * Deletes a content node using attestations from multiple content nodes
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "publicDeleteContentNode",
    value: function () {
      var _publicDeleteContentNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(params) {
        var tx;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                tx = AudiusData__namespace.publicDeleteContentNode(_objectSpread2({
                  program: this.program,
                  payer: this.solanaWeb3Manager.feePayerKey
                }, params));
                _context12.next = 3;
                return this.sendTx(tx);

              case 3:
                return _context12.abrupt("return", _context12.sent);

              case 4:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function publicDeleteContentNode(_x12) {
        return _publicDeleteContentNode.apply(this, arguments);
      }

      return publicDeleteContentNode;
    }()
    /**
     * Creates a user account
     * NOTE: This method can only we called after the admin account is write enabled false
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "createUser",
    value: function () {
      var _createUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(params) {
        var _this = this;

        var ethAccount, userSolKeypair, _yield$this$getUserId2, userAccount, bumpSeed, baseAuthorityAccount, spSeedAddresses, tx;

        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                if (this.didInit()) {
                  _context14.next = 2;
                  break;
                }

                return _context14.abrupt("return");

              case 2:
                ethAccount = {
                  privateKey: this.web3Manager.ownerWallet.getPrivateKeyString(),
                  address: this.web3Manager.ownerWallet.getAddressString()
                };
                userSolKeypair = this.getUserKeyPair();
                _context14.next = 6;
                return this.getUserIdSeed(params.userId);

              case 6:
                _yield$this$getUserId2 = _context14.sent;
                userAccount = _yield$this$getUserId2.userAccount;
                bumpSeed = _yield$this$getUserId2.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId2.baseAuthorityAccount;
                _context14.next = 12;
                return Promise.all([params.cn1SpId, params.cn2SpId, params.cn3SpId].map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(id) {
                    return regeneratorRuntime.wrap(function _callee13$(_context13) {
                      while (1) {
                        switch (_context13.prev = _context13.next) {
                          case 0:
                            _context13.next = 2;
                            return _this.getContentNodeSeedAddress(id);

                          case 2:
                            return _context13.abrupt("return", _context13.sent);

                          case 3:
                          case "end":
                            return _context13.stop();
                        }
                      }
                    }, _callee13);
                  }));

                  return function (_x14) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 12:
                spSeedAddresses = _context14.sent;
                tx = AudiusData__namespace.createUser({
                  program: this.program,
                  payer: this.solanaWeb3Manager.feePayerKey,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  ethAccount: ethAccount,
                  userId: params.userId,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  message: userSolKeypair.publicKey.toBytes(),
                  replicaSet: [params.cn1SpId, params.cn2SpId, params.cn3SpId],
                  replicaSetBumps: spSeedAddresses.map(function (_ref2) {
                    var bumpSeed = _ref2.bumpSeed;
                    return bumpSeed;
                  }),
                  cn1: spSeedAddresses[0].derivedAddress,
                  cn2: spSeedAddresses[1].derivedAddress,
                  cn3: spSeedAddresses[2].derivedAddress,
                  metadata: params.metadata
                });
                _context14.next = 16;
                return this.sendTx(tx);

              case 16:
                return _context14.abrupt("return", _context14.sent);

              case 17:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function createUser(_x13) {
        return _createUser.apply(this, arguments);
      }

      return createUser;
    }()
    /**
     * Updates a user account
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "updateUser",
    value: function () {
      var _updateUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(params) {
        var _yield$this$getUserId3, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (this.didInit()) {
                  _context15.next = 2;
                  break;
                }

                return _context15.abrupt("return");

              case 2:
                _context15.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId3 = _context15.sent;
                userAccount = _yield$this$getUserId3.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.updateUser({
                  program: this.program,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegate: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId,
                  metadata: params.metadata
                });
                _context15.next = 10;
                return this.signTransaction(tx, userSolKeypair);

              case 10:
                _context15.next = 12;
                return this.sendTx(tx);

              case 12:
                return _context15.abrupt("return", _context15.sent);

              case 13:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function updateUser(_x15) {
        return _updateUser.apply(this, arguments);
      }

      return updateUser;
    }()
    /**
     * Updates the admin account, used for write enabled
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "updateAdmin",
    value: function () {
      var _updateAdmin = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(params) {
        var tx;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                if (!(!this.program || !this.solanaWeb3Manager.feePayerKey || !this.adminAccount)) {
                  _context16.next = 2;
                  break;
                }

                return _context16.abrupt("return");

              case 2:
                tx = AudiusData__namespace.updateAdmin(_objectSpread2({
                  program: this.program
                }, params));
                _context16.next = 5;
                return this.sendTx(tx);

              case 5:
                return _context16.abrupt("return", _context16.sent);

              case 6:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function updateAdmin(_x16) {
        return _updateAdmin.apply(this, arguments);
      }

      return updateAdmin;
    }()
  }, {
    key: "initAuthorityDelegationStatus",
    value: function () {
      var _initAuthorityDelegationStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(params) {
        var tx;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                tx = AudiusData__namespace.initAuthorityDelegationStatus(_objectSpread2({
                  program: this.program,
                  payer: this.solanaWeb3Manager.feePayerKey
                }, params));
                _context17.next = 3;
                return this.sendTx(tx);

              case 3:
                return _context17.abrupt("return", _context17.sent);

              case 4:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function initAuthorityDelegationStatus(_x17) {
        return _initAuthorityDelegationStatus.apply(this, arguments);
      }

      return initAuthorityDelegationStatus;
    }()
  }, {
    key: "revokeAuthorityDelegation",
    value: function () {
      var _revokeAuthorityDelegation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(params) {
        var tx;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                tx = AudiusData__namespace.revokeAuthorityDelegation(_objectSpread2({
                  program: this.program,
                  payer: this.solanaWeb3Manager.feePayerKey
                }, params));
                _context18.next = 3;
                return this.sendTx(tx);

              case 3:
                return _context18.abrupt("return", _context18.sent);

              case 4:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function revokeAuthorityDelegation(_x18) {
        return _revokeAuthorityDelegation.apply(this, arguments);
      }

      return revokeAuthorityDelegation;
    }()
  }, {
    key: "addUserAuthorityDelegate",
    value: function () {
      var _addUserAuthorityDelegate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(params) {
        var tx;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                tx = AudiusData__namespace.addUserAuthorityDelegate(_objectSpread2({
                  program: this.program,
                  payer: this.solanaWeb3Manager.feePayerKey
                }, params));
                _context19.next = 3;
                return this.sendTx(tx);

              case 3:
                return _context19.abrupt("return", _context19.sent);

              case 4:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function addUserAuthorityDelegate(_x19) {
        return _addUserAuthorityDelegate.apply(this, arguments);
      }

      return addUserAuthorityDelegate;
    }()
  }, {
    key: "removeUserAuthorityDelegate",
    value: function () {
      var _removeUserAuthorityDelegate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(params) {
        var tx;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                tx = AudiusData__namespace.removeUserAuthorityDelegate(_objectSpread2({
                  program: this.program,
                  payer: this.solanaWeb3Manager.feePayerKey
                }, params));
                _context20.next = 3;
                return this.sendTx(tx);

              case 3:
                return _context20.abrupt("return", _context20.sent);

              case 4:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function removeUserAuthorityDelegate(_x20) {
        return _removeUserAuthorityDelegate.apply(this, arguments);
      }

      return removeUserAuthorityDelegate;
    }()
    /**
     * Updates a user to be verified
     * NOTE: This tx must be signed by the admin verifier
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "updateIsVerified",
    value: function () {
      var _updateIsVerified = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(params) {
        var _yield$this$getUserId4, bumpSeed, baseAuthorityAccount, userAccount, tx;

        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (this.didInit()) {
                  _context21.next = 2;
                  break;
                }

                return _context21.abrupt("return");

              case 2:
                _context21.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId4 = _context21.sent;
                bumpSeed = _yield$this$getUserId4.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId4.baseAuthorityAccount;
                userAccount = _yield$this$getUserId4.userAccount;
                tx = AudiusData__namespace.updateIsVerified(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  bumpSeed: bumpSeed,
                  baseAuthorityAccount: baseAuthorityAccount,
                  userAccount: userAccount,
                  verifierPublicKey: params.verifierKeyPair.publicKey
                }, params));
                _context21.next = 11;
                return this.signTransaction(tx, params.verifierKeyPair);

              case 11:
                _context21.next = 13;
                return this.sendTx(tx);

              case 13:
                return _context21.abrupt("return", _context21.sent);

              case 14:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function updateIsVerified(_x21) {
        return _updateIsVerified.apply(this, arguments);
      }

      return updateIsVerified;
    }() // ============================= MANAGE ENTITY =============================

    /**
     * Creates a track
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "createTrack",
    value: function () {
      var _createTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(params) {
        var _yield$this$getUserId5, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                if (this.didInit()) {
                  _context22.next = 2;
                  break;
                }

                return _context22.abrupt("return");

              case 2:
                _context22.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId5 = _context22.sent;
                bumpSeed = _yield$this$getUserId5.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId5.baseAuthorityAccount;
                userAccount = _yield$this$getUserId5.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.createTrack({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId,
                  userId: params.userId,
                  id: params.id,
                  metadata: params.metadata
                });
                _context22.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context22.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context22.abrupt("return", _context22.sent);

              case 15:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function createTrack(_x22) {
        return _createTrack.apply(this, arguments);
      }

      return createTrack;
    }()
    /**
     * Updates a track
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "updateTrack",
    value: function () {
      var _updateTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(params) {
        var _yield$this$getUserId6, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (this.didInit()) {
                  _context23.next = 2;
                  break;
                }

                return _context23.abrupt("return");

              case 2:
                _context23.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId6 = _context23.sent;
                bumpSeed = _yield$this$getUserId6.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId6.baseAuthorityAccount;
                userAccount = _yield$this$getUserId6.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.updateTrack({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId,
                  userId: params.userId,
                  id: params.id,
                  metadata: params.metadata
                });
                _context23.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context23.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context23.abrupt("return", _context23.sent);

              case 15:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function updateTrack(_x23) {
        return _updateTrack.apply(this, arguments);
      }

      return updateTrack;
    }()
    /**
     * Deletes a track
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "deleteTrack",
    value: function () {
      var _deleteTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(params) {
        var _yield$this$getUserId7, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                if (this.didInit()) {
                  _context24.next = 2;
                  break;
                }

                return _context24.abrupt("return");

              case 2:
                _context24.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId7 = _context24.sent;
                bumpSeed = _yield$this$getUserId7.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId7.baseAuthorityAccount;
                userAccount = _yield$this$getUserId7.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.deleteTrack({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId,
                  userId: params.userId,
                  id: params.id
                });
                _context24.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context24.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context24.abrupt("return", _context24.sent);

              case 15:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function deleteTrack(_x24) {
        return _deleteTrack.apply(this, arguments);
      }

      return deleteTrack;
    }()
    /**
     * Creates a solana transaction for createPlaylist
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "createPlaylist",
    value: function () {
      var _createPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(params) {
        var _yield$this$getUserId8, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if (this.didInit()) {
                  _context25.next = 2;
                  break;
                }

                return _context25.abrupt("return");

              case 2:
                _context25.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId8 = _context25.sent;
                bumpSeed = _yield$this$getUserId8.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId8.baseAuthorityAccount;
                userAccount = _yield$this$getUserId8.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.createPlaylist({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId,
                  userId: params.userId,
                  id: params.id,
                  metadata: params.metadata
                });
                _context25.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context25.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context25.abrupt("return", _context25.sent);

              case 15:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function createPlaylist(_x25) {
        return _createPlaylist.apply(this, arguments);
      }

      return createPlaylist;
    }()
    /**
     * Creates a solana transaction for updatePlaylist
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "updatePlaylist",
    value: function () {
      var _updatePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(params) {
        var _yield$this$getUserId9, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                if (this.didInit()) {
                  _context26.next = 2;
                  break;
                }

                return _context26.abrupt("return");

              case 2:
                _context26.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId9 = _context26.sent;
                bumpSeed = _yield$this$getUserId9.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId9.baseAuthorityAccount;
                userAccount = _yield$this$getUserId9.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.updatePlaylist({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId,
                  userId: params.userId,
                  id: params.id,
                  metadata: params.metadata
                });
                _context26.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context26.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context26.abrupt("return", _context26.sent);

              case 15:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function updatePlaylist(_x26) {
        return _updatePlaylist.apply(this, arguments);
      }

      return updatePlaylist;
    }()
    /**
     * Creates a solana transaction for deletePlaylist
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "deletePlaylist",
    value: function () {
      var _deletePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(params) {
        var _yield$this$getUserId10, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (this.didInit()) {
                  _context27.next = 2;
                  break;
                }

                return _context27.abrupt("return");

              case 2:
                _context27.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId10 = _context27.sent;
                bumpSeed = _yield$this$getUserId10.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId10.baseAuthorityAccount;
                userAccount = _yield$this$getUserId10.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.deletePlaylist(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context27.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context27.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context27.abrupt("return", _context27.sent);

              case 15:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function deletePlaylist(_x27) {
        return _deletePlaylist.apply(this, arguments);
      }

      return deletePlaylist;
    }() // ============================= SOCIAL ACTIONS =============================

    /**
     * Creates a solana transaction for addTrackRepost
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "addTrackSave",
    value: function () {
      var _addTrackSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(params) {
        var _yield$this$getUserId11, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                if (this.didInit()) {
                  _context28.next = 2;
                  break;
                }

                return _context28.abrupt("return");

              case 2:
                _context28.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId11 = _context28.sent;
                bumpSeed = _yield$this$getUserId11.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId11.baseAuthorityAccount;
                userAccount = _yield$this$getUserId11.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.addTrackSave(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context28.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context28.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context28.abrupt("return", _context28.sent);

              case 15:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function addTrackSave(_x28) {
        return _addTrackSave.apply(this, arguments);
      }

      return addTrackSave;
    }()
    /**
     * Creates a solana transaction for deleteTrackSave
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "deleteTrackSave",
    value: function () {
      var _deleteTrackSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(params) {
        var _yield$this$getUserId12, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                if (this.didInit()) {
                  _context29.next = 2;
                  break;
                }

                return _context29.abrupt("return");

              case 2:
                _context29.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId12 = _context29.sent;
                bumpSeed = _yield$this$getUserId12.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId12.baseAuthorityAccount;
                userAccount = _yield$this$getUserId12.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.deleteTrackSave(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context29.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context29.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context29.abrupt("return", _context29.sent);

              case 15:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function deleteTrackSave(_x29) {
        return _deleteTrackSave.apply(this, arguments);
      }

      return deleteTrackSave;
    }()
    /**
     * Creates a solana transaction for addTrackRepost
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "addTrackRepost",
    value: function () {
      var _addTrackRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(params) {
        var _yield$this$getUserId13, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                if (this.didInit()) {
                  _context30.next = 2;
                  break;
                }

                return _context30.abrupt("return");

              case 2:
                _context30.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId13 = _context30.sent;
                bumpSeed = _yield$this$getUserId13.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId13.baseAuthorityAccount;
                userAccount = _yield$this$getUserId13.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.addTrackRepost(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context30.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context30.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context30.abrupt("return", _context30.sent);

              case 15:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function addTrackRepost(_x30) {
        return _addTrackRepost.apply(this, arguments);
      }

      return addTrackRepost;
    }()
    /**
     * Creates a solana transaction for deleteTrackRepost
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "deleteTrackRepost",
    value: function () {
      var _deleteTrackRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(params) {
        var _yield$this$getUserId14, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (this.didInit()) {
                  _context31.next = 2;
                  break;
                }

                return _context31.abrupt("return");

              case 2:
                _context31.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId14 = _context31.sent;
                bumpSeed = _yield$this$getUserId14.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId14.baseAuthorityAccount;
                userAccount = _yield$this$getUserId14.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.deleteTrackRepost(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context31.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context31.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context31.abrupt("return", _context31.sent);

              case 15:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function deleteTrackRepost(_x31) {
        return _deleteTrackRepost.apply(this, arguments);
      }

      return deleteTrackRepost;
    }()
    /**
     * Creates a solana transaction for addPlaylistSave
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "addPlaylistSave",
    value: function () {
      var _addPlaylistSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(params) {
        var _yield$this$getUserId15, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                if (this.didInit()) {
                  _context32.next = 2;
                  break;
                }

                return _context32.abrupt("return");

              case 2:
                _context32.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId15 = _context32.sent;
                bumpSeed = _yield$this$getUserId15.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId15.baseAuthorityAccount;
                userAccount = _yield$this$getUserId15.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.addPlaylistSave(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context32.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context32.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context32.abrupt("return", _context32.sent);

              case 15:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function addPlaylistSave(_x32) {
        return _addPlaylistSave.apply(this, arguments);
      }

      return addPlaylistSave;
    }()
    /**
     * Creates a solana transaction for deletePlaylistSave
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "deletePlaylistSave",
    value: function () {
      var _deletePlaylistSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(params) {
        var _yield$this$getUserId16, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                if (this.didInit()) {
                  _context33.next = 2;
                  break;
                }

                return _context33.abrupt("return");

              case 2:
                _context33.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId16 = _context33.sent;
                bumpSeed = _yield$this$getUserId16.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId16.baseAuthorityAccount;
                userAccount = _yield$this$getUserId16.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.deletePlaylistSave(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context33.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context33.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context33.abrupt("return", _context33.sent);

              case 15:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function deletePlaylistSave(_x33) {
        return _deletePlaylistSave.apply(this, arguments);
      }

      return deletePlaylistSave;
    }()
    /**
     * Creates a solana transaction for addPlaylistRepost
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "addPlaylistRepost",
    value: function () {
      var _addPlaylistRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(params) {
        var _yield$this$getUserId17, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                if (this.didInit()) {
                  _context34.next = 2;
                  break;
                }

                return _context34.abrupt("return");

              case 2:
                _context34.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId17 = _context34.sent;
                bumpSeed = _yield$this$getUserId17.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId17.baseAuthorityAccount;
                userAccount = _yield$this$getUserId17.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.addPlaylistRepost(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context34.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context34.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context34.abrupt("return", _context34.sent);

              case 15:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function addPlaylistRepost(_x34) {
        return _addPlaylistRepost.apply(this, arguments);
      }

      return addPlaylistRepost;
    }()
    /**
     * Creates a solana transaction for deletePlaylistRepost
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "deletePlaylistRepost",
    value: function () {
      var _deletePlaylistRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(params) {
        var _yield$this$getUserId18, bumpSeed, baseAuthorityAccount, userAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                if (this.didInit()) {
                  _context35.next = 2;
                  break;
                }

                return _context35.abrupt("return");

              case 2:
                _context35.next = 4;
                return this.getUserIdSeed(params.userId);

              case 4:
                _yield$this$getUserId18 = _context35.sent;
                bumpSeed = _yield$this$getUserId18.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId18.baseAuthorityAccount;
                userAccount = _yield$this$getUserId18.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.deletePlaylistRepost(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  bumpSeed: bumpSeed,
                  userAccount: userAccount,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context35.next = 12;
                return this.signTransaction(tx, userSolKeypair);

              case 12:
                _context35.next = 14;
                return this.sendTx(tx);

              case 14:
                return _context35.abrupt("return", _context35.sent);

              case 15:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function deletePlaylistRepost(_x35) {
        return _deletePlaylistRepost.apply(this, arguments);
      }

      return deletePlaylistRepost;
    }() // ============================= USER ACTIONS =============================

    /**
     * Creates a solana transaction for followUser
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "followUser",
    value: function () {
      var _followUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(params) {
        var _yield$this$getUserId19, sourceUserBumpSeed, baseAuthorityAccount, sourceUserAccount, _yield$this$getUserId20, targetUserBumpSeed, targetUserAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                if (this.didInit()) {
                  _context36.next = 2;
                  break;
                }

                return _context36.abrupt("return");

              case 2:
                _context36.next = 4;
                return this.getUserIdSeed(params.sourceUserId);

              case 4:
                _yield$this$getUserId19 = _context36.sent;
                sourceUserBumpSeed = _yield$this$getUserId19.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId19.baseAuthorityAccount;
                sourceUserAccount = _yield$this$getUserId19.userAccount;
                _context36.next = 10;
                return this.getUserIdSeed(params.targetUserId);

              case 10:
                _yield$this$getUserId20 = _context36.sent;
                targetUserBumpSeed = _yield$this$getUserId20.bumpSeed;
                targetUserAccount = _yield$this$getUserId20.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.followUser(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  sourceUserAccount: sourceUserAccount,
                  sourceUserBumpSeed: sourceUserBumpSeed,
                  targetUserAccount: targetUserAccount,
                  targetUserBumpSeed: targetUserBumpSeed,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context36.next = 17;
                return this.signTransaction(tx, userSolKeypair);

              case 17:
                _context36.next = 19;
                return this.sendTx(tx);

              case 19:
                return _context36.abrupt("return", _context36.sent);

              case 20:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function followUser(_x36) {
        return _followUser.apply(this, arguments);
      }

      return followUser;
    }()
    /**
     * Creates a solana transaction for unfollowUser
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "unfollowUser",
    value: function () {
      var _unfollowUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(params) {
        var _yield$this$getUserId21, sourceUserBumpSeed, baseAuthorityAccount, sourceUserAccount, _yield$this$getUserId22, targetUserBumpSeed, targetUserAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                if (this.didInit()) {
                  _context37.next = 2;
                  break;
                }

                return _context37.abrupt("return");

              case 2:
                _context37.next = 4;
                return this.getUserIdSeed(params.sourceUserId);

              case 4:
                _yield$this$getUserId21 = _context37.sent;
                sourceUserBumpSeed = _yield$this$getUserId21.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId21.baseAuthorityAccount;
                sourceUserAccount = _yield$this$getUserId21.userAccount;
                _context37.next = 10;
                return this.getUserIdSeed(params.targetUserId);

              case 10:
                _yield$this$getUserId22 = _context37.sent;
                targetUserBumpSeed = _yield$this$getUserId22.bumpSeed;
                targetUserAccount = _yield$this$getUserId22.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.unfollowUser(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  sourceUserAccount: sourceUserAccount,
                  sourceUserBumpSeed: sourceUserBumpSeed,
                  targetUserAccount: targetUserAccount,
                  targetUserBumpSeed: targetUserBumpSeed,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context37.next = 17;
                return this.signTransaction(tx, userSolKeypair);

              case 17:
                _context37.next = 19;
                return this.sendTx(tx);

              case 19:
                return _context37.abrupt("return", _context37.sent);

              case 20:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function unfollowUser(_x37) {
        return _unfollowUser.apply(this, arguments);
      }

      return unfollowUser;
    }()
    /**
     * Creates a solana transaction for subscribeUser
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "subscribeUser",
    value: function () {
      var _subscribeUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(params) {
        var _yield$this$getUserId23, sourceUserBumpSeed, baseAuthorityAccount, sourceUserAccount, _yield$this$getUserId24, targetUserBumpSeed, targetUserAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                if (this.didInit()) {
                  _context38.next = 2;
                  break;
                }

                return _context38.abrupt("return");

              case 2:
                _context38.next = 4;
                return this.getUserIdSeed(params.sourceUserId);

              case 4:
                _yield$this$getUserId23 = _context38.sent;
                sourceUserBumpSeed = _yield$this$getUserId23.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId23.baseAuthorityAccount;
                sourceUserAccount = _yield$this$getUserId23.userAccount;
                _context38.next = 10;
                return this.getUserIdSeed(params.targetUserId);

              case 10:
                _yield$this$getUserId24 = _context38.sent;
                targetUserBumpSeed = _yield$this$getUserId24.bumpSeed;
                targetUserAccount = _yield$this$getUserId24.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.subscribeUser(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  sourceUserAccount: sourceUserAccount,
                  sourceUserBumpSeed: sourceUserBumpSeed,
                  targetUserAccount: targetUserAccount,
                  targetUserBumpSeed: targetUserBumpSeed,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context38.next = 17;
                return this.signTransaction(tx, userSolKeypair);

              case 17:
                _context38.next = 19;
                return this.sendTx(tx);

              case 19:
                return _context38.abrupt("return", _context38.sent);

              case 20:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function subscribeUser(_x38) {
        return _subscribeUser.apply(this, arguments);
      }

      return subscribeUser;
    }()
    /**
     * Creates a solana transaction for unsubscribeUser
     *
     * @return {Promise<any>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "unsubscribeUser",
    value: function () {
      var _unsubscribeUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(params) {
        var _yield$this$getUserId25, sourceUserBumpSeed, baseAuthorityAccount, sourceUserAccount, _yield$this$getUserId26, targetUserBumpSeed, targetUserAccount, userSolKeypair, tx;

        return regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                if (this.didInit()) {
                  _context39.next = 2;
                  break;
                }

                return _context39.abrupt("return");

              case 2:
                _context39.next = 4;
                return this.getUserIdSeed(params.sourceUserId);

              case 4:
                _yield$this$getUserId25 = _context39.sent;
                sourceUserBumpSeed = _yield$this$getUserId25.bumpSeed;
                baseAuthorityAccount = _yield$this$getUserId25.baseAuthorityAccount;
                sourceUserAccount = _yield$this$getUserId25.userAccount;
                _context39.next = 10;
                return this.getUserIdSeed(params.targetUserId);

              case 10:
                _yield$this$getUserId26 = _context39.sent;
                targetUserBumpSeed = _yield$this$getUserId26.bumpSeed;
                targetUserAccount = _yield$this$getUserId26.userAccount;
                userSolKeypair = this.getUserKeyPair();
                tx = AudiusData__namespace.unsubscribeUser(_objectSpread2({
                  program: this.program,
                  adminAccount: this.adminAccount,
                  baseAuthorityAccount: baseAuthorityAccount,
                  sourceUserAccount: sourceUserAccount,
                  sourceUserBumpSeed: sourceUserBumpSeed,
                  targetUserAccount: targetUserAccount,
                  targetUserBumpSeed: targetUserBumpSeed,
                  userAuthorityPublicKey: userSolKeypair.publicKey,
                  userAuthorityDelegateAccount: require$$1$1v.SystemProgram.programId,
                  authorityDelegationStatusAccount: require$$1$1v.SystemProgram.programId
                }, params));
                _context39.next = 17;
                return this.signTransaction(tx, userSolKeypair);

              case 17:
                _context39.next = 19;
                return this.sendTx(tx);

              case 19:
                return _context39.abrupt("return", _context39.sent);

              case 20:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function unsubscribeUser(_x39) {
        return _unsubscribeUser.apply(this, arguments);
      }

      return unsubscribeUser;
    }()
  }]);

  return SolanaAudiusData;
}();
module.exports = SolanaAudiusData;

var solanaAudiusData = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SolanaAudiusData: SolanaAudiusData
});

var require$$2$2 = /*@__PURE__*/getAugmentedNamespace(solanaAudiusData);

var abiMap = {};

function loadABI(abiFile) {
  var contract = Utils$b.importDataContractABI(abiFile);
  abiDecoder__default["default"].addABI(contract.abi);
  abiMap[contract.contractName] = contract.abi;
}

loadABI('Registry.json');
loadABI('UserFactory.json');
loadABI('TrackFactory.json');
loadABI('DiscoveryProviderFactory.json');
loadABI('SocialFeatureFactory.json');
loadABI('PlaylistFactory.json');
loadABI('UserLibraryFactory.json');
loadABI('UserReplicaSetManager.json'); // eslint-disable-next-line @typescript-eslint/no-extraneous-class -- should just use esm

var AudiusABIDecoder = /*#__PURE__*/function () {
  function AudiusABIDecoder() {
    _classCallCheck(this, AudiusABIDecoder);
  }

  _createClass(AudiusABIDecoder, null, [{
    key: "decodeMethod",
    value: function decodeMethod(contractName, encodedABI) {
      var decoded = abiDecoder__default["default"].decodeMethod(encodedABI);

      if (!decoded) {
        throw new Error('No Audius ABI matches given data');
      } // hack around abi-decoder's lack of contract-specific support (only one global
      // namespace of functions)


      var abi = abiMap[contractName];

      if (!abi) {
        throw new Error('Unrecognized contract name');
      }

      var foundFunction;
      abi.forEach(function (item) {
        if (item.type === 'function' && item.name === decoded.name) {
          foundFunction = item;
        }
      });

      if (!foundFunction) {
        throw new Error("Unrecognized function ".concat(decoded.name, " for contract ").concat(contractName));
      }

      var paramSpecs = foundFunction.inputs;
      decoded.params.forEach(function (param, idx) {
        if (idx >= paramSpecs.length) {
          throw new Error('Extra parameter');
        }

        var paramSpec = paramSpecs[idx];

        if ((paramSpec === null || paramSpec === void 0 ? void 0 : paramSpec.name) !== param.name || paramSpec.type !== param.type) {
          throw new Error("Invalid name or value for param ".concat(paramSpec === null || paramSpec === void 0 ? void 0 : paramSpec.name, ": ").concat(paramSpec === null || paramSpec === void 0 ? void 0 : paramSpec.type));
        }
      });
      return decoded;
    }
  }, {
    key: "decodeLogs",
    value: function decodeLogs(_, logs) {
      return abiDecoder__default["default"].decodeLogs(logs);
    }
  }]);

  return AudiusABIDecoder;
}();

var ABIDecoder = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AudiusABIDecoder: AudiusABIDecoder
});

/* eslint-disable @typescript-eslint/no-var-requires */
var XMLHttpRequestRef;

if (typeof window === 'undefined' || window === null) {
  XMLHttpRequestRef = require('xmlhttprequest').XMLHttpRequest;
} else {
  XMLHttpRequestRef = window.XMLHttpRequest;
}

var DEFAULT_GAS_LIMIT = 2000000;
/** singleton class to be instantiated and persisted with every AudiusLibs */

var Web3Manager$1 = /*#__PURE__*/function () {
  function Web3Manager(web3Config, identityService, hedgehog, isServer) {
    _classCallCheck(this, Web3Manager);

    this.web3Config = web3Config;
    this.isServer = isServer; // Unset if externalWeb3 = true

    this.identityService = identityService;
    this.hedgehog = hedgehog;
    this.AudiusABIDecoder = AudiusABIDecoder;
  }

  _createClass(Web3Manager, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _web3Config$externalW, _web3Config$internalW;

        var web3Config, pkeyBuffer, storedWallet, passwordEntropy;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                web3Config = this.web3Config;

                if (web3Config) {
                  _context.next = 3;
                  break;
                }

                throw new Error('Failed to initialize Web3Manager');

              case 3:
                if (!( // External Web3
                web3Config !== null && web3Config !== void 0 && web3Config.useExternalWeb3 && (_web3Config$externalW = web3Config.externalWeb3Config) !== null && _web3Config$externalW !== void 0 && _web3Config$externalW.web3 && web3Config.externalWeb3Config.ownerWallet)) {
                  _context.next = 9;
                  break;
                }

                this.web3 = web3Config.externalWeb3Config.web3;
                this.useExternalWeb3 = true;
                this.ownerWallet = web3Config.externalWeb3Config.ownerWallet;
                _context.next = 28;
                break;

              case 9:
                if (!( // Internal Web3
                web3Config && !web3Config.useExternalWeb3 && (_web3Config$internalW = web3Config.internalWeb3Config) !== null && _web3Config$internalW !== void 0 && _web3Config$internalW.web3ProviderEndpoints)) {
                  _context.next = 27;
                  break;
                }

                // either user has external web3 but it's not configured, or doesn't have web3
                this.web3 = new web3(this.provider(web3Config.internalWeb3Config.web3ProviderEndpoints[0], 10000));
                this.useExternalWeb3 = false;

                if (!web3Config.internalWeb3Config.privateKey) {
                  _context.next = 16;
                  break;
                }

                pkeyBuffer = Buffer.from(web3Config.internalWeb3Config.privateKey, 'hex');
                this.ownerWallet = EthereumWallet__default["default"].fromPrivateKey(pkeyBuffer);
                return _context.abrupt("return");

              case 16:
                // create private key pair here if it doesn't already exist
                storedWallet = this.hedgehog.getWallet();

                if (!storedWallet) {
                  _context.next = 21;
                  break;
                }

                this.ownerWallet = storedWallet;
                _context.next = 25;
                break;

              case 21:
                passwordEntropy = "audius-dummy-pkey-".concat(Math.floor(Math.random() * 1000000));
                _context.next = 24;
                return this.hedgehog.createWalletObj(passwordEntropy);

              case 24:
                this.ownerWallet = _context.sent;

              case 25:
                _context.next = 28;
                break;

              case 27:
                throw new Error("web3ProviderEndpoint isn't passed into constructor");

              case 28:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "getWeb3",
    value: function getWeb3() {
      return this.web3;
    }
  }, {
    key: "setWeb3",
    value: function setWeb3(web3) {
      this.web3 = web3;
    }
  }, {
    key: "getWalletAddress",
    value: function getWalletAddress() {
      if (this.useExternalWeb3) {
        // Lowercase the owner wallet. Consider using the checksum address.
        // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md.
        // @ts-expect-error Wallet type doesn't have `toLowerCase` method?
        return this.ownerWallet.toLowerCase();
      } else {
        return this.ownerWallet.getAddressString();
      }
    }
  }, {
    key: "setOwnerWallet",
    value: function setOwnerWallet(ownerWallet) {
      this.ownerWallet = ownerWallet;
    }
  }, {
    key: "web3IsExternal",
    value: function web3IsExternal() {
      return this.useExternalWeb3;
    }
  }, {
    key: "getOwnerWalletPrivateKey",
    value: function getOwnerWalletPrivateKey() {
      if (this.useExternalWeb3) {
        throw new Error("Can't get owner wallet private key for external web3");
      } else {
        return this.ownerWallet.getPrivateKey();
      }
    }
    /**
     * Signs provided string data (should be timestamped).
     * @param data
     */

  }, {
    key: "sign",
    value: function () {
      var _sign = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(data) {
        var account, _this$web, _this$web2;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.useExternalWeb3) {
                  _context2.next = 11;
                  break;
                }

                account = this.getWalletAddress();

                if (!this.isServer) {
                  _context2.next = 8;
                  break;
                }

                _context2.next = 5;
                return (_this$web = this.web3) === null || _this$web === void 0 ? void 0 : _this$web.eth.sign(this.web3.utils.fromUtf8(data), account);

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 8:
                _context2.next = 10;
                return (_this$web2 = this.web3) === null || _this$web2 === void 0 ? void 0 : _this$web2.eth.personal.sign(this.web3.utils.fromUtf8(data), account, '');

              case 10:
                return _context2.abrupt("return", _context2.sent);

              case 11:
                return _context2.abrupt("return", sigUtil__default["default"].personalSign(this.getOwnerWalletPrivateKey(), {
                  data: data
                }));

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function sign(_x) {
        return _sign.apply(this, arguments);
      }

      return sign;
    }()
    /**
     * Given a data payload and signature, verifies that signature is valid, and returns
     * Ethereum wallet address used to sign data.
     * @param data information that was signed
     * @param signature hex-formatted signature of data generated by web3 personalSign method
     */

  }, {
    key: "verifySignature",
    value: function () {
      var _verifySignature = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(data, signature) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", sigUtil__default["default"].recoverPersonalSignature({
                  data: data,
                  sig: signature
                }));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function verifySignature(_x2, _x3) {
        return _verifySignature.apply(this, arguments);
      }

      return verifySignature;
    }()
  }, {
    key: "signTypedData",
    value: function () {
      var _signTypedData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(signatureData) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.useExternalWeb3) {
                  _context4.next = 6;
                  break;
                }

                _context4.next = 3;
                return ethSignTypedData(this.getWeb3(), this.getWalletAddress(), signatureData);

              case 3:
                return _context4.abrupt("return", _context4.sent);

              case 6:
                // Due to changes in ethereumjs-util's toBuffer method as of v6.2.0
                // non hex-prefixed string values are not permitted and need to be
                // provided directly as a buffer.
                // https://github.com/ethereumjs/ethereumjs-util/releases/tag/v6.2.0
                Object.keys(signatureData.message).forEach(function (key) {
                  var message = signatureData.message[key];

                  if (typeof message === 'string' && !message.startsWith('0x')) {
                    signatureData.message[key] = Buffer.from(message);
                  }
                });
                return _context4.abrupt("return", sigUtil__default["default"].signTypedData(this.ownerWallet.getPrivateKey(), {
                  data: signatureData
                }));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function signTypedData(_x4) {
        return _signTypedData.apply(this, arguments);
      }

      return signTypedData;
    }()
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(contractMethod, contractRegistryKey, contractAddress) {
        var _this = this;

        var txRetries,
            txGasLimit,
            gasLimit,
            encodedABI,
            response,
            receipt,
            events,
            decoded,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                txRetries = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : 5;
                txGasLimit = _args6.length > 4 ? _args6[4] : undefined;

                if (!(txGasLimit !== null && txGasLimit !== void 0)) {
                  _context6.next = 6;
                  break;
                }

                _context6.t0 = txGasLimit;
                _context6.next = 9;
                break;

              case 6:
                _context6.next = 8;
                return estimateGas({
                  method: contractMethod,
                  gasLimitMaximum: DEFAULT_GAS_LIMIT
                });

              case 8:
                _context6.t0 = _context6.sent;

              case 9:
                gasLimit = _context6.t0;

                if (!this.useExternalWeb3) {
                  _context6.next = 16;
                  break;
                }

                _context6.next = 13;
                return contractMethod.send({
                  from: this.ownerWallet,
                  gas: gasLimit
                });

              case 13:
                return _context6.abrupt("return", _context6.sent);

              case 16:
                encodedABI = contractMethod.encodeABI();
                _context6.next = 19;
                return retry__default["default"]( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                  return regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return _this.identityService.relay(contractRegistryKey, contractAddress, _this.ownerWallet.getAddressString(), encodedABI, gasLimit);

                        case 2:
                          return _context5.abrupt("return", _context5.sent);

                        case 3:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                })), {
                  // Retry function 5x by default
                  // 1st retry delay = 500ms, 2nd = 1500ms, 3rd...nth retry = 4000 ms (capped)
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: txRetries,
                  onRetry: function onRetry(err) {
                    if (err) {
                      console.log( // eslint-disable-next-line @typescript-eslint/no-base-to-string
                      "libs web3Manager transaction send retry error : ".concat(err));
                    }
                  }
                });

              case 19:
                response = _context6.sent;
                receipt = response.receipt; // interestingly, using contractMethod.send from Metamask's web3 (eg. like in the if
                // above) parses the event log into an 'events' key on the transaction receipt and
                // blows away the 'logs' key. However, using sendRawTransaction as our
                // relayer does, returns only the logs. Here, we replicate the part of the 'events'
                // key that our code consumes, but we may want to change our functions to consume
                // this data in a different way in future (this parsing is messy).
                // More on Metamask's / Web3.js' behavior here:
                // https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#methods-mymethod-send

                if (receipt.logs) {
                  events = {}; // TODO: decodeLogs appears to return DecodedLog, not DecodedLog[] so maybe a type/version issue

                  decoded = this.AudiusABIDecoder.decodeLogs(contractRegistryKey, receipt.logs);
                  decoded.forEach(function (evt) {
                    var returnValues = {};
                    evt.events.forEach(function (arg) {
                      returnValues[arg.name] = arg.value;
                    });
                    var eventLog = {
                      returnValues: returnValues
                    };
                    events[evt.name] = eventLog;
                  });
                  receipt.events = events;
                }

                return _context6.abrupt("return", response.receipt);

              case 23:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function sendTransaction(_x5, _x6, _x7) {
        return _sendTransaction.apply(this, arguments);
      }

      return sendTransaction;
    }() // TODO - Remove this. Adapted from https://github.com/raiden-network/webui/pull/51/files
    // Vendored code below

  }, {
    key: "provider",
    value: function provider(url, timeout) {
      return this.monkeyPatchProvider(new web3.providers.HttpProvider(url, {
        timeout: timeout
      }));
    } // TODO: Workaround for https://github.com/ethereum/web3.js/issues/1803 it should be immediately removed
    // as soon as the issue is fixed upstream.
    // Issue is also documented here https://github.com/ethereum/web3.js/issues/1802

  }, {
    key: "monkeyPatchProvider",
    value: function monkeyPatchProvider(httpProvider) {
      // @ts-expect-error overriding a private method not appearing in types
      override(httpProvider, '_prepareRequest', function () {
        return function () {
          var request = new XMLHttpRequestRef();
          request.open('POST', this.host, true);
          request.setRequestHeader('Content-Type', 'application/json');
          request.timeout = this.timeout && this.timeout !== 1 ? this.timeout : 0;

          if (this.headers) {
            this.headers.forEach(function (header) {
              request.setRequestHeader(header.name, header.value);
            });
          }

          return request;
        };
      });
      return httpProvider;
    }
  }]);

  return Web3Manager;
}();
/** Browser and testing-compatible signTypedData */

var ethSignTypedData = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(web3, wallet, signatureData) {
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return new Promise(function (resolve, reject) {
              var processedSignatureData = signatureData;
              var method; // @ts-expect-error isMetaMask not captured by web3Provider

              // @ts-expect-error isMetaMask not captured by web3Provider
              if (web3.currentProvider.isMetaMask === true) {
                method = 'eth_signTypedData_v3';
                processedSignatureData = JSON.stringify(signatureData);
              } else {
                method = 'eth_signTypedData'; // fix per https://github.com/ethereum/web3.js/issues/1119
              }
              web3.currentProvider.send({
                method: method,
                params: [wallet, processedSignatureData],
                // @ts-expect-error from not in JsonRpcPayload
                from: wallet
              }, function (err, result) {
                if (err) {
                  reject(err);
                } else if (result !== null && result !== void 0 && result.error) {
                  reject(result === null || result === void 0 ? void 0 : result.error);
                } else {
                  resolve(result === null || result === void 0 ? void 0 : result.result);
                }
              });
            });

          case 2:
            return _context7.abrupt("return", _context7.sent);

          case 3:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function ethSignTypedData(_x8, _x9, _x10) {
    return _ref2.apply(this, arguments);
  };
}();

function override(object, methodName, callback) {
  object[methodName] = callback(object[methodName]);
}

var web3Manager = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Web3Manager: Web3Manager$1
});

var require$$3 = /*@__PURE__*/getAugmentedNamespace(web3Manager);

var AudiusTokenClient = /*#__PURE__*/function () {
  function AudiusTokenClient(ethWeb3Manager, contractABI, contractAddress) {
    _classCallCheck(this, AudiusTokenClient);

    this.ethWeb3Manager = ethWeb3Manager;
    this.contractABI = contractABI;
    this.contractAddress = contractAddress;
    this.web3 = this.ethWeb3Manager.getWeb3();
    this.AudiusTokenContract = new this.web3.eth.Contract(this.contractABI, this.contractAddress);
    this.bustCacheNonce = 0;
  }
  /* ------- GETTERS ------- */


  _createClass(AudiusTokenClient, [{
    key: "bustCache",
    value: function () {
      var _bustCache = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.bustCacheNonce += 1;

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bustCache() {
        return _bustCache.apply(this, arguments);
      }

      return bustCache;
    }()
  }, {
    key: "balanceOf",
    value: function () {
      var _balanceOf = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(account) {
        var args, balance;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.bustCacheNonce > 0) {
                  args = {
                    _audiusBustCache: this.bustCacheNonce
                  };
                }

                _context2.next = 3;
                return this.AudiusTokenContract.methods.balanceOf(account).call(args);

              case 3:
                balance = _context2.sent;
                return _context2.abrupt("return", this.web3.utils.toBN(balance));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function balanceOf(_x) {
        return _balanceOf.apply(this, arguments);
      }

      return balanceOf;
    }() // Get the name of the contract

  }, {
    key: "name",
    value: function () {
      var _name = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var name;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.AudiusTokenContract.methods.name().call();

              case 2:
                name = _context3.sent;
                return _context3.abrupt("return", name);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function name() {
        return _name.apply(this, arguments);
      }

      return name;
    }() // Get the name of the contract

  }, {
    key: "nonces",
    value: function () {
      var _nonces = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(wallet) {
        var nonce, number;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.AudiusTokenContract.methods.nonces(wallet).call({
                  _audiusBustCache: Date.now()
                });

              case 2:
                nonce = _context4.sent;
                number = this.web3.utils.toBN(nonce).toNumber();
                return _context4.abrupt("return", number);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function nonces(_x2) {
        return _nonces.apply(this, arguments);
      }

      return nonces;
    }()
    /* ------- SETTERS ------- */

  }, {
    key: "transfer",
    value: function () {
      var _transfer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(recipient, amount) {
        var contractMethod, tx;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                contractMethod = this.AudiusTokenContract.methods.transfer(recipient, amount);
                _context5.next = 3;
                return this.ethWeb3Manager.sendTransaction(contractMethod);

              case 3:
                tx = _context5.sent;
                return _context5.abrupt("return", {
                  txReceipt: tx
                });

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function transfer(_x3, _x4) {
        return _transfer.apply(this, arguments);
      }

      return transfer;
    }()
  }, {
    key: "transferFrom",
    value: function () {
      var _transferFrom = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(owner, recipient, relayer, amount) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                method = this.AudiusTokenContract.methods.transferFrom(owner, recipient, amount);
                _context6.next = 3;
                return this.ethWeb3Manager.relayTransaction(method, this.contractAddress, owner, relayer,
                /* retries */
                0);

              case 3:
                tx = _context6.sent;
                return _context6.abrupt("return", {
                  txReceipt: tx
                });

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function transferFrom(_x5, _x6, _x7, _x8) {
        return _transferFrom.apply(this, arguments);
      }

      return transferFrom;
    }() // Permit meta transaction of balance transfer

  }, {
    key: "permit",
    value: function () {
      var _permit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(owner, // address
      spender, // address
      value, // uint
      deadline, // uint
      v, // uint8
      r, // bytes32
      s // bytes32
      ) {
        var contractMethod, tx;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                contractMethod = this.AudiusTokenContract.methods.permit(owner, spender, value, deadline, v, r, s);
                _context7.next = 3;
                return this.ethWeb3Manager.relayTransaction(contractMethod, this.contractAddress, owner, spender,
                /* retries */
                0);

              case 3:
                tx = _context7.sent;
                return _context7.abrupt("return", tx);

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function permit(_x9, _x10, _x11, _x12, _x13, _x14, _x15) {
        return _permit.apply(this, arguments);
      }

      return permit;
    }() // Allow spender to withdraw from calling account up to value amount
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md

  }, {
    key: "approve",
    value: function () {
      var _approve = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(spender, value) {
        var privateKey,
            contractMethod,
            tx,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                privateKey = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : null;
                contractMethod = this.AudiusTokenContract.methods.approve(spender, value);

                if (!(privateKey === null)) {
                  _context8.next = 8;
                  break;
                }

                _context8.next = 5;
                return this.ethWeb3Manager.sendTransaction(contractMethod);

              case 5:
                tx = _context8.sent;
                _context8.next = 11;
                break;

              case 8:
                _context8.next = 10;
                return this.ethWeb3Manager.sendTransaction(contractMethod, this.contractAddress, privateKey);

              case 10:
                tx = _context8.sent;

              case 11:
                return _context8.abrupt("return", {
                  txReceipt: tx
                });

              case 12:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function approve(_x16, _x17) {
        return _approve.apply(this, arguments);
      }

      return approve;
    }()
  }, {
    key: "approveProxyTokens",
    value: function () {
      var _approveProxyTokens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(owner, spender, value, relayer) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                method = this.AudiusTokenContract.methods.approve(spender, value);
                _context9.next = 3;
                return this.ethWeb3Manager.relayTransaction(method, this.contractAddress, owner, relayer,
                /* retries */
                0);

              case 3:
                tx = _context9.sent;
                return _context9.abrupt("return", {
                  txReceipt: tx
                });

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function approveProxyTokens(_x18, _x19, _x20, _x21) {
        return _approveProxyTokens.apply(this, arguments);
      }

      return approveProxyTokens;
    }()
  }]);

  return AudiusTokenClient;
}();

var RegistryClient$2 = /*#__PURE__*/function () {
  function RegistryClient(web3Manager, contractABI, contractAddress) {
    _classCallCheck(this, RegistryClient);

    this.web3Manager = web3Manager;
    this.contractABI = contractABI;
    this.contractAddress = contractAddress;
    this.web3 = this.web3Manager.getWeb3();
    this.Registry = new this.web3.eth.Contract(contractABI, contractAddress);
  }

  _createClass(RegistryClient, [{
    key: "getContract",
    value: function () {
      var _getContract = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(contractRegistryKey) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                Utils$b.checkStrLen(contractRegistryKey, 32);
                return _context.abrupt("return", this.Registry.methods.getContract(Utils$b.utf8ToHex(contractRegistryKey)).call());

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getContract(_x) {
        return _getContract.apply(this, arguments);
      }

      return getContract;
    }()
  }]);

  return RegistryClient;
}();

var DECISION_TREE_STATE$1;

(function (DECISION_TREE_STATE) {
  DECISION_TREE_STATE["CHECK_SHORT_CIRCUIT"] = "Check Short Circuit";
  DECISION_TREE_STATE["GET_ALL_SERVICES"] = "Get All Services";
  DECISION_TREE_STATE["FILTER_TO_WHITELIST"] = "Filter To Whitelist";
  DECISION_TREE_STATE["FILTER_FROM_BLACKLIST"] = "Filter From Blacklist";
  DECISION_TREE_STATE["FILTER_OUT_KNOWN_UNHEALTHY"] = "Filter Out Known Unhealthy";
  DECISION_TREE_STATE["GET_SELECTION_ROUND"] = "Get Selection Round";
  DECISION_TREE_STATE["NO_SERVICES_LEFT_TO_TRY"] = "No Services Left To Try";
  DECISION_TREE_STATE["SELECTED_FROM_BACKUP"] = "Selected From Backup";
  DECISION_TREE_STATE["FAILED_AND_RESETTING"] = "Failed Everything -- Resetting";
  DECISION_TREE_STATE["ROUND_FAILED_RETRY"] = "Round Failed Retry";
  DECISION_TREE_STATE["MADE_A_SELECTION"] = "Made A Selection";
  DECISION_TREE_STATE["RACED_AND_FOUND_BEST"] = "Raced And Found Best";
})(DECISION_TREE_STATE$1 || (DECISION_TREE_STATE$1 = {}));

function isVerbose(service) {
  return typeof service !== 'string';
}
/**
 * A class that assists with autoselecting services.
 * `ServiceSelection` is intended to be overridden with further
 * business logic that a particular sevice might preference.
 *
 * The general use case is as follows:
 *
 * ```
 *
 * const selector = new ServiceSelection({
 *   getServices: ethContracts.getDiscoveryProviders()
 * })
 *
 * const service = await selector.select()
 *
 * ```
 *
 * This class operates by taking a list of services and
 * round-robin makes requests at them until a suitable one is found.
 *
 * Two types of "bad" services are defined below:
 *  - Unhealthy: this service is bad and should not be used
 *  - Backup: this service is bad, but if we can't find anything better, maybe use it
 *
 * Classes that extend `ServiceSelection` can choose to implement custom logic on top
 * of them and is generally how this class is intended to be used.
 */


var ServiceSelection = /*#__PURE__*/function () {
  function ServiceSelection(_ref) {
    var blacklist = _ref.blacklist,
        whitelist = _ref.whitelist,
        getServices = _ref.getServices,
        _ref$maxConcurrentReq = _ref.maxConcurrentRequests,
        maxConcurrentRequests = _ref$maxConcurrentReq === void 0 ? 6 : _ref$maxConcurrentReq,
        _ref$requestTimeout = _ref.requestTimeout,
        requestTimeout = _ref$requestTimeout === void 0 ? 30 * 1000 : _ref$requestTimeout,
        _ref$unhealthyTTL = _ref.unhealthyTTL,
        unhealthyTTL = _ref$unhealthyTTL === void 0 ? 60 * 60 * 1000 : _ref$unhealthyTTL,
        _ref$backupsTTL = _ref.backupsTTL,
        backupsTTL = _ref$backupsTTL === void 0 ? 2 * 60 * 1000 : _ref$backupsTTL;

    _classCallCheck(this, ServiceSelection);

    this.unhealthyCleanupTimeout = null;
    this.backupCleanupTimeout = null; // For Creator Node selection

    this.blacklist = blacklist;
    this.whitelist = whitelist;
    this.getServices = getServices;
    this.maxConcurrentRequests = maxConcurrentRequests;
    this.requestTimeout = requestTimeout;
    this.unhealthyTTL = unhealthyTTL;
    this.backupsTTL = backupsTTL; // Truly "unhealthy" services. Should not ever be picked.

    this.unhealthy = new Set([]); // Selectable services but not optimal. Will be picked as a last resort.

    this.backups = {}; // Total number of services attempted

    this.totalAttempts = 0; // The decision tree path that was taken. Reset on each new selection.

    this.decisionTree = [];
  }
  /**
   * Selects a service
   * @param reset if reset is true, clear the decision tree
   */
  // we need any type here to allow sub-classes to more strictly type return type


  _createClass(ServiceSelection, [{
    key: "select",
    value: function () {
      var _select = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var reset,
            shortcircuit,
            services,
            filteredServices,
            round,
            backup,
            _yield$this$race,
            best,
            errored,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                reset = _args.length > 0 && _args[0] !== undefined ? _args[0] : true;

                if (reset) {
                  this.decisionTree = [];
                } // If a short circuit is provided, take it. Don't check it, just use it.


                shortcircuit = this.shortcircuit();
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE$1.CHECK_SHORT_CIRCUIT,
                  val: shortcircuit
                }); // If there is a shortcircuit defined and we have not blacklisted it, pick it

                if (!(shortcircuit && (!this.blacklist || !this.blacklist.has(shortcircuit)))) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", shortcircuit);

              case 6:
                _context.next = 8;
                return this.getServices();

              case 8:
                services = _context.sent;
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE$1.GET_ALL_SERVICES,
                  val: services
                }); // If a whitelist is provided, filter down to it

                if (this.whitelist) {
                  services = this.filterToWhitelist(services);
                  this.decisionTree.push({
                    stage: DECISION_TREE_STATE$1.FILTER_TO_WHITELIST,
                    val: services
                  });
                } // if a blacklist is provided, filter out services in the list


                if (this.blacklist) {
                  services = this.filterFromBlacklist(services);
                  this.decisionTree.push({
                    stage: DECISION_TREE_STATE$1.FILTER_FROM_BLACKLIST,
                    val: services
                  });
                } // Filter out anything we know is already unhealthy


                filteredServices = this.filterOutKnownUnhealthy(services);
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE$1.FILTER_OUT_KNOWN_UNHEALTHY,
                  val: filteredServices
                }); // Randomly sample a "round" to test

                round = this.getSelectionRound(filteredServices);
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE$1.GET_SELECTION_ROUND,
                  val: round
                });
                this.totalAttempts += round.length; // If there are no services left to try, either pick a backup or return null

                if (!(filteredServices.length === 0)) {
                  _context.next = 31;
                  break;
                }

                this.decisionTree.push({
                  stage: DECISION_TREE_STATE$1.NO_SERVICES_LEFT_TO_TRY
                });

                if (!(this.getBackupsSize() > 0)) {
                  _context.next = 27;
                  break;
                }

                _context.next = 22;
                return this.selectFromBackups();

              case 22:
                backup = _context.sent;
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE$1.SELECTED_FROM_BACKUP,
                  val: backup
                });
                return _context.abrupt("return", backup);

              case 27:
                // Nothing could be found that was healthy.
                // Reset everything we know so that we might try again.
                this.unhealthy = new Set([]);
                this.backups = {};
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE$1.FAILED_AND_RESETTING
                });
                return _context.abrupt("return", null);

              case 31:
                _context.next = 33;
                return this.race(round);

              case 33:
                _yield$this$race = _context.sent;
                best = _yield$this$race.best;
                errored = _yield$this$race.errored;
                // Mark all the errored ones as unhealthy
                errored.forEach(function (e) {
                  if (e) {
                    _this.addUnhealthy(e);
                  }
                }); // Trigger a cleanup event for all of the unhealthy and backup services,
                // so they can get retried in the future

                this.triggerCleanup(); // Recursively try this selection function if we didn't find something

                if (best) {
                  _context.next = 43;
                  break;
                }

                this.decisionTree.push({
                  stage: DECISION_TREE_STATE$1.ROUND_FAILED_RETRY
                });
                _context.next = 42;
                return this.select(
                /* reset */
                false);

              case 42:
                return _context.abrupt("return", _context.sent);

              case 43:
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE$1.MADE_A_SELECTION,
                  val: best
                }); // If we made it this far, we found the best service! (of the rounds we tried)

                return _context.abrupt("return", best);

              case 45:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function select() {
        return _select.apply(this, arguments);
      }

      return select;
    }()
    /**
     * Finds all selectable services (respecting whitelist, health checks & timeouts).
     * Note: this method is potentially slow.
     * If you need just a single service, prefer calling `.select()`
     * @param {boolean} verbose whether or not to return full services metadata
     * @param {Set} whitelist a whitelist to override the set of endpoints
     */

  }, {
    key: "findAll",
    value: function () {
      var _findAll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _this2 = this;

        var _ref2,
            _ref2$verbose,
            verbose,
            _ref2$whitelist,
            whitelist,
            services,
            urlMap,
            results,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref2 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, _ref2$verbose = _ref2.verbose, verbose = _ref2$verbose === void 0 ? false : _ref2$verbose, _ref2$whitelist = _ref2.whitelist, whitelist = _ref2$whitelist === void 0 ? this.whitelist : _ref2$whitelist;
                _context2.next = 3;
                return this.getServices({
                  verbose: verbose
                });

              case 3:
                services = _context2.sent;

                // If a whitelist is provided, filter down to it
                if (whitelist) {
                  services = services.filter(function (service) {
                    return whitelist.has(isVerbose(service) ? service.endpoint : service);
                  });
                } // Key the services by their health check endpoint


                urlMap = services.reduce(function (urlMap, service) {
                  urlMap[ServiceSelection.getHealthCheckEndpoint(isVerbose(service) ? service.endpoint : service)] = service;
                  return urlMap;
                }, {});
                _context2.prev = 6;
                _context2.next = 9;
                return allRequests({
                  urlMap: urlMap,
                  timeout: this.requestTimeout,
                  validationCheck: function validationCheck(resp) {
                    return _this2.isHealthy(resp, urlMap);
                  }
                });

              case 9:
                results = _context2.sent;
                return _context2.abrupt("return", results);

              case 13:
                _context2.prev = 13;
                _context2.t0 = _context2["catch"](6);
                console.error(_context2.t0);
                return _context2.abrupt("return", []);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 13]]);
      }));

      function findAll() {
        return _findAll.apply(this, arguments);
      }

      return findAll;
    }()
    /** Triggers a clean up of unhealthy and backup services so they can be retried later */

  }, {
    key: "triggerCleanup",
    value: function triggerCleanup() {
      var _this3 = this;

      if (this.unhealthyCleanupTimeout) {
        clearTimeout(this.unhealthyCleanupTimeout);
      }

      if (this.backupCleanupTimeout) {
        clearTimeout(this.backupCleanupTimeout);
      }

      this.unhealthyCleanupTimeout = setTimeout(function () {
        _this3.clearUnhealthy();
      }, this.unhealthyTTL);
      this.backupCleanupTimeout = setTimeout(function () {
        _this3.clearBackups();
      }, this.backupsTTL);
    }
  }, {
    key: "clearUnhealthy",
    value: function clearUnhealthy() {
      this.unhealthy = new Set([]);
    }
  }, {
    key: "clearBackups",
    value: function clearBackups() {
      this.backups = {};
    }
    /** A short-circuit. If overriden, can be used to skip selection (which could be slow) */

  }, {
    key: "shortcircuit",
    value: function shortcircuit() {
      return null;
    }
    /**
     * Filter out services that are in the blacklist
     * @param services endpoints
     */

  }, {
    key: "filterFromBlacklist",
    value: function filterFromBlacklist(services) {
      var _this4 = this;

      return services.filter(function (s) {
        var _this4$blacklist;

        return !((_this4$blacklist = _this4.blacklist) !== null && _this4$blacklist !== void 0 && _this4$blacklist.has(s));
      });
    }
    /** Filter down services to those in the whitelist */

  }, {
    key: "filterToWhitelist",
    value: function filterToWhitelist(services) {
      var _this5 = this;

      return services.filter(function (s) {
        var _this5$whitelist;

        return (_this5$whitelist = _this5.whitelist) === null || _this5$whitelist === void 0 ? void 0 : _this5$whitelist.has(s);
      });
    }
    /** Filter out known unhealthy services from the provided */

  }, {
    key: "filterOutKnownUnhealthy",
    value: function filterOutKnownUnhealthy(services) {
      var _this6 = this;

      return services.filter(function (s) {
        return !_this6.unhealthy.has(s);
      });
    }
    /** Given a list of services, samples maxConcurrentRequests from them */

  }, {
    key: "getSelectionRound",
    value: function getSelectionRound(services) {
      return require$$0$4.sampleSize(services, this.maxConcurrentRequests);
    }
    /** Gets the total number of attempts we've made this instantiation */

  }, {
    key: "getTotalAttempts",
    value: function getTotalAttempts() {
      return this.totalAttempts;
    }
    /** Where does the health check for this type of service live */

  }, {
    key: "isHealthy",
    value:
    /**
     * What the criteria is for a healthy service
     * @param response axios response
     * @param {{ [key: string]: string}} urlMap health check urls mapped to their cannonical url
     * e.g. https://discoveryprovider.audius.co/health_check => https://discoveryprovider.audius.co
     */
    function isHealthy(response, _urlMap) {
      return response.status === 200;
    }
    /** Races requests against each other with provided timeouts and health checks */

  }, {
    key: "race",
    value: function () {
      var _race = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(services) {
        var _this7 = this;

        var serviceMap, best, _yield$raceRequests, errored;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // Key the services by their health check endpoint
                serviceMap = services.reduce(function (acc, s) {
                  acc[ServiceSelection.getHealthCheckEndpoint(s)] = s;
                  return acc;
                }, {});
                best = null;
                _context3.prev = 2;
                _context3.next = 5;
                return raceRequests$1(Object.keys(serviceMap), function (url) {
                  best = serviceMap[url];
                }, {},
                /* timeout */
                this.requestTimeout,
                /* timeBetweenRequests */
                0,
                /* validationCheck */
                function (resp) {
                  return _this7.isHealthy(resp, serviceMap);
                });

              case 5:
                _yield$raceRequests = _context3.sent;
                errored = _yield$raceRequests.errored;
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE$1.RACED_AND_FOUND_BEST,
                  val: best
                });
                return _context3.abrupt("return", {
                  best: best,
                  errored: errored.map(function (e) {
                    var _e$config$url;

                    return serviceMap[(_e$config$url = e.config.url) !== null && _e$config$url !== void 0 ? _e$config$url : ''];
                  })
                });

              case 11:
                _context3.prev = 11;
                _context3.t0 = _context3["catch"](2);
                return _context3.abrupt("return", {
                  best: null,
                  errored: []
                });

              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 11]]);
      }));

      function race(_x) {
        return _race.apply(this, arguments);
      }

      return race;
    }()
    /** Adds a service to the unhealthy set */

  }, {
    key: "addUnhealthy",
    value: function addUnhealthy(service) {
      this.unhealthy.add(service);
    }
    /** Gets unhealthy set size */

  }, {
    key: "getUnhealthySize",
    value: function getUnhealthySize() {
      return this.unhealthy.size;
    }
    /**
     * Removes from unhealthy set
     * @param key service endpoint
     */

  }, {
    key: "removeFromUnhealthy",
    value: function removeFromUnhealthy(key) {
      if (this.unhealthy.has(key)) this.unhealthy["delete"](key);
    }
    /**
     * Adds a service to the list of backups
     * @param service the service to add
     * @param response the services response. This can be used to weigh various
     * backups against eachother
     */

  }, {
    key: "addBackup",
    value: function addBackup(service, response) {
      this.backups[service] = response;
    }
    /**
     * Controls how a backup is picked. Overriding methods may choose to use the backup's response.
     * e.g. pick a backup that's the fewest versions behind
     */

  }, {
    key: "selectFromBackups",
    value: function () {
      var _selectFromBackups = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", Object.keys(this.backups)[0]);

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function selectFromBackups() {
        return _selectFromBackups.apply(this, arguments);
      }

      return selectFromBackups;
    }()
    /**
     * Removes from backups
     * @param key service endpoint
     */

  }, {
    key: "removeFromBackups",
    value: function removeFromBackups(key) {
      if (Object.prototype.hasOwnProperty.call(this.backups, key)) // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete this.backups[key];
    }
    /**
     * Returns the size of backups
     */

  }, {
    key: "getBackupsSize",
    value: function getBackupsSize() {
      return Object.keys(this.backups).length;
    }
  }], [{
    key: "getHealthCheckEndpoint",
    value: function getHealthCheckEndpoint(service) {
      return "".concat(service, "/health_check");
    }
  }]);

  return ServiceSelection;
}();

/**
 * This class provides the logic to select a healthy gateway
 */

var ProviderSelection$1 = /*#__PURE__*/function (_ServiceSelection) {
  _inherits(ProviderSelection, _ServiceSelection);

  var _super = _createSuper(ProviderSelection);

  function ProviderSelection() {
    var _this;

    var services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, ProviderSelection);

    _this = _super.call(this, {
      whitelist: new Set(),
      getServices: function () {
        var _getServices = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", _this.services);

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function getServices() {
          return _getServices.apply(this, arguments);
        }

        return getServices;
      }()
    });
    _this.services = services;
    return _this;
  }
  /**
   * Filters out previously tried providers, and then initializes the client
   * (ContractClient, RegistryClient) with a healthy POA provider.
   *
   * @param client object used for making transaction calls
   */


  _createClass(ProviderSelection, [{
    key: "select",
    value: function () {
      var _select = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(client) {
        var web3Manager, filteredServices, web3;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                web3Manager = client.web3Manager;
                _context2.t0 = this;
                _context2.next = 4;
                return this.getServices();

              case 4:
                _context2.t1 = _context2.sent;
                filteredServices = _context2.t0.filterOutKnownUnhealthy.call(_context2.t0, _context2.t1);
                web3 = new require$$0__default["default"](web3Manager.provider(filteredServices[0], 10000));
                web3Manager.setWeb3(web3);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function select(_x) {
        return _select.apply(this, arguments);
      }

      return select;
    }()
  }, {
    key: "getServicesSize",
    value: function getServicesSize() {
      return this.services.length;
    }
  }]);

  return ProviderSelection;
}(ServiceSelection);

var ProviderSelection$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ProviderSelection: ProviderSelection$1
});

var CONTRACT_INITIALIZING_INTERVAL = 100;
var CONTRACT_INITIALIZING_TIMEOUT = 10000;
var CONTRACT_INIT_MAX_ATTEMPTS = 5;
var METHOD_CALL_MAX_RETRIES = 5;
/*
 * Base class for instantiating contracts.
 * Performs a single init of the eth contract the first
 * time a method on the contract is invoked.
 */

var ContractClient$7 = /*#__PURE__*/function () {
  function ContractClient(web3Manager, contractABI, contractRegistryKey, getRegistryAddress) {
    var logger = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : console;
    var contractAddress = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

    _classCallCheck(this, ContractClient);

    this.web3Manager = web3Manager;
    this.contractABI = contractABI;
    this.contractRegistryKey = contractRegistryKey;
    this.getRegistryAddress = getRegistryAddress;
    this.logger = logger; // Once initialized, contract address and contract are set up

    this._contractAddress = contractAddress;
    this._contract = null; // Initialization setup

    this._isInitialized = false;
    this._isInitializing = false;
    this._initAttempts = 0; // Initializing this.providerSelector for POA provider fallback logic

    if (this.web3Manager instanceof Web3Manager$1 && !this.web3Manager.web3Config.useExternalWeb3) {
      var providerEndpoints = this.web3Manager.web3Config.internalWeb3Config.web3ProviderEndpoints;
      this.providerSelector = new ProviderSelection$1(providerEndpoints);
    } else {
      this.providerSelector = null;
    }
  }
  /** Inits the contract if necessary */


  _createClass(ContractClient, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var interval, web3, selectNewEndpoint;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._isInitialized) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                if (!this._isInitializing) {
                  _context.next = 7;
                  break;
                }

                _context.next = 5;
                return new Promise(function (resolve, reject) {
                  interval = setInterval(function () {
                    if (_this._isInitialized) resolve();
                  }, CONTRACT_INITIALIZING_INTERVAL);
                  setTimeout(function () {
                    reject(new Error('[ContractClient:init()] Initialization timeout'));
                  }, CONTRACT_INITIALIZING_TIMEOUT);
                });

              case 5:
                clearInterval(interval);
                return _context.abrupt("return");

              case 7:
                this._isInitializing = true;
                _context.prev = 8;

                if (this._contractAddress) {
                  _context.next = 16;
                  break;
                }

                _context.next = 12;
                return this.getRegistryAddress(this.contractRegistryKey);

              case 12:
                this._contractAddress = _context.sent;

                if (!(this._contractAddress === '0x0000000000000000000000000000000000000000')) {
                  _context.next = 16;
                  break;
                }

                this._isInitializing = false;
                throw new Error("Failed retrieve address for ".concat(this.contractRegistryKey));

              case 16:
                web3 = this.web3Manager.getWeb3();
                this._contract = new web3.eth.Contract(this.contractABI, this._contractAddress);
                this._isInitializing = false;
                this._isInitialized = !!this._contractAddress;
                _context.next = 32;
                break;

              case 22:
                _context.prev = 22;
                _context.t0 = _context["catch"](8);

                if (!(++this._initAttempts >= CONTRACT_INIT_MAX_ATTEMPTS)) {
                  _context.next = 27;
                  break;
                }

                this.logger.error("Failed to initialize ".concat(this.contractRegistryKey, ". Max attempts exceeded."));
                return _context.abrupt("return");

              case 27:
                selectNewEndpoint = !!this.providerSelector;
                this.logger.error("Failed to initialize ".concat(this.contractRegistryKey, " on attempt #").concat(this._initAttempts, ". Retrying with selectNewEndpoint=").concat(selectNewEndpoint));
                this._isInitializing = false;
                _context.next = 32;
                return this.retryInit(selectNewEndpoint);

              case 32:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[8, 22]]);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "retryInit",
    value: function () {
      var _retryInit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var selectNewEndpoint,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                selectNewEndpoint = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : true;
                _context2.prev = 1;

                if (!selectNewEndpoint) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 5;
                return this.selectNewEndpoint();

              case 5:
                _context2.next = 7;
                return this.init();

              case 7:
                _context2.next = 12;
                break;

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](1);
                this.logger.error(_context2.t0 === null || _context2.t0 === void 0 ? void 0 : _context2.t0.message);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 9]]);
      }));

      function retryInit() {
        return _retryInit.apply(this, arguments);
      }

      return retryInit;
    }()
    /**
     * Adds current provider into unhealthy set and selects the next healthy provider
     */

  }, {
    key: "selectNewEndpoint",
    value: function () {
      var _selectNewEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this$providerSelecto, _this$providerSelecto2, _this$providerSelecto3, _this$providerSelecto6;

        var currentProviderUrl, _this$providerSelecto4, _this$providerSelecto5;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                currentProviderUrl = this.web3Manager.getWeb3().currentProvider.host;
                (_this$providerSelecto = this.providerSelector) === null || _this$providerSelecto === void 0 ? void 0 : _this$providerSelecto.addUnhealthy(currentProviderUrl);

                if (((_this$providerSelecto2 = this.providerSelector) === null || _this$providerSelecto2 === void 0 ? void 0 : _this$providerSelecto2.getUnhealthySize()) === ((_this$providerSelecto3 = this.providerSelector) === null || _this$providerSelecto3 === void 0 ? void 0 : _this$providerSelecto3.getServicesSize())) {
                  this.logger.log('No healthy providers available - resetting ProviderSelection and selecting.');
                  (_this$providerSelecto4 = this.providerSelector) === null || _this$providerSelecto4 === void 0 ? void 0 : _this$providerSelecto4.clearUnhealthy();
                  (_this$providerSelecto5 = this.providerSelector) === null || _this$providerSelecto5 === void 0 ? void 0 : _this$providerSelecto5.clearBackups();
                } // Reset _isInitializing to false to retry init logic and avoid the _isInitialzing check


                this._isInitializing = false;
                _context3.next = 6;
                return (_this$providerSelecto6 = this.providerSelector) === null || _this$providerSelecto6 === void 0 ? void 0 : _this$providerSelecto6.select(this);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function selectNewEndpoint() {
        return _selectNewEndpoint.apply(this, arguments);
      }

      return selectNewEndpoint;
    }()
    /** Gets the contract address and ensures that the contract has initted. */

  }, {
    key: "getAddress",
    value: function () {
      var _getAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.init();

              case 2:
                return _context4.abrupt("return", this._contractAddress);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAddress() {
        return _getAddress.apply(this, arguments);
      }

      return getAddress;
    }()
    /**
     * Gets a contract method and ensures that the contract has initted
     * The contract can then be invoked with .call() or be passed to a sendTransaction.
     * @param methodName the name of the contract method
     */

  }, {
    key: "getMethod",
    value: function () {
      var _getMethod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(methodName) {
        var _this$_contract,
            _this$_contract3,
            _this$_contract3$meth,
            _this2 = this;

        var _this$_contract2,
            _len,
            args,
            _key,
            method,
            call,
            _args7 = arguments;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.init();

              case 2:
                if (methodName in ((_this$_contract = this._contract) === null || _this$_contract === void 0 ? void 0 : _this$_contract.methods)) {
                  _context7.next = 4;
                  break;
                }

                throw new Error("Contract method ".concat(methodName, " not found in ").concat(Object.keys((_this$_contract2 = this._contract) === null || _this$_contract2 === void 0 ? void 0 : _this$_contract2.methods)));

              case 4:
                for (_len = _args7.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = _args7[_key];
                }

                _context7.next = 7;
                return (_this$_contract3 = this._contract) === null || _this$_contract3 === void 0 ? void 0 : (_this$_contract3$meth = _this$_contract3.methods)[methodName].apply(_this$_contract3$meth, args);

              case 7:
                method = _context7.sent;
                // Override method.call (chain reads) with built in retry logic
                call = method.call;
                method.call = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
                  var _len2,
                      args,
                      _key2,
                      _args6 = arguments;

                  return regeneratorRuntime.wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          for (_len2 = _args6.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                            args[_key2] = _args6[_key2];
                          }

                          _context6.next = 3;
                          return retry__default["default"]( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                            return regeneratorRuntime.wrap(function _callee5$(_context5) {
                              while (1) {
                                switch (_context5.prev = _context5.next) {
                                  case 0:
                                    return _context5.abrupt("return", call.apply(void 0, args));

                                  case 1:
                                  case "end":
                                    return _context5.stop();
                                }
                              }
                            }, _callee5);
                          })), {
                            // Retry function 5x by default
                            // 1st retry delay = 500ms, 2nd = 1500ms, 3rd...nth retry = 4000 ms (capped)
                            minTimeout: 500,
                            maxTimeout: 4000,
                            factor: 3,
                            retries: METHOD_CALL_MAX_RETRIES,
                            onRetry: function onRetry(err) {
                              if (err) {
                                // eslint-disable-next-line @typescript-eslint/no-base-to-string
                                _this2.logger.log("Retry error for ".concat(methodName, " : ").concat(err));
                              }
                            }
                          });

                        case 3:
                          return _context6.abrupt("return", _context6.sent);

                        case 4:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6);
                }));
                return _context7.abrupt("return", method);

              case 11:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getMethod(_x) {
        return _getMethod.apply(this, arguments);
      }

      return getMethod;
    }()
  }, {
    key: "getEthNetId",
    value: function () {
      var _getEthNetId = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var netId;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.init();

              case 2:
                _context8.next = 4;
                return this.web3Manager.getWeb3().eth.net.getId();

              case 4:
                netId = _context8.sent;
                return _context8.abrupt("return", netId);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getEthNetId() {
        return _getEthNetId.apply(this, arguments);
      }

      return getEthNetId;
    }()
  }, {
    key: "getContract",
    value: function () {
      var _getContract = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.init();

              case 2:
                return _context9.abrupt("return", this._contract);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getContract() {
        return _getContract.apply(this, arguments);
      }

      return getContract;
    }()
  }]);

  return ContractClient;
}();

var ContractClient$8 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ContractClient: ContractClient$7
});

/**
 * Transform a method name and its argument types into a string-composed
 * signature, e.g. someMethod(bytes32, int32)
 * @param methodName
 * @param argumentTypes
 */

var createMethodSignature = function createMethodSignature(methodName, argumentTypes) {
  return "".concat(methodName, "(").concat(argumentTypes.join(','), ")");
};
/**
 * Represent an instance of a proposal vote.
 */


Object.freeze({
  no: 1,
  yes: 2
});
var GovernanceClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(GovernanceClient, _ContractClient);

  var _super = _createSuper(GovernanceClient);

  function GovernanceClient(ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, audiusTokenClient, stakingProxyClient) {
    var _this;

    var logger = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : console;
    var isDebug = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;

    _classCallCheck(this, GovernanceClient);

    _this = _super.call(this, ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, logger);
    _this.audiusTokenClient = audiusTokenClient;
    _this.stakingProxyClient = stakingProxyClient;
    _this.isDebug = isDebug;
    _this.formatVote = _this.formatVote.bind(_assertThisInitialized(_this));
    _this.formatProposalEvent = _this.formatProposalEvent.bind(_assertThisInitialized(_this));
    _this.abiEncode = _this.abiEncode.bind(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Gets the function signature and call data for a contract method.
   * The signature and call data are passed to other contracts (like governance)
   * as arguments.
   * @param methodName
   * @param contractMethod
   */


  _createClass(GovernanceClient, [{
    key: "getSignatureAndCallData",
    value: function getSignatureAndCallData(methodName, contractMethod) {
      var argumentTypes = contractMethod._method.inputs.map(function (i) {
        return i.type;
      });

      var argumentValues = contractMethod.arguments;
      var signature = createMethodSignature(methodName, argumentTypes);
      var callData = this.abiEncode(argumentTypes, argumentValues);
      return {
        signature: signature,
        callData: callData
      };
    }
  }, {
    key: "guardianExecuteTransaction",
    value: function () {
      var _guardianExecuteTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(contractRegistryKey, functionSignature, callData) {
        var callValue0, method;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // 0 eth valued transaction. We don't anticipate needed to attach
                // value to this txn, so default to 0.
                callValue0 = this.toBN('0');
                _context.next = 3;
                return this.getMethod('guardianExecuteTransaction', contractRegistryKey, callValue0, functionSignature, callData);

              case 3:
                method = _context.sent;
                return _context.abrupt("return", method);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function guardianExecuteTransaction(_x, _x2, _x3) {
        return _guardianExecuteTransaction.apply(this, arguments);
      }

      return guardianExecuteTransaction;
    }()
  }, {
    key: "getVotingPeriod",
    value: function () {
      var _getVotingPeriod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var method, period;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getMethod('getVotingPeriod');

              case 2:
                method = _context2.sent;
                _context2.next = 5;
                return method.call();

              case 5:
                period = _context2.sent;
                return _context2.abrupt("return", parseInt(period));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getVotingPeriod() {
        return _getVotingPeriod.apply(this, arguments);
      }

      return getVotingPeriod;
    }()
  }, {
    key: "setVotingPeriod",
    value: function () {
      var _setVotingPeriod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(period) {
        var methodName, contractMethod, _this$getSignatureAnd, signature, callData, contractRegistryKey, method;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                methodName = 'setVotingPeriod';
                _context3.next = 3;
                return this.getMethod(methodName, period);

              case 3:
                contractMethod = _context3.sent;
                _this$getSignatureAnd = this.getSignatureAndCallData(methodName, contractMethod), signature = _this$getSignatureAnd.signature, callData = _this$getSignatureAnd.callData;
                contractRegistryKey = this.web3Manager.getWeb3().utils.utf8ToHex(this.contractRegistryKey);
                _context3.next = 8;
                return this.guardianExecuteTransaction(contractRegistryKey, signature, callData);

              case 8:
                method = _context3.sent;
                _context3.next = 11;
                return this.web3Manager.sendTransaction(method);

              case 11:
                return _context3.abrupt("return", _context3.sent);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function setVotingPeriod(_x4) {
        return _setVotingPeriod.apply(this, arguments);
      }

      return setVotingPeriod;
    }()
  }, {
    key: "getVotingQuorumPercent",
    value: function () {
      var _getVotingQuorumPercent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var method, percent;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('getVotingQuorumPercent');

              case 2:
                method = _context4.sent;
                _context4.next = 5;
                return method.call();

              case 5:
                percent = _context4.sent;
                return _context4.abrupt("return", parseInt(percent));

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getVotingQuorumPercent() {
        return _getVotingQuorumPercent.apply(this, arguments);
      }

      return getVotingQuorumPercent;
    }()
  }, {
    key: "getExecutionDelay",
    value: function () {
      var _getExecutionDelay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var method, delay;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getMethod('getExecutionDelay');

              case 2:
                method = _context5.sent;
                _context5.next = 5;
                return method.call();

              case 5:
                delay = _context5.sent;
                return _context5.abrupt("return", parseInt(delay));

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getExecutionDelay() {
        return _getExecutionDelay.apply(this, arguments);
      }

      return getExecutionDelay;
    }()
  }, {
    key: "setExecutionDelay",
    value: function () {
      var _setExecutionDelay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(delay) {
        var methodName, contractMethod, _this$getSignatureAnd2, signature, callData, contractRegistryKey, method;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                methodName = 'setExecutionDelay';
                _context6.next = 3;
                return this.getMethod(methodName, delay);

              case 3:
                contractMethod = _context6.sent;
                _this$getSignatureAnd2 = this.getSignatureAndCallData(methodName, contractMethod), signature = _this$getSignatureAnd2.signature, callData = _this$getSignatureAnd2.callData;
                contractRegistryKey = this.web3Manager.getWeb3().utils.utf8ToHex(this.contractRegistryKey);
                _context6.next = 8;
                return this.guardianExecuteTransaction(contractRegistryKey, signature, callData);

              case 8:
                method = _context6.sent;
                _context6.next = 11;
                return this.web3Manager.sendTransaction(method);

              case 11:
                return _context6.abrupt("return", _context6.sent);

              case 12:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function setExecutionDelay(_x5) {
        return _setExecutionDelay.apply(this, arguments);
      }

      return setExecutionDelay;
    }()
  }, {
    key: "getProposalById",
    value: function () {
      var _getProposalById = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(id) {
        var method, proposal, formattedProposal;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getMethod('getProposalById', id);

              case 2:
                method = _context7.sent;
                _context7.next = 5;
                return method.call();

              case 5:
                proposal = _context7.sent;
                formattedProposal = this.formatProposal(proposal);
                return _context7.abrupt("return", formattedProposal);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getProposalById(_x6) {
        return _getProposalById.apply(this, arguments);
      }

      return getProposalById;
    }()
  }, {
    key: "getProposalTargetContractHash",
    value: function () {
      var _getProposalTargetContractHash = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(id) {
        var method;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getMethod('getProposalTargetContractHash', id);

              case 2:
                method = _context8.sent;
                return _context8.abrupt("return", method.call());

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getProposalTargetContractHash(_x7) {
        return _getProposalTargetContractHash.apply(this, arguments);
      }

      return getProposalTargetContractHash;
    }()
  }, {
    key: "getProposals",
    value: function () {
      var _getProposals = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var queryStartBlock,
            contract,
            events,
            _args9 = arguments;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                queryStartBlock = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : 0;
                _context9.next = 3;
                return this.getContract();

              case 3:
                contract = _context9.sent;
                _context9.next = 6;
                return contract.getPastEvents('ProposalSubmitted', {
                  fromBlock: queryStartBlock
                });

              case 6:
                events = _context9.sent;
                return _context9.abrupt("return", events === null || events === void 0 ? void 0 : events.map(this.formatProposalEvent));

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getProposals() {
        return _getProposals.apply(this, arguments);
      }

      return getProposals;
    }()
  }, {
    key: "getProposalsForAddresses",
    value: function () {
      var _getProposalsForAddresses = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(addresses) {
        var queryStartBlock,
            contract,
            events,
            _args10 = arguments;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                queryStartBlock = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : 0;
                _context10.next = 3;
                return this.getContract();

              case 3:
                contract = _context10.sent;
                _context10.next = 6;
                return contract.getPastEvents('ProposalSubmitted', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _proposer: addresses
                  }
                });

              case 6:
                events = _context10.sent;
                return _context10.abrupt("return", events.map(this.formatProposalEvent));

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getProposalsForAddresses(_x8) {
        return _getProposalsForAddresses.apply(this, arguments);
      }

      return getProposalsForAddresses;
    }()
  }, {
    key: "getProposalSubmission",
    value: function () {
      var _getProposalSubmission = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(proposalId) {
        var queryStartBlock,
            contract,
            events,
            _args11 = arguments;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                queryStartBlock = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : 0;
                _context11.next = 3;
                return this.getContract();

              case 3:
                contract = _context11.sent;
                _context11.next = 6;
                return contract.getPastEvents('ProposalSubmitted', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _proposalId: proposalId
                  }
                });

              case 6:
                events = _context11.sent;
                return _context11.abrupt("return", this.formatProposalEvent(events[0]));

              case 8:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getProposalSubmission(_x9) {
        return _getProposalSubmission.apply(this, arguments);
      }

      return getProposalSubmission;
    }()
  }, {
    key: "getInProgressProposals",
    value: function () {
      var _getInProgressProposals = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var method, ids;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getMethod('getInProgressProposals');

              case 2:
                method = _context12.sent;
                _context12.next = 5;
                return method.call();

              case 5:
                ids = _context12.sent;
                return _context12.abrupt("return", ids);

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getInProgressProposals() {
        return _getInProgressProposals.apply(this, arguments);
      }

      return getInProgressProposals;
    }()
  }, {
    key: "submitProposal",
    value: function () {
      var _submitProposal = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref) {
        var _functionSignature$ma, _functionSignature$ma2, _functionSignature$ma3, _tx$events, _tx$events$ProposalSu, _tx$events$ProposalSu2;

        var targetContractRegistryKey, callValue, functionSignature, callData, name, description, argumentTypes, encodedCallData, method, tx, id;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                targetContractRegistryKey = _ref.targetContractRegistryKey, callValue = _ref.callValue, functionSignature = _ref.functionSignature, callData = _ref.callData, name = _ref.name, description = _ref.description;
                argumentTypes = (_functionSignature$ma = functionSignature.match( /*#__PURE__*/_wrapRegExp(/.*\((.*)\)/, {
                  args: 1
                }))) === null || _functionSignature$ma === void 0 ? void 0 : (_functionSignature$ma2 = _functionSignature$ma.groups) === null || _functionSignature$ma2 === void 0 ? void 0 : (_functionSignature$ma3 = _functionSignature$ma2['args']) === null || _functionSignature$ma3 === void 0 ? void 0 : _functionSignature$ma3.split(',');
                encodedCallData = this.abiEncode(argumentTypes, callData);
                _context13.next = 5;
                return this.getMethod('submitProposal', targetContractRegistryKey, callValue, functionSignature, encodedCallData, name, description);

              case 5:
                method = _context13.sent;
                _context13.next = 8;
                return this.web3Manager.sendTransaction(method);

              case 8:
                tx = _context13.sent;
                id = (_tx$events = tx.events) === null || _tx$events === void 0 ? void 0 : (_tx$events$ProposalSu = _tx$events['ProposalSubmitted']) === null || _tx$events$ProposalSu === void 0 ? void 0 : (_tx$events$ProposalSu2 = _tx$events$ProposalSu.returnValues) === null || _tx$events$ProposalSu2 === void 0 ? void 0 : _tx$events$ProposalSu2._proposalId;

                if (!id) {
                  _context13.next = 12;
                  break;
                }

                return _context13.abrupt("return", id);

              case 12:
                throw new Error('submitProposal: txn malformed');

              case 13:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function submitProposal(_x10) {
        return _submitProposal.apply(this, arguments);
      }

      return submitProposal;
    }()
  }, {
    key: "submitVote",
    value: function () {
      var _submitVote = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(_ref2) {
        var proposalId, vote, method;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                proposalId = _ref2.proposalId, vote = _ref2.vote;
                _context14.next = 3;
                return this.getMethod('submitVote', proposalId, vote);

              case 3:
                method = _context14.sent;
                _context14.next = 6;
                return this.web3Manager.sendTransaction(method);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function submitVote(_x11) {
        return _submitVote.apply(this, arguments);
      }

      return submitVote;
    }()
  }, {
    key: "updateVote",
    value: function () {
      var _updateVote = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(_ref3) {
        var proposalId, vote, method;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                proposalId = _ref3.proposalId, vote = _ref3.vote;
                _context15.next = 3;
                return this.getMethod('updateVote', proposalId, vote);

              case 3:
                method = _context15.sent;
                _context15.next = 6;
                return this.web3Manager.sendTransaction(method);

              case 6:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function updateVote(_x12) {
        return _updateVote.apply(this, arguments);
      }

      return updateVote;
    }()
  }, {
    key: "evaluateProposalOutcome",
    value: function () {
      var _evaluateProposalOutcome = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(proposalId) {
        var method, outcome;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getMethod('evaluateProposalOutcome', proposalId);

              case 2:
                method = _context16.sent;
                _context16.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                outcome = _context16.sent;
                return _context16.abrupt("return", outcome);

              case 7:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function evaluateProposalOutcome(_x13) {
        return _evaluateProposalOutcome.apply(this, arguments);
      }

      return evaluateProposalOutcome;
    }()
  }, {
    key: "getProposalEvaluation",
    value: function () {
      var _getProposalEvaluation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(proposalId) {
        var queryStartBlock,
            contract,
            events,
            _args17 = arguments;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                queryStartBlock = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : 0;
                _context17.next = 3;
                return this.getContract();

              case 3:
                contract = _context17.sent;
                _context17.next = 6;
                return contract.getPastEvents('ProposalOutcomeEvaluated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _proposalId: proposalId
                  }
                });

              case 6:
                events = _context17.sent;
                return _context17.abrupt("return", events);

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getProposalEvaluation(_x14) {
        return _getProposalEvaluation.apply(this, arguments);
      }

      return getProposalEvaluation;
    }()
  }, {
    key: "getVotes",
    value: function () {
      var _getVotes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(_ref4) {
        var proposalId, _ref4$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                proposalId = _ref4.proposalId, _ref4$queryStartBlock = _ref4.queryStartBlock, queryStartBlock = _ref4$queryStartBlock === void 0 ? 0 : _ref4$queryStartBlock;
                _context18.next = 3;
                return this.getContract();

              case 3:
                contract = _context18.sent;
                _context18.next = 6;
                return contract.getPastEvents('ProposalVoteSubmitted', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _proposalId: proposalId
                  }
                });

              case 6:
                events = _context18.sent;
                return _context18.abrupt("return", events.map(this.formatVote));

              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getVotes(_x15) {
        return _getVotes.apply(this, arguments);
      }

      return getVotes;
    }()
  }, {
    key: "getVoteUpdates",
    value: function () {
      var _getVoteUpdates = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(_ref5) {
        var proposalId, _ref5$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                proposalId = _ref5.proposalId, _ref5$queryStartBlock = _ref5.queryStartBlock, queryStartBlock = _ref5$queryStartBlock === void 0 ? 0 : _ref5$queryStartBlock;
                _context19.next = 3;
                return this.getContract();

              case 3:
                contract = _context19.sent;
                _context19.next = 6;
                return contract.getPastEvents('ProposalVoteUpdated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _proposalId: proposalId
                  }
                });

              case 6:
                events = _context19.sent;
                return _context19.abrupt("return", events.map(this.formatVote));

              case 8:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getVoteUpdates(_x16) {
        return _getVoteUpdates.apply(this, arguments);
      }

      return getVoteUpdates;
    }()
  }, {
    key: "getVoteSubmissionsByAddress",
    value: function () {
      var _getVoteSubmissionsByAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(_ref6) {
        var addresses, _ref6$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                addresses = _ref6.addresses, _ref6$queryStartBlock = _ref6.queryStartBlock, queryStartBlock = _ref6$queryStartBlock === void 0 ? 0 : _ref6$queryStartBlock;
                _context20.next = 3;
                return this.getContract();

              case 3:
                contract = _context20.sent;
                _context20.next = 6;
                return contract.getPastEvents('ProposalVoteSubmitted', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _voter: addresses
                  }
                });

              case 6:
                events = _context20.sent;
                return _context20.abrupt("return", events.map(this.formatVote));

              case 8:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getVoteSubmissionsByAddress(_x17) {
        return _getVoteSubmissionsByAddress.apply(this, arguments);
      }

      return getVoteSubmissionsByAddress;
    }()
  }, {
    key: "getVoteUpdatesByAddress",
    value: function () {
      var _getVoteUpdatesByAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(_ref7) {
        var addresses, _ref7$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                addresses = _ref7.addresses, _ref7$queryStartBlock = _ref7.queryStartBlock, queryStartBlock = _ref7$queryStartBlock === void 0 ? 0 : _ref7$queryStartBlock;
                _context21.next = 3;
                return this.getContract();

              case 3:
                contract = _context21.sent;
                _context21.next = 6;
                return contract.getPastEvents('ProposalVoteUpdated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _voter: addresses
                  }
                });

              case 6:
                events = _context21.sent;
                return _context21.abrupt("return", events.map(this.formatVote));

              case 8:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getVoteUpdatesByAddress(_x18) {
        return _getVoteUpdatesByAddress.apply(this, arguments);
      }

      return getVoteUpdatesByAddress;
    }()
  }, {
    key: "getVoteByProposalAndVoter",
    value: function () {
      var _getVoteByProposalAndVoter = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(_ref8) {
        var proposalId, voterAddress, method, result;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                proposalId = _ref8.proposalId, voterAddress = _ref8.voterAddress;
                _context22.next = 3;
                return this.getMethod('getVoteInfoByProposalAndVoter', proposalId, voterAddress);

              case 3:
                method = _context22.sent;
                _context22.next = 6;
                return method.call();

              case 6:
                result = _context22.sent;
                return _context22.abrupt("return", parseInt(result.vote));

              case 8:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getVoteByProposalAndVoter(_x19) {
        return _getVoteByProposalAndVoter.apply(this, arguments);
      }

      return getVoteByProposalAndVoter;
    }() // Helpers

    /**
     * ABI encodes argument types and values together into one encoded string
     */

  }, {
    key: "abiEncode",
    value: function abiEncode(types, values) {
      return this.web3Manager.getWeb3().eth.abi.encodeParameters(types, values);
    }
  }, {
    key: "toBN",
    value: function toBN(val) {
      return this.web3Manager.getWeb3().utils.toBN(val);
    }
    /**
     * Prune off extraneous fields from proposal returned by txn
     */

  }, {
    key: "formatProposal",
    value: function formatProposal(proposal) {
      return {
        proposalId: parseInt(proposal.proposalId),
        proposer: proposal.proposer,
        submissionBlockNumber: parseInt(proposal.submissionBlockNumber),
        targetContractRegistryKey: proposal.targetContractRegistryKey,
        targetContractAddress: proposal.targetContractAddress,
        callValue: parseInt(proposal.callValue),
        functionSignature: proposal.functionSignature,
        callData: proposal.callData,
        outcome: parseInt(proposal.outcome),
        numVotes: parseInt(proposal.numVotes),
        voteMagnitudeYes: this.toBN(proposal.voteMagnitudeYes),
        voteMagnitudeNo: this.toBN(proposal.voteMagnitudeNo)
      };
    }
    /**
     * Formats a proposal event
     */

  }, {
    key: "formatProposalEvent",
    value: function formatProposalEvent(proposalEvent) {
      var event = proposalEvent.returnValues;
      return {
        proposalId: parseInt(event._proposalId),
        proposer: event._proposer,
        description: event._description,
        name: event._name,
        blockNumber: proposalEvent.blockNumber
      };
    }
    /**
     * Prune off extraneous fields from vote event
     */

  }, {
    key: "formatVote",
    value: function formatVote(voteEvent) {
      var event = voteEvent.returnValues;
      return {
        proposalId: parseInt(event._proposalId),
        voter: event._voter,
        vote: parseInt(event._vote),
        voterStake: this.toBN(event._voterStake),
        blockNumber: voteEvent.blockNumber
      };
    }
    /**
     *
     * @param {Number} proposalId id of the governance proposal
     * @returns {BN} amount of tokens in wei required to reach quorum
     */

  }, {
    key: "calculateQuorum",
    value: function () {
      var _calculateQuorum = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(proposalId) {
        var _yield$this$getPropos, submissionBlockNumber, quoroumPercent, totalStakeAtProposal, quorumStakeDivMod, quorumStake;

        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.getProposalById(proposalId);

              case 2:
                _yield$this$getPropos = _context23.sent;
                submissionBlockNumber = _yield$this$getPropos.submissionBlockNumber;
                _context23.next = 6;
                return this.getVotingQuorumPercent();

              case 6:
                quoroumPercent = _context23.sent;
                _context23.next = 9;
                return this.stakingProxyClient.totalStakedAt(submissionBlockNumber);

              case 9:
                totalStakeAtProposal = _context23.sent;
                // quorum = (total staked at proposal * quorum percent) / 100
                // the divmod function returns an object with both the quotient (div) and the remainder (mod)
                // { div, mod }
                quorumStakeDivMod = totalStakeAtProposal.mul(Utils$b.toBN(quoroumPercent)) // @ts-expect-error divmod not in types for some reason
                .divmod(Utils$b.toBN(100));
                quorumStake = quorumStakeDivMod.div; // if there's a non-zero remainder, round up

                if (!quorumStakeDivMod.mod.isZero()) {
                  quorumStake = quorumStakeDivMod.div.add(Utils$b.toBN(1));
                }

                return _context23.abrupt("return", quorumStake);

              case 14:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function calculateQuorum(_x20) {
        return _calculateQuorum.apply(this, arguments);
      }

      return calculateQuorum;
    }()
  }]);

  return GovernanceClient;
}(ContractClient$7);

/**
 * Contract class that extends a ContractClient and provides an interface
 * to retrieve governed methods that cannot be executed directly.
 */

var GovernedContractClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(GovernedContractClient, _ContractClient);

  var _super = _createSuper(GovernedContractClient);

  function GovernedContractClient(web3Manager, contractABI, contractRegistryKey, getRegistryAddress, governanceClient) {
    var _this;

    var logger = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : console;

    _classCallCheck(this, GovernedContractClient);

    _this = _super.call(this, web3Manager, contractABI, contractRegistryKey, getRegistryAddress, logger);
    _this.governanceClient = governanceClient;
    return _this;
  }
  /**
   * Gets a governed version of a method and allows a single transaction
   * to be sent to the governance client with the appropriate payload.
   * Similar to `getMethod`
   */


  _createClass(GovernedContractClient, [{
    key: "getGovernedMethod",
    value: function () {
      var _getGovernedMethod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(methodName) {
        var _len,
            args,
            _key,
            contractMethod,
            _this$governanceClien,
            signature,
            callData,
            contractRegistryKey,
            method,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                for (_len = _args.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = _args[_key];
                }

                _context.next = 3;
                return this.getMethod.apply(this, [methodName].concat(args));

              case 3:
                contractMethod = _context.sent;
                _this$governanceClien = this.governanceClient.getSignatureAndCallData(methodName, contractMethod), signature = _this$governanceClien.signature, callData = _this$governanceClien.callData;
                contractRegistryKey = this.web3Manager.getWeb3().utils.utf8ToHex(this.contractRegistryKey);
                _context.next = 8;
                return this.governanceClient.guardianExecuteTransaction(contractRegistryKey, signature, callData);

              case 8:
                method = _context.sent;
                return _context.abrupt("return", method);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getGovernedMethod(_x) {
        return _getGovernedMethod.apply(this, arguments);
      }

      return getGovernedMethod;
    }()
  }]);

  return GovernedContractClient;
}(ContractClient$7);

var ServiceTypeManagerClient = /*#__PURE__*/function (_GovernedContractClie) {
  _inherits(ServiceTypeManagerClient, _GovernedContractClie);

  var _super = _createSuper(ServiceTypeManagerClient);

  function ServiceTypeManagerClient() {
    _classCallCheck(this, ServiceTypeManagerClient);

    return _super.apply(this, arguments);
  }

  _createClass(ServiceTypeManagerClient, [{
    key: "setServiceVersion",
    value:
    /**
     *
     * @param serviceType Type of service to set the version, either `discovery-node` or `content-node`
     * @param serviceVersion Version string to set on chain
     * @param privateKey Optional privateKey to pass along to web3Manager sendTransaction
     * @param dryRun Optional parameter to return the generated parameters without sending tx
     * @returns comma-separated String of serviceType and serviceVersion if dryRun; else response from web3Manager.sendTransaction
     */
    function () {
      var _setServiceVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(serviceType, serviceVersion) {
        var privateKey,
            dryRun,
            method,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                privateKey = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
                dryRun = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;
                _context.next = 4;
                return this.getGovernedMethod('setServiceVersion', Utils$b.utf8ToHex(serviceType), Utils$b.utf8ToHex(serviceVersion));

              case 4:
                method = _context.sent;

                if (!dryRun) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", "".concat(Utils$b.utf8ToHex(serviceType), ",").concat(Utils$b.utf8ToHex(serviceVersion)));

              case 7:
                _context.t0 = this.web3Manager;
                _context.t1 = method;
                _context.next = 11;
                return this.governanceClient.getAddress();

              case 11:
                _context.t2 = _context.sent;
                _context.t3 = privateKey;
                _context.next = 15;
                return _context.t0.sendTransaction.call(_context.t0, _context.t1, _context.t2, _context.t3);

              case 15:
                return _context.abrupt("return", _context.sent);

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setServiceVersion(_x, _x2) {
        return _setServiceVersion.apply(this, arguments);
      }

      return setServiceVersion;
    }()
  }, {
    key: "addServiceType",
    value: function () {
      var _addServiceType = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(serviceType, serviceTypeMin, serviceTypeMax) {
        var privateKey,
            method,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                privateKey = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : null;
                _context2.next = 3;
                return this.getGovernedMethod('addServiceType', Utils$b.utf8ToHex(serviceType), serviceTypeMin, serviceTypeMax);

              case 3:
                method = _context2.sent;
                _context2.t0 = this.web3Manager;
                _context2.t1 = method;
                _context2.next = 8;
                return this.governanceClient.getAddress();

              case 8:
                _context2.t2 = _context2.sent;
                _context2.t3 = privateKey;
                _context2.next = 12;
                return _context2.t0.sendTransaction.call(_context2.t0, _context2.t1, _context2.t2, _context2.t3);

              case 12:
                return _context2.abrupt("return", _context2.sent);

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function addServiceType(_x3, _x4, _x5) {
        return _addServiceType.apply(this, arguments);
      }

      return addServiceType;
    }()
  }, {
    key: "getValidServiceTypes",
    value: function () {
      var _getValidServiceTypes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var method, types;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getMethod('getValidServiceTypes');

              case 2:
                method = _context3.sent;
                _context3.next = 5;
                return method.call();

              case 5:
                types = _context3.sent;
                return _context3.abrupt("return", types.map(function (t) {
                  return Utils$b.hexToUtf8(t);
                }));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getValidServiceTypes() {
        return _getValidServiceTypes.apply(this, arguments);
      }

      return getValidServiceTypes;
    }()
  }, {
    key: "getCurrentVersion",
    value: function () {
      var _getCurrentVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(serviceType) {
        var method, hexVersion;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('getCurrentVersion', Utils$b.utf8ToHex(serviceType));

              case 2:
                method = _context4.sent;
                _context4.next = 5;
                return method.call();

              case 5:
                hexVersion = _context4.sent;
                return _context4.abrupt("return", Utils$b.hexToUtf8(hexVersion));

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getCurrentVersion(_x6) {
        return _getCurrentVersion.apply(this, arguments);
      }

      return getCurrentVersion;
    }()
  }, {
    key: "getVersion",
    value: function () {
      var _getVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(serviceType, serviceTypeIndex) {
        var serviceTypeBytes32, method, version;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                serviceTypeBytes32 = Utils$b.utf8ToHex(serviceType);
                _context5.next = 3;
                return this.getMethod('getVersion', serviceTypeBytes32, serviceTypeIndex);

              case 3:
                method = _context5.sent;
                _context5.next = 6;
                return method.call();

              case 6:
                version = _context5.sent;
                return _context5.abrupt("return", Utils$b.hexToUtf8(version));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getVersion(_x7, _x8) {
        return _getVersion.apply(this, arguments);
      }

      return getVersion;
    }()
  }, {
    key: "getNumberOfVersions",
    value: function () {
      var _getNumberOfVersions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(serviceType) {
        var method;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getMethod('getNumberOfVersions', Utils$b.utf8ToHex(serviceType));

              case 2:
                method = _context6.sent;
                _context6.t0 = parseInt;
                _context6.next = 6;
                return method.call();

              case 6:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", (0, _context6.t0)(_context6.t1));

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getNumberOfVersions(_x9) {
        return _getNumberOfVersions.apply(this, arguments);
      }

      return getNumberOfVersions;
    }()
    /**
     * @notice Add a new service type
     * @returns {
     *  isValid: Is the types type is isValid
     *  minStake: minimum stake for service type
     *  maxStake: minimum stake for service type
     * }
     */

  }, {
    key: "getServiceTypeInfo",
    value: function () {
      var _getServiceTypeInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(serviceType) {
        var method, response;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getMethod('getServiceTypeInfo', Utils$b.utf8ToHex(serviceType));

              case 2:
                method = _context7.sent;
                _context7.next = 5;
                return method.call();

              case 5:
                response = _context7.sent;
                return _context7.abrupt("return", {
                  isValid: response[0],
                  minStake: Utils$b.toBN(response[1]),
                  maxStake: Utils$b.toBN(response[2])
                });

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getServiceTypeInfo(_x10) {
        return _getServiceTypeInfo.apply(this, arguments);
      }

      return getServiceTypeInfo;
    }()
  }]);

  return ServiceTypeManagerClient;
}(GovernedContractClient);

var ServiceProviderFactoryClient = /*#__PURE__*/function (_GovernedContractClie) {
  _inherits(ServiceProviderFactoryClient, _GovernedContractClie);

  var _super = _createSuper(ServiceProviderFactoryClient);

  function ServiceProviderFactoryClient(ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, audiusTokenClient, stakingProxyClient, governanceClient) {
    var _this;

    var logger = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : console;
    var isDebug = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;

    _classCallCheck(this, ServiceProviderFactoryClient);

    _this = _super.call(this, ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, governanceClient, logger);
    _this.audiusTokenClient = audiusTokenClient;
    _this.stakingProxyClient = stakingProxyClient;
    _this.isDebug = isDebug;
    return _this;
  }

  _createClass(ServiceProviderFactoryClient, [{
    key: "registerWithDelegate",
    value: function () {
      var _registerWithDelegate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(serviceType, endpoint, amount, delegateOwnerWallet) {
        var _tx$events, _tx$events$Registered;

        var sanitizedEndpoint, requestUrl, axiosRequestObj, resp, endpointServiceType, contractAddress, tx0, method, tx, returnValues;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                sanitizedEndpoint = endpoint.replace(/\/$/, '');

                if (!(!this.isDebug && !Utils$b.isHttps(sanitizedEndpoint))) {
                  _context.next = 3;
                  break;
                }

                throw new Error('Domain name not using https protocol!');

              case 3:
                if (!(!this.isDebug && !Utils$b.isFQDN(sanitizedEndpoint))) {
                  _context.next = 5;
                  break;
                }

                throw new Error('Not a fully qualified domain name!');

              case 5:
                if (!(!Number.isInteger(amount) && !Utils$b.isBN(amount))) {
                  _context.next = 7;
                  break;
                }

                throw new Error('Invalid amount');

              case 7:
                requestUrl = urlJoin__default["default"](sanitizedEndpoint, 'health_check');
                axiosRequestObj = {
                  url: requestUrl,
                  method: 'get',
                  timeout: 1000
                };
                _context.next = 11;
                return axios__default["default"](axiosRequestObj);

              case 11:
                resp = _context.sent;
                endpointServiceType = resp.data.data.service;

                if (!(serviceType !== endpointServiceType)) {
                  _context.next = 15;
                  break;
                }

                throw new Error('Attempting to register endpoint with mismatched service type');

              case 15:
                _context.next = 17;
                return this.stakingProxyClient.getAddress();

              case 17:
                contractAddress = _context.sent;
                _context.next = 20;
                return this.audiusTokenClient.approve(contractAddress, amount);

              case 20:
                tx0 = _context.sent;
                _context.next = 23;
                return this.getMethod('register', Utils$b.utf8ToHex(serviceType), sanitizedEndpoint, amount, delegateOwnerWallet);

              case 23:
                method = _context.sent;
                _context.next = 26;
                return this.web3Manager.sendTransaction(method, 1000000);

              case 26:
                tx = _context.sent;
                returnValues = (_tx$events = tx.events) === null || _tx$events === void 0 ? void 0 : (_tx$events$Registered = _tx$events['RegisteredServiceProvider']) === null || _tx$events$Registered === void 0 ? void 0 : _tx$events$Registered.returnValues;
                return _context.abrupt("return", {
                  txReceipt: tx,
                  spID: parseInt(returnValues._spID),
                  serviceType: Utils$b.hexToUtf8(returnValues._serviceType),
                  owner: returnValues._owner,
                  endpoint: returnValues._endpoint,
                  tokenApproveReceipt: tx0
                });

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function registerWithDelegate(_x, _x2, _x3, _x4) {
        return _registerWithDelegate.apply(this, arguments);
      }

      return registerWithDelegate;
    }()
  }, {
    key: "register",
    value: function () {
      var _register = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(serviceType, endpoint, amount) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.registerWithDelegate(serviceType, endpoint, amount, this.web3Manager.getWalletAddress());

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function register(_x5, _x6, _x7) {
        return _register.apply(this, arguments);
      }

      return register;
    }()
  }, {
    key: "getRegisteredServiceProviderEvents",
    value: function () {
      var _getRegisteredServiceProviderEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref) {
        var serviceType, owner, _ref$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                serviceType = _ref.serviceType, owner = _ref.owner, _ref$queryStartBlock = _ref.queryStartBlock, queryStartBlock = _ref$queryStartBlock === void 0 ? 0 : _ref$queryStartBlock;
                _context3.next = 3;
                return this.getContract();

              case 3:
                contract = _context3.sent;
                filter = {};

                if (owner) {
                  filter._owner = owner;
                }

                if (serviceType) {
                  filter._serviceType = serviceType;
                }

                _context3.next = 9;
                return contract.getPastEvents('RegisteredServiceProvider', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 9:
                events = _context3.sent;
                return _context3.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    spID: parseInt(event.returnValues['_spID']),
                    serviceType: Utils$b.hexToUtf8(event.returnValues['_serviceType']),
                    owner: event.returnValues['_owner'],
                    endpoint: event.returnValues['_endpoint'],
                    stakeAmount: Utils$b.toBN(event.returnValues['_stakeAmout'])
                  };
                }));

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getRegisteredServiceProviderEvents(_x8) {
        return _getRegisteredServiceProviderEvents.apply(this, arguments);
      }

      return getRegisteredServiceProviderEvents;
    }()
  }, {
    key: "getDeregisteredServiceProviderEvents",
    value: function () {
      var _getDeregisteredServiceProviderEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref2) {
        var serviceType, owner, _ref2$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                serviceType = _ref2.serviceType, owner = _ref2.owner, _ref2$queryStartBlock = _ref2.queryStartBlock, queryStartBlock = _ref2$queryStartBlock === void 0 ? 0 : _ref2$queryStartBlock;
                _context4.next = 3;
                return this.getContract();

              case 3:
                contract = _context4.sent;
                filter = {};

                if (owner) {
                  filter._owner = owner;
                }

                if (serviceType) {
                  filter._serviceType = serviceType;
                }

                _context4.next = 9;
                return contract.getPastEvents('DeregisteredServiceProvider', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 9:
                events = _context4.sent;
                return _context4.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    spID: parseInt(event.returnValues['_spID']),
                    serviceType: Utils$b.hexToUtf8(event.returnValues['_serviceType']),
                    owner: event.returnValues['_owner'],
                    endpoint: event.returnValues['_endpoint'],
                    stakeAmount: Utils$b.toBN(event.returnValues['_stakeAmount'])
                  };
                }));

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getDeregisteredServiceProviderEvents(_x9) {
        return _getDeregisteredServiceProviderEvents.apply(this, arguments);
      }

      return getDeregisteredServiceProviderEvents;
    }()
  }, {
    key: "getIncreasedStakeEvents",
    value: function () {
      var _getIncreasedStakeEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref3) {
        var owner, _ref3$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                owner = _ref3.owner, _ref3$queryStartBlock = _ref3.queryStartBlock, queryStartBlock = _ref3$queryStartBlock === void 0 ? 0 : _ref3$queryStartBlock;
                _context5.next = 3;
                return this.getContract();

              case 3:
                contract = _context5.sent;
                _context5.next = 6;
                return contract.getPastEvents('IncreasedStake', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _owner: owner
                  }
                });

              case 6:
                events = _context5.sent;
                return _context5.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    owner: event.returnValues['_owner'],
                    increaseAmount: Utils$b.toBN(event.returnValues['_increaseAmount']),
                    newStakeAmount: Utils$b.toBN(event.returnValues['_newStakeAmount'])
                  };
                }));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getIncreasedStakeEvents(_x10) {
        return _getIncreasedStakeEvents.apply(this, arguments);
      }

      return getIncreasedStakeEvents;
    }()
  }, {
    key: "getDecreasedStakeEvaluatedEvents",
    value: function () {
      var _getDecreasedStakeEvaluatedEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref4) {
        var owner, _ref4$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                owner = _ref4.owner, _ref4$queryStartBlock = _ref4.queryStartBlock, queryStartBlock = _ref4$queryStartBlock === void 0 ? 0 : _ref4$queryStartBlock;
                _context6.next = 3;
                return this.getContract();

              case 3:
                contract = _context6.sent;
                _context6.next = 6;
                return contract.getPastEvents('DecreaseStakeRequestEvaluated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _owner: owner
                  }
                });

              case 6:
                events = _context6.sent;
                return _context6.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    owner: event.returnValues['_owner'],
                    decreaseAmount: Utils$b.toBN(event.returnValues['_decreaseAmount']),
                    newStakeAmount: Utils$b.toBN(event.returnValues['_newStakeAmount'])
                  };
                }));

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getDecreasedStakeEvaluatedEvents(_x11) {
        return _getDecreasedStakeEvaluatedEvents.apply(this, arguments);
      }

      return getDecreasedStakeEvaluatedEvents;
    }()
  }, {
    key: "getDecreasedStakeRequestedEvents",
    value: function () {
      var _getDecreasedStakeRequestedEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(_ref5) {
        var owner, _ref5$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                owner = _ref5.owner, _ref5$queryStartBlock = _ref5.queryStartBlock, queryStartBlock = _ref5$queryStartBlock === void 0 ? 0 : _ref5$queryStartBlock;
                _context7.next = 3;
                return this.getContract();

              case 3:
                contract = _context7.sent;
                _context7.next = 6;
                return contract.getPastEvents('DecreaseStakeRequested', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _owner: owner
                  }
                });

              case 6:
                events = _context7.sent;
                return _context7.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    owner: event.returnValues['_owner'],
                    decreaseAmount: Utils$b.toBN(event.returnValues['_decreaseAmount']),
                    lockupExpiryBlock: parseInt(event.returnValues['_lockupExpiryBlock'])
                  };
                }));

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getDecreasedStakeRequestedEvents(_x12) {
        return _getDecreasedStakeRequestedEvents.apply(this, arguments);
      }

      return getDecreasedStakeRequestedEvents;
    }()
  }, {
    key: "getDecreasedStakeCancelledEvents",
    value: function () {
      var _getDecreasedStakeCancelledEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref6) {
        var owner, _ref6$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                owner = _ref6.owner, _ref6$queryStartBlock = _ref6.queryStartBlock, queryStartBlock = _ref6$queryStartBlock === void 0 ? 0 : _ref6$queryStartBlock;
                _context8.next = 3;
                return this.getContract();

              case 3:
                contract = _context8.sent;
                _context8.next = 6;
                return contract.getPastEvents('DecreaseStakeRequestCancelled', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _owner: owner
                  }
                });

              case 6:
                events = _context8.sent;
                return _context8.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    owner: event.returnValues['_owner'],
                    decreaseAmount: Utils$b.toBN(event.returnValues['_decreaseAmount']),
                    lockupExpiryBlock: parseInt(event.returnValues['_lockupExpiryBlock'])
                  };
                }));

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getDecreasedStakeCancelledEvents(_x13) {
        return _getDecreasedStakeCancelledEvents.apply(this, arguments);
      }

      return getDecreasedStakeCancelledEvents;
    }() // Get the deregistered service's most recent endpoint and delegate owner wallet

  }, {
    key: "getDeregisteredService",
    value: function () {
      var _getDeregisteredService = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_ref7) {
        var serviceType, spID, _ref7$queryStartBlock, queryStartBlock, contract, service, registerEvents, _registerEvents, _registerEvents$retur, _endpoint, _owner, endpointUpdateEvents, _endpointUpdateEvents2, _endpointUpdateEvents, _newEndpoint, walletEvents, _walletEvents, _walletEvents$returnV, _updatedWallet;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                serviceType = _ref7.serviceType, spID = _ref7.spID, _ref7$queryStartBlock = _ref7.queryStartBlock, queryStartBlock = _ref7$queryStartBlock === void 0 ? 0 : _ref7$queryStartBlock;
                _context9.next = 3;
                return this.getContract();

              case 3:
                contract = _context9.sent;
                service = {
                  endpoint: '',
                  delegateOwnerWallet: ''
                };
                _context9.next = 7;
                return contract.getPastEvents('RegisteredServiceProvider', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _spID: spID,
                    _serviceType: Utils$b.utf8ToHex(serviceType)
                  }
                });

              case 7:
                registerEvents = _context9.sent;

                if (registerEvents.length > 0) {
                  _registerEvents$retur = (_registerEvents = registerEvents[registerEvents.length - 1]) === null || _registerEvents === void 0 ? void 0 : _registerEvents.returnValues, _endpoint = _registerEvents$retur._endpoint, _owner = _registerEvents$retur._owner;
                  service.endpoint = _endpoint;
                  service.owner = _owner;
                }

                _context9.next = 11;
                return contract.getPastEvents('EndpointUpdated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _spID: spID,
                    _serviceType: Utils$b.utf8ToHex(serviceType)
                  }
                });

              case 11:
                endpointUpdateEvents = _context9.sent;

                if (endpointUpdateEvents.length > 0) {
                  _endpointUpdateEvents = (_endpointUpdateEvents2 = endpointUpdateEvents[endpointUpdateEvents.length - 1]) === null || _endpointUpdateEvents2 === void 0 ? void 0 : _endpointUpdateEvents2.returnValues, _newEndpoint = _endpointUpdateEvents._newEndpoint;
                  service.endpoint = _newEndpoint;
                }

                _context9.next = 15;
                return contract.getPastEvents('DelegateOwnerWalletUpdated', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _spID: spID,
                    _serviceType: Utils$b.utf8ToHex(serviceType)
                  }
                });

              case 15:
                walletEvents = _context9.sent;

                if (walletEvents.length > 0) {
                  _walletEvents$returnV = (_walletEvents = walletEvents[walletEvents.length - 1]) === null || _walletEvents === void 0 ? void 0 : _walletEvents.returnValues, _updatedWallet = _walletEvents$returnV._updatedWallet;
                  service.delegateOwnerWallet = _updatedWallet;
                }

                return _context9.abrupt("return", service);

              case 18:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getDeregisteredService(_x14) {
        return _getDeregisteredService.apply(this, arguments);
      }

      return getDeregisteredService;
    }()
  }, {
    key: "increaseStake",
    value: function () {
      var _increaseStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(amount) {
        var contractAddress, tx0, method, tx;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.stakingProxyClient.getAddress();

              case 2:
                contractAddress = _context10.sent;
                _context10.next = 5;
                return this.audiusTokenClient.approve(contractAddress, amount);

              case 5:
                tx0 = _context10.sent;
                _context10.next = 8;
                return this.getMethod('increaseStake', amount);

              case 8:
                method = _context10.sent;
                _context10.next = 11;
                return this.web3Manager.sendTransaction(method, 1000000);

              case 11:
                tx = _context10.sent;
                return _context10.abrupt("return", {
                  txReceipt: tx,
                  tokenApproveReceipt: tx0
                });

              case 13:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function increaseStake(_x15) {
        return _increaseStake.apply(this, arguments);
      }

      return increaseStake;
    }()
    /**
     * Makes a request to decrease stake
     * @param amount
     * @returns decrease stake lockup expiry block
     */

  }, {
    key: "requestDecreaseStake",
    value: function () {
      var _requestDecreaseStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(amount) {
        var requestDecreaseMethod, account, lockupExpiryBlock;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.getMethod('requestDecreaseStake', amount);

              case 2:
                requestDecreaseMethod = _context11.sent;
                _context11.next = 5;
                return this.web3Manager.sendTransaction(requestDecreaseMethod, // @ts-expect-error TODO: sendTransaction's signature seems pretty different
                1000000);

              case 5:
                account = this.web3Manager.getWalletAddress();
                _context11.next = 8;
                return this.getLockupExpiry(account);

              case 8:
                lockupExpiryBlock = _context11.sent;
                return _context11.abrupt("return", parseInt(lockupExpiryBlock));

              case 10:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function requestDecreaseStake(_x16) {
        return _requestDecreaseStake.apply(this, arguments);
      }

      return requestDecreaseStake;
    }()
    /**
     * Gets the pending decrease stake request for a given account
     * @param account wallet address to fetch for
     */

  }, {
    key: "getPendingDecreaseStakeRequest",
    value: function () {
      var _getPendingDecreaseStakeRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(account) {
        var requestInfoMethod, _yield$requestInfoMet, amount, lockupExpiryBlock;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getMethod('getPendingDecreaseStakeRequest', account);

              case 2:
                requestInfoMethod = _context12.sent;
                _context12.next = 5;
                return requestInfoMethod.call();

              case 5:
                _yield$requestInfoMet = _context12.sent;
                amount = _yield$requestInfoMet.amount;
                lockupExpiryBlock = _yield$requestInfoMet.lockupExpiryBlock;
                return _context12.abrupt("return", {
                  amount: Utils$b.toBN(amount),
                  lockupExpiryBlock: parseInt(lockupExpiryBlock)
                });

              case 9:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getPendingDecreaseStakeRequest(_x17) {
        return _getPendingDecreaseStakeRequest.apply(this, arguments);
      }

      return getPendingDecreaseStakeRequest;
    }()
    /**
     * Gets the pending decrease stake lockup duration
     */

  }, {
    key: "getDecreaseStakeLockupDuration",
    value: function () {
      var _getDecreaseStakeLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var requestInfoMethod, info;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.getMethod('getDecreaseStakeLockupDuration');

              case 2:
                requestInfoMethod = _context13.sent;
                _context13.next = 5;
                return requestInfoMethod.call();

              case 5:
                info = _context13.sent;
                return _context13.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getDecreaseStakeLockupDuration() {
        return _getDecreaseStakeLockupDuration.apply(this, arguments);
      }

      return getDecreaseStakeLockupDuration;
    }()
    /**
     * Gets the deployer cut lockup duration
     */

  }, {
    key: "getDeployerCutLockupDuration",
    value: function () {
      var _getDeployerCutLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var requestInfoMethod, info;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getMethod('getDeployerCutLockupDuration');

              case 2:
                requestInfoMethod = _context14.sent;
                _context14.next = 5;
                return requestInfoMethod.call();

              case 5:
                info = _context14.sent;
                return _context14.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getDeployerCutLockupDuration() {
        return _getDeployerCutLockupDuration.apply(this, arguments);
      }

      return getDeployerCutLockupDuration;
    }()
    /**
     * Cancels the pending decrease stake request
     * @param account wallet address to cancel request for
     */

  }, {
    key: "cancelDecreaseStakeRequest",
    value: function () {
      var _cancelDecreaseStakeRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(account) {
        var requestCancelDecreaseMethod;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.getMethod('cancelDecreaseStakeRequest', account);

              case 2:
                requestCancelDecreaseMethod = _context15.sent;
                _context15.next = 5;
                return this.web3Manager.sendTransaction(requestCancelDecreaseMethod, // @ts-expect-error TODO: double check sendTransaction
                1000000);

              case 5:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function cancelDecreaseStakeRequest(_x18) {
        return _cancelDecreaseStakeRequest.apply(this, arguments);
      }

      return cancelDecreaseStakeRequest;
    }()
    /**
     * Fetches the pending decrease stake lockup expiry block for a user
     * @param account wallet address to fetch for
     */

  }, {
    key: "getLockupExpiry",
    value: function () {
      var _getLockupExpiry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(account) {
        var _yield$this$getPendin, lockupExpiryBlock;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getPendingDecreaseStakeRequest(account);

              case 2:
                _yield$this$getPendin = _context16.sent;
                lockupExpiryBlock = _yield$this$getPendin.lockupExpiryBlock;
                return _context16.abrupt("return", parseInt(lockupExpiryBlock));

              case 5:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getLockupExpiry(_x19) {
        return _getLockupExpiry.apply(this, arguments);
      }

      return getLockupExpiry;
    }()
  }, {
    key: "decreaseStake",
    value: function () {
      var _decreaseStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this.getMethod('decreaseStake');

              case 2:
                method = _context17.sent;
                _context17.next = 5;
                return this.web3Manager.sendTransaction(method, 1000000);

              case 5:
                tx = _context17.sent;
                return _context17.abrupt("return", {
                  txReceipt: tx
                });

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function decreaseStake() {
        return _decreaseStake.apply(this, arguments);
      }

      return decreaseStake;
    }()
    /**
     * Deregisters a service
     * @param serviceType
     * @param endpoint
     */

  }, {
    key: "deregister",
    value: function () {
      var _deregister = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(serviceType, endpoint) {
        var _tx$events2, _tx$events2$Deregiste;

        var method, tx, returnValues;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getMethod('deregister', Utils$b.utf8ToHex(serviceType), endpoint);

              case 2:
                method = _context18.sent;
                _context18.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context18.sent;
                returnValues = (_tx$events2 = tx.events) === null || _tx$events2 === void 0 ? void 0 : (_tx$events2$Deregiste = _tx$events2['DeregisteredServiceProvider']) === null || _tx$events2$Deregiste === void 0 ? void 0 : _tx$events2$Deregiste.returnValues;
                return _context18.abrupt("return", {
                  txReceipt: tx,
                  spID: parseInt(returnValues._spID),
                  serviceType: Utils$b.hexToUtf8(returnValues._serviceType),
                  owner: returnValues._owner,
                  endpoint: returnValues._endpoint
                });

              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function deregister(_x20, _x21) {
        return _deregister.apply(this, arguments);
      }

      return deregister;
    }()
  }, {
    key: "getTotalServiceTypeProviders",
    value: function () {
      var _getTotalServiceTypeProviders = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(serviceType) {
        var method, count;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.getMethod('getTotalServiceTypeProviders', Utils$b.utf8ToHex(serviceType));

              case 2:
                method = _context19.sent;
                _context19.next = 5;
                return method.call();

              case 5:
                count = _context19.sent;
                return _context19.abrupt("return", parseInt(count));

              case 7:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getTotalServiceTypeProviders(_x22) {
        return _getTotalServiceTypeProviders.apply(this, arguments);
      }

      return getTotalServiceTypeProviders;
    }()
  }, {
    key: "getServiceProviderIdFromEndpoint",
    value: function () {
      var _getServiceProviderIdFromEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(endpoint) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getMethod('getServiceProviderIdFromEndpoint', endpoint);

              case 2:
                method = _context20.sent;
                _context20.next = 5;
                return method.call();

              case 5:
                info = _context20.sent;
                return _context20.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getServiceProviderIdFromEndpoint(_x23) {
        return _getServiceProviderIdFromEndpoint.apply(this, arguments);
      }

      return getServiceProviderIdFromEndpoint;
    }() // TODO: Remove this method after all consumers are using
    // `getServiceEndpointInfo` directly

  }, {
    key: "getServiceProviderInfo",
    value: function () {
      var _getServiceProviderInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(serviceType, serviceId) {
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this.getServiceEndpointInfo(serviceType, serviceId);

              case 2:
                return _context21.abrupt("return", _context21.sent);

              case 3:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getServiceProviderInfo(_x24, _x25) {
        return _getServiceProviderInfo.apply(this, arguments);
      }

      return getServiceProviderInfo;
    }()
  }, {
    key: "getServiceEndpointInfo",
    value: function () {
      var _getServiceEndpointInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(serviceType, serviceId) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getMethod('getServiceEndpointInfo', Utils$b.utf8ToHex(serviceType), serviceId);

              case 2:
                method = _context22.sent;
                _context22.next = 5;
                return method.call();

              case 5:
                info = _context22.sent;
                return _context22.abrupt("return", {
                  owner: info.owner,
                  endpoint: info.endpoint.replace(/\/$/, ''),
                  spID: parseInt(serviceId),
                  type: serviceType,
                  blockNumber: parseInt(info.blockNumber),
                  delegateOwnerWallet: info.delegateOwnerWallet
                });

              case 7:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getServiceEndpointInfo(_x26, _x27) {
        return _getServiceEndpointInfo.apply(this, arguments);
      }

      return getServiceEndpointInfo;
    }()
  }, {
    key: "getServiceProviderInfoFromEndpoint",
    value: function () {
      var _getServiceProviderInfoFromEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(endpoint) {
        var requestUrl, axiosRequestObj, resp, serviceType, serviceProviderId, info;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                requestUrl = urlJoin__default["default"](endpoint, 'health_check');
                axiosRequestObj = {
                  url: requestUrl,
                  method: 'get',
                  timeout: 1000
                };
                _context23.next = 4;
                return axios__default["default"](axiosRequestObj);

              case 4:
                resp = _context23.sent;
                serviceType = resp.data.data.service;
                _context23.next = 8;
                return this.getServiceProviderIdFromEndpoint(endpoint);

              case 8:
                serviceProviderId = _context23.sent;
                _context23.next = 11;
                return this.getServiceEndpointInfo(serviceType, serviceProviderId);

              case 11:
                info = _context23.sent;
                return _context23.abrupt("return", info);

              case 13:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getServiceProviderInfoFromEndpoint(_x28) {
        return _getServiceProviderInfoFromEndpoint.apply(this, arguments);
      }

      return getServiceProviderInfoFromEndpoint;
    }()
  }, {
    key: "getServiceProviderIdsFromAddress",
    value: function () {
      var _getServiceProviderIdsFromAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(ownerAddress, serviceType) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getMethod('getServiceProviderIdsFromAddress', ownerAddress, Utils$b.utf8ToHex(serviceType));

              case 2:
                method = _context24.sent;
                _context24.next = 5;
                return method.call();

              case 5:
                info = _context24.sent;
                return _context24.abrupt("return", info.map(function (id) {
                  return parseInt(id);
                }));

              case 7:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getServiceProviderIdsFromAddress(_x29, _x30) {
        return _getServiceProviderIdsFromAddress.apply(this, arguments);
      }

      return getServiceProviderIdsFromAddress;
    }()
  }, {
    key: "getServiceProviderIdFromAddress",
    value: function () {
      var _getServiceProviderIdFromAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(ownerAddress, serviceType) {
        var infos;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this.getServiceProviderIdsFromAddress(ownerAddress, serviceType);

              case 2:
                infos = _context25.sent;
                return _context25.abrupt("return", infos[0]);

              case 4:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getServiceProviderIdFromAddress(_x31, _x32) {
        return _getServiceProviderIdFromAddress.apply(this, arguments);
      }

      return getServiceProviderIdFromAddress;
    }()
  }, {
    key: "getServiceEndpointInfoFromAddress",
    value: function () {
      var _getServiceEndpointInfoFromAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(ownerAddress, serviceType) {
        var spId, spInfo;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.getServiceProviderIdFromAddress(ownerAddress, serviceType);

              case 2:
                spId = _context26.sent;
                _context26.next = 5;
                return this.getServiceEndpointInfo(serviceType, spId);

              case 5:
                _context26.t0 = _context26.sent;
                spInfo = [_context26.t0];
                return _context26.abrupt("return", spInfo);

              case 8:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getServiceEndpointInfoFromAddress(_x33, _x34) {
        return _getServiceEndpointInfoFromAddress.apply(this, arguments);
      }

      return getServiceEndpointInfoFromAddress;
    }()
    /**
     * Returns all service providers of requested `serviceType`
     * Returns array of objects with schema { blockNumber, delegateOwnerWallet, endpoint, owner, spID, type }
     */

  }, {
    key: "getServiceProviderList",
    value: function () {
      var _getServiceProviderList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(serviceType) {
        var _this2 = this;

        var numberOfProviders, providerList;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getTotalServiceTypeProviders(serviceType);

              case 2:
                numberOfProviders = _context28.sent;
                _context28.next = 5;
                return Promise.all(require$$0$4.range(1, numberOfProviders + 1).map( /*#__PURE__*/function () {
                  var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(i) {
                    return regeneratorRuntime.wrap(function _callee27$(_context27) {
                      while (1) {
                        switch (_context27.prev = _context27.next) {
                          case 0:
                            _context27.next = 2;
                            return _this2.getServiceEndpointInfo(serviceType, i);

                          case 2:
                            return _context27.abrupt("return", _context27.sent);

                          case 3:
                          case "end":
                            return _context27.stop();
                        }
                      }
                    }, _callee27);
                  }));

                  return function (_x36) {
                    return _ref8.apply(this, arguments);
                  };
                }()));

              case 5:
                providerList = _context28.sent;
                return _context28.abrupt("return", providerList.filter(function (provider) {
                  return provider.endpoint !== '';
                }));

              case 7:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getServiceProviderList(_x35) {
        return _getServiceProviderList.apply(this, arguments);
      }

      return getServiceProviderList;
    }()
  }, {
    key: "updateDecreaseStakeLockupDuration",
    value: function () {
      var _updateDecreaseStakeLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(duration) {
        var method;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return this.getGovernedMethod('updateDecreaseStakeLockupDuration', duration);

              case 2:
                method = _context29.sent;
                _context29.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context29.abrupt("return", _context29.sent);

              case 6:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function updateDecreaseStakeLockupDuration(_x37) {
        return _updateDecreaseStakeLockupDuration.apply(this, arguments);
      }

      return updateDecreaseStakeLockupDuration;
    }()
  }, {
    key: "getServiceProviderDetails",
    value: function () {
      var _getServiceProviderDetails = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(serviceProviderAddress) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getMethod('getServiceProviderDetails', serviceProviderAddress);

              case 2:
                method = _context30.sent;
                _context30.next = 5;
                return method.call();

              case 5:
                info = _context30.sent;
                return _context30.abrupt("return", {
                  deployerCut: parseInt(info.deployerCut),
                  deployerStake: Utils$b.toBN(info.deployerStake),
                  maxAccountStake: Utils$b.toBN(info.maxAccountStake),
                  minAccountStake: Utils$b.toBN(info.minAccountStake),
                  numberOfEndpoints: parseInt(info.numberOfEndpoints),
                  validBounds: info.validBounds
                });

              case 7:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getServiceProviderDetails(_x38) {
        return _getServiceProviderDetails.apply(this, arguments);
      }

      return getServiceProviderDetails;
    }()
  }, {
    key: "updateDelegateOwnerWallet",
    value: function () {
      var _updateDelegateOwnerWallet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(serviceType, endpoint, updatedDelegateOwnerWallet) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                _context31.next = 2;
                return this.getMethod('updateDelegateOwnerWallet', Utils$b.utf8ToHex(serviceType), endpoint, updatedDelegateOwnerWallet);

              case 2:
                method = _context31.sent;
                _context31.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context31.sent;
                return _context31.abrupt("return", tx);

              case 7:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function updateDelegateOwnerWallet(_x39, _x40, _x41) {
        return _updateDelegateOwnerWallet.apply(this, arguments);
      }

      return updateDelegateOwnerWallet;
    }()
  }, {
    key: "updateEndpoint",
    value: function () {
      var _updateEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(serviceType, oldEndpoint, newEndpoint) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getMethod('updateEndpoint', Utils$b.utf8ToHex(serviceType), oldEndpoint, newEndpoint);

              case 2:
                method = _context32.sent;
                _context32.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context32.sent;
                return _context32.abrupt("return", tx);

              case 7:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function updateEndpoint(_x42, _x43, _x44) {
        return _updateEndpoint.apply(this, arguments);
      }

      return updateEndpoint;
    }()
  }, {
    key: "requestUpdateDeployerCut",
    value: function () {
      var _requestUpdateDeployerCut = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(ownerAddress, deployerCut) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                _context33.next = 2;
                return this.getMethod('requestUpdateDeployerCut', ownerAddress, deployerCut);

              case 2:
                method = _context33.sent;
                _context33.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context33.sent;
                return _context33.abrupt("return", tx);

              case 7:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function requestUpdateDeployerCut(_x45, _x46) {
        return _requestUpdateDeployerCut.apply(this, arguments);
      }

      return requestUpdateDeployerCut;
    }()
  }, {
    key: "getPendingUpdateDeployerCutRequest",
    value: function () {
      var _getPendingUpdateDeployerCutRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(ownerAddress) {
        var method, _yield$method$call, lockupExpiryBlock, newDeployerCut;

        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return this.getMethod('getPendingUpdateDeployerCutRequest', ownerAddress);

              case 2:
                method = _context34.sent;
                _context34.next = 5;
                return method.call();

              case 5:
                _yield$method$call = _context34.sent;
                lockupExpiryBlock = _yield$method$call.lockupExpiryBlock;
                newDeployerCut = _yield$method$call.newDeployerCut;
                return _context34.abrupt("return", {
                  lockupExpiryBlock: parseInt(lockupExpiryBlock),
                  newDeployerCut: parseInt(newDeployerCut)
                });

              case 9:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getPendingUpdateDeployerCutRequest(_x47) {
        return _getPendingUpdateDeployerCutRequest.apply(this, arguments);
      }

      return getPendingUpdateDeployerCutRequest;
    }()
  }, {
    key: "cancelUpdateDeployerCut",
    value: function () {
      var _cancelUpdateDeployerCut = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(ownerAddress) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                _context35.next = 2;
                return this.getMethod('cancelUpdateDeployerCut', ownerAddress);

              case 2:
                method = _context35.sent;
                _context35.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context35.sent;
                return _context35.abrupt("return", tx);

              case 7:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function cancelUpdateDeployerCut(_x48) {
        return _cancelUpdateDeployerCut.apply(this, arguments);
      }

      return cancelUpdateDeployerCut;
    }()
  }, {
    key: "updateDeployerCut",
    value: function () {
      var _updateDeployerCut = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(ownerAddress) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                _context36.next = 2;
                return this.getMethod('updateDeployerCut', ownerAddress);

              case 2:
                method = _context36.sent;
                _context36.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context36.sent;
                return _context36.abrupt("return", tx);

              case 7:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function updateDeployerCut(_x49) {
        return _updateDeployerCut.apply(this, arguments);
      }

      return updateDeployerCut;
    }()
  }, {
    key: "updateServiceProviderStake",
    value: function () {
      var _updateServiceProviderStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(ownerAddress, newAmount) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                _context37.next = 2;
                return this.getMethod('updateServiceProviderStake', ownerAddress, newAmount);

              case 2:
                method = _context37.sent;
                _context37.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context37.sent;
                return _context37.abrupt("return", tx);

              case 7:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function updateServiceProviderStake(_x50, _x51) {
        return _updateServiceProviderStake.apply(this, arguments);
      }

      return updateServiceProviderStake;
    }()
  }]);

  return ServiceProviderFactoryClient;
}(GovernedContractClient);

var StakingProxyClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(StakingProxyClient, _ContractClient);

  var _super = _createSuper(StakingProxyClient);

  function StakingProxyClient(ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, audiusTokenClient) {
    var _this;

    var logger = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : console;

    _classCallCheck(this, StakingProxyClient);

    _this = _super.call(this, ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, logger);
    _this.audiusTokenClient = audiusTokenClient;
    _this.toBN = ethWeb3Manager.getWeb3().utils.toBN;
    return _this;
  }

  _createClass(StakingProxyClient, [{
    key: "token",
    value: function () {
      var _token = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var method;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getMethod('token');

              case 2:
                method = _context.sent;
                return _context.abrupt("return", method.call());

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function token() {
        return _token.apply(this, arguments);
      }

      return token;
    }()
  }, {
    key: "totalStaked",
    value: function () {
      var _totalStaked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var method;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getMethod('totalStaked');

              case 2:
                method = _context2.sent;
                _context2.t0 = this;
                _context2.next = 6;
                return method.call();

              case 6:
                _context2.t1 = _context2.sent;
                return _context2.abrupt("return", _context2.t0.toBN.call(_context2.t0, _context2.t1));

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function totalStaked() {
        return _totalStaked.apply(this, arguments);
      }

      return totalStaked;
    }()
  }, {
    key: "supportsHistory",
    value: function () {
      var _supportsHistory = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var method;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getMethod('supportsHistory');

              case 2:
                method = _context3.sent;
                return _context3.abrupt("return", method.call());

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function supportsHistory() {
        return _supportsHistory.apply(this, arguments);
      }

      return supportsHistory;
    }()
  }, {
    key: "totalStakedFor",
    value: function () {
      var _totalStakedFor = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(account) {
        var method;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('totalStakedFor', account);

              case 2:
                method = _context4.sent;
                _context4.t0 = this;
                _context4.next = 6;
                return method.call();

              case 6:
                _context4.t1 = _context4.sent;
                return _context4.abrupt("return", _context4.t0.toBN.call(_context4.t0, _context4.t1));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function totalStakedFor(_x) {
        return _totalStakedFor.apply(this, arguments);
      }

      return totalStakedFor;
    }()
  }, {
    key: "totalStakedForAt",
    value: function () {
      var _totalStakedForAt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(account, blockNumber) {
        var method;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getMethod('totalStakedForAt', account, blockNumber);

              case 2:
                method = _context5.sent;
                _context5.t0 = this;
                _context5.next = 6;
                return method.call();

              case 6:
                _context5.t1 = _context5.sent;
                return _context5.abrupt("return", _context5.t0.toBN.call(_context5.t0, _context5.t1));

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function totalStakedForAt(_x2, _x3) {
        return _totalStakedForAt.apply(this, arguments);
      }

      return totalStakedForAt;
    }()
  }, {
    key: "totalStakedAt",
    value: function () {
      var _totalStakedAt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(blockNumber) {
        var method;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getMethod('totalStakedAt', blockNumber);

              case 2:
                method = _context6.sent;
                _context6.t0 = this;
                _context6.next = 6;
                return method.call();

              case 6:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", _context6.t0.toBN.call(_context6.t0, _context6.t1));

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function totalStakedAt(_x4) {
        return _totalStakedAt.apply(this, arguments);
      }

      return totalStakedAt;
    }()
  }, {
    key: "isStaker",
    value: function () {
      var _isStaker = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(account) {
        var method;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getMethod('isStaker', account);

              case 2:
                method = _context7.sent;
                return _context7.abrupt("return", method.call());

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function isStaker(_x5) {
        return _isStaker.apply(this, arguments);
      }

      return isStaker;
    }()
  }, {
    key: "getDelegateManagerAddress",
    value: function () {
      var _getDelegateManagerAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var method;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getMethod('getDelegateManagerAddress');

              case 2:
                method = _context8.sent;
                return _context8.abrupt("return", method.call());

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getDelegateManagerAddress() {
        return _getDelegateManagerAddress.apply(this, arguments);
      }

      return getDelegateManagerAddress;
    }()
  }, {
    key: "getClaimsManagerAddress",
    value: function () {
      var _getClaimsManagerAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var method;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getMethod('getClaimsManagerAddress');

              case 2:
                method = _context9.sent;
                return _context9.abrupt("return", method.call());

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getClaimsManagerAddress() {
        return _getClaimsManagerAddress.apply(this, arguments);
      }

      return getClaimsManagerAddress;
    }()
  }, {
    key: "getServiceProviderFactoryAddress",
    value: function () {
      var _getServiceProviderFactoryAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var method;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getMethod('getServiceProviderFactoryAddress');

              case 2:
                method = _context10.sent;
                return _context10.abrupt("return", method.call());

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getServiceProviderFactoryAddress() {
        return _getServiceProviderFactoryAddress.apply(this, arguments);
      }

      return getServiceProviderFactoryAddress;
    }()
  }, {
    key: "getGovernanceAddress",
    value: function () {
      var _getGovernanceAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var method;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.getMethod('getGovernanceAddress');

              case 2:
                method = _context11.sent;
                return _context11.abrupt("return", method.call());

              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getGovernanceAddress() {
        return _getGovernanceAddress.apply(this, arguments);
      }

      return getGovernanceAddress;
    }()
  }, {
    key: "getLastClaimedBlockForUser",
    value: function () {
      var _getLastClaimedBlockForUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getMethod('lastClaimedFor', this.web3Manager.getWalletAddress());

              case 2:
                method = _context12.sent;
                _context12.next = 5;
                return method.call();

              case 5:
                tx = _context12.sent;
                return _context12.abrupt("return", tx);

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getLastClaimedBlockForUser() {
        return _getLastClaimedBlockForUser.apply(this, arguments);
      }

      return getLastClaimedBlockForUser;
    }()
  }]);

  return StakingProxyClient;
}(ContractClient$7);

var DelegateManagerClient = /*#__PURE__*/function (_GovernedContractClie) {
  _inherits(DelegateManagerClient, _GovernedContractClie);

  var _super = _createSuper(DelegateManagerClient);

  function DelegateManagerClient(ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, audiusTokenClient, stakingProxyClient, governanceClient) {
    var _this;

    var logger = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : console;

    _classCallCheck(this, DelegateManagerClient);

    _this = _super.call(this, ethWeb3Manager, contractABI, contractRegistryKey, getRegistryAddress, governanceClient, logger);
    _this.audiusTokenClient = audiusTokenClient;
    _this.stakingProxyClient = stakingProxyClient;
    return _this;
  }

  _createClass(DelegateManagerClient, [{
    key: "delegateStake",
    value: function () {
      var _delegateStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(targetSP, amount) {
        var _tx$events, _tx$events$IncreaseDe;

        var contractAddress, tx0, method, tx, returnValues;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.stakingProxyClient.getAddress();

              case 2:
                contractAddress = _context.sent;
                _context.next = 5;
                return this.audiusTokenClient.approve(contractAddress, amount);

              case 5:
                tx0 = _context.sent;
                _context.next = 8;
                return this.getMethod('delegateStake', targetSP, amount);

              case 8:
                method = _context.sent;
                _context.next = 11;
                return this.web3Manager.sendTransaction(method);

              case 11:
                tx = _context.sent;
                returnValues = (_tx$events = tx.events) === null || _tx$events === void 0 ? void 0 : (_tx$events$IncreaseDe = _tx$events['IncreaseDelegatedStake']) === null || _tx$events$IncreaseDe === void 0 ? void 0 : _tx$events$IncreaseDe.returnValues;
                return _context.abrupt("return", {
                  txReceipt: tx,
                  tokenApproveReceipt: tx0,
                  delegator: returnValues === null || returnValues === void 0 ? void 0 : returnValues._delegator,
                  serviceProvider: returnValues === null || returnValues === void 0 ? void 0 : returnValues._serviceProvider,
                  increaseAmount: Utils$b.toBN(returnValues === null || returnValues === void 0 ? void 0 : returnValues._increaseAmount)
                });

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function delegateStake(_x, _x2) {
        return _delegateStake.apply(this, arguments);
      }

      return delegateStake;
    }()
    /* Pass either delegator or serviceProvider filters */

  }, {
    key: "getIncreaseDelegateStakeEvents",
    value: function () {
      var _getIncreaseDelegateStakeEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref) {
        var delegator, serviceProvider, _ref$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                delegator = _ref.delegator, serviceProvider = _ref.serviceProvider, _ref$queryStartBlock = _ref.queryStartBlock, queryStartBlock = _ref$queryStartBlock === void 0 ? 0 : _ref$queryStartBlock;
                _context2.next = 3;
                return this.getContract();

              case 3:
                contract = _context2.sent;
                filter = {};

                if (delegator) {
                  filter._delegator = delegator;
                } else {
                  filter._serviceProvider = serviceProvider;
                }

                _context2.next = 8;
                return contract.getPastEvents('IncreaseDelegatedStake', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 8:
                events = _context2.sent;
                return _context2.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    delegator: event.returnValues['_delegator'],
                    increaseAmount: Utils$b.toBN(event.returnValues['_increaseAmount']),
                    serviceProvider: event.returnValues['_serviceProvider']
                  };
                }));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getIncreaseDelegateStakeEvents(_x3) {
        return _getIncreaseDelegateStakeEvents.apply(this, arguments);
      }

      return getIncreaseDelegateStakeEvents;
    }()
  }, {
    key: "getDecreaseDelegateStakeEvents",
    value: function () {
      var _getDecreaseDelegateStakeEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref2) {
        var delegator, serviceProvider, _ref2$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                delegator = _ref2.delegator, serviceProvider = _ref2.serviceProvider, _ref2$queryStartBlock = _ref2.queryStartBlock, queryStartBlock = _ref2$queryStartBlock === void 0 ? 0 : _ref2$queryStartBlock;
                _context3.next = 3;
                return this.getContract();

              case 3:
                contract = _context3.sent;
                filter = {};

                if (delegator) {
                  filter._delegator = delegator;
                }

                if (serviceProvider) {
                  filter._serviceProvider = serviceProvider;
                }

                _context3.next = 9;
                return contract.getPastEvents('UndelegateStakeRequestEvaluated', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 9:
                events = _context3.sent;
                return _context3.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    delegator: event.returnValues['_delegator'],
                    amount: Utils$b.toBN(event.returnValues['_amount']),
                    serviceProvider: event.returnValues['_serviceProvider']
                  };
                }));

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getDecreaseDelegateStakeEvents(_x4) {
        return _getDecreaseDelegateStakeEvents.apply(this, arguments);
      }

      return getDecreaseDelegateStakeEvents;
    }()
  }, {
    key: "getUndelegateStakeRequestedEvents",
    value: function () {
      var _getUndelegateStakeRequestedEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref3) {
        var delegator, serviceProvider, _ref3$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                delegator = _ref3.delegator, serviceProvider = _ref3.serviceProvider, _ref3$queryStartBlock = _ref3.queryStartBlock, queryStartBlock = _ref3$queryStartBlock === void 0 ? 0 : _ref3$queryStartBlock;
                _context4.next = 3;
                return this.getContract();

              case 3:
                contract = _context4.sent;
                filter = {};

                if (delegator) {
                  filter._delegator = delegator;
                }

                if (serviceProvider) {
                  filter._serviceProvider = serviceProvider;
                }

                _context4.next = 9;
                return contract.getPastEvents('UndelegateStakeRequested', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 9:
                events = _context4.sent;
                return _context4.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    lockupExpiryBlock: parseInt(event.returnValues['_lockupExpiryBlock']),
                    delegator: event.returnValues['_delegator'],
                    amount: Utils$b.toBN(event.returnValues['_amount']),
                    serviceProvider: event.returnValues['_serviceProvider']
                  };
                }));

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getUndelegateStakeRequestedEvents(_x5) {
        return _getUndelegateStakeRequestedEvents.apply(this, arguments);
      }

      return getUndelegateStakeRequestedEvents;
    }()
  }, {
    key: "getUndelegateStakeCancelledEvents",
    value: function () {
      var _getUndelegateStakeCancelledEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref4) {
        var delegator, serviceProvider, _ref4$queryStartBlock, queryStartBlock, contract, filter, events;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                delegator = _ref4.delegator, serviceProvider = _ref4.serviceProvider, _ref4$queryStartBlock = _ref4.queryStartBlock, queryStartBlock = _ref4$queryStartBlock === void 0 ? 0 : _ref4$queryStartBlock;
                _context5.next = 3;
                return this.getContract();

              case 3:
                contract = _context5.sent;
                filter = {};

                if (delegator) {
                  filter._delegator = delegator;
                }

                if (serviceProvider) {
                  filter._serviceProvider = serviceProvider;
                }

                _context5.next = 9;
                return contract.getPastEvents('UndelegateStakeRequestCancelled', {
                  fromBlock: queryStartBlock,
                  filter: filter
                });

              case 9:
                events = _context5.sent;
                return _context5.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    delegator: event.returnValues['_delegator'],
                    amount: Utils$b.toBN(event.returnValues['_amount']),
                    serviceProvider: event.returnValues['_serviceProvider']
                  };
                }));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getUndelegateStakeCancelledEvents(_x6) {
        return _getUndelegateStakeCancelledEvents.apply(this, arguments);
      }

      return getUndelegateStakeCancelledEvents;
    }()
  }, {
    key: "getClaimEvents",
    value: function () {
      var _getClaimEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref5) {
        var claimer, _ref5$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                claimer = _ref5.claimer, _ref5$queryStartBlock = _ref5.queryStartBlock, queryStartBlock = _ref5$queryStartBlock === void 0 ? 0 : _ref5$queryStartBlock;
                _context6.next = 3;
                return this.getContract();

              case 3:
                contract = _context6.sent;
                _context6.next = 6;
                return contract.getPastEvents('Claim', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _claimer: claimer
                  }
                });

              case 6:
                events = _context6.sent;
                return _context6.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    claimer: event.returnValues['_claimer'],
                    rewards: Utils$b.toBN(event.returnValues['_rewards']),
                    newTotal: Utils$b.toBN(event.returnValues['_newTotal'])
                  };
                }));

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getClaimEvents(_x7) {
        return _getClaimEvents.apply(this, arguments);
      }

      return getClaimEvents;
    }()
  }, {
    key: "getSlashEvents",
    value: function () {
      var _getSlashEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(_ref6) {
        var target, _ref6$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                target = _ref6.target, _ref6$queryStartBlock = _ref6.queryStartBlock, queryStartBlock = _ref6$queryStartBlock === void 0 ? 0 : _ref6$queryStartBlock;
                _context7.next = 3;
                return this.getContract();

              case 3:
                contract = _context7.sent;
                _context7.next = 6;
                return contract.getPastEvents('Slash', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _target: target
                  }
                });

              case 6:
                events = _context7.sent;
                return _context7.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    target: event.returnValues['_target'],
                    amount: Utils$b.toBN(event.returnValues['_amount']),
                    newTotal: Utils$b.toBN(event.returnValues['_newTotal'])
                  };
                }));

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getSlashEvents(_x8) {
        return _getSlashEvents.apply(this, arguments);
      }

      return getSlashEvents;
    }()
  }, {
    key: "getDelegatorRemovedEvents",
    value: function () {
      var _getDelegatorRemovedEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref7) {
        var target, _ref7$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                target = _ref7.target, _ref7$queryStartBlock = _ref7.queryStartBlock, queryStartBlock = _ref7$queryStartBlock === void 0 ? 0 : _ref7$queryStartBlock;
                _context8.next = 3;
                return this.getContract();

              case 3:
                contract = _context8.sent;
                _context8.next = 6;
                return contract.getPastEvents('DelegatorRemoved', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _target: target
                  }
                });

              case 6:
                events = _context8.sent;
                return _context8.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    serviceProvider: event.returnValues['_serviceProvider'],
                    delegator: event.returnValues['_delegator'],
                    unstakedAmount: Utils$b.toBN(event.returnValues['_unstakedAmount'])
                  };
                }));

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getDelegatorRemovedEvents(_x9) {
        return _getDelegatorRemovedEvents.apply(this, arguments);
      }

      return getDelegatorRemovedEvents;
    }()
  }, {
    key: "requestUndelegateStake",
    value: function () {
      var _requestUndelegateStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(targetSP, amount) {
        var method;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getMethod('requestUndelegateStake', targetSP, amount);

              case 2:
                method = _context9.sent;
                _context9.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context9.abrupt("return", _context9.sent);

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function requestUndelegateStake(_x10, _x11) {
        return _requestUndelegateStake.apply(this, arguments);
      }

      return requestUndelegateStake;
    }()
  }, {
    key: "cancelUndelegateStakeRequest",
    value: function () {
      var _cancelUndelegateStakeRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var method;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getMethod('cancelUndelegateStakeRequest');

              case 2:
                method = _context10.sent;
                _context10.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context10.abrupt("return", _context10.sent);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function cancelUndelegateStakeRequest() {
        return _cancelUndelegateStakeRequest.apply(this, arguments);
      }

      return cancelUndelegateStakeRequest;
    }()
  }, {
    key: "undelegateStake",
    value: function () {
      var _undelegateStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var _tx$events2, _tx$events2$Undelegat;

        var method, tx, returnValues;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.getMethod('undelegateStake');

              case 2:
                method = _context11.sent;
                _context11.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context11.sent;
                returnValues = (_tx$events2 = tx.events) === null || _tx$events2 === void 0 ? void 0 : (_tx$events2$Undelegat = _tx$events2['UndelegateStakeRequestEvaluated']) === null || _tx$events2$Undelegat === void 0 ? void 0 : _tx$events2$Undelegat.returnValues;
                return _context11.abrupt("return", {
                  txReceipt: tx,
                  delegator: returnValues._delegator,
                  serviceProvider: returnValues._serviceProvider,
                  decreaseAmount: Utils$b.toBN(returnValues._amount)
                });

              case 8:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function undelegateStake() {
        return _undelegateStake.apply(this, arguments);
      }

      return undelegateStake;
    }()
  }, {
    key: "claimRewards",
    value: function () {
      var _claimRewards = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(serviceProvider) {
        var txRetries,
            method,
            _args12 = arguments;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                txRetries = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : 5;
                _context12.next = 3;
                return this.getMethod('claimRewards', serviceProvider);

              case 3:
                method = _context12.sent;
                _context12.next = 6;
                return this.web3Manager.sendTransaction(method, null, null, txRetries);

              case 6:
                return _context12.abrupt("return", _context12.sent);

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function claimRewards(_x12) {
        return _claimRewards.apply(this, arguments);
      }

      return claimRewards;
    }()
  }, {
    key: "requestRemoveDelegator",
    value: function () {
      var _requestRemoveDelegator = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(serviceProvider, delegator) {
        var method;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.getMethod('requestRemoveDelegator', serviceProvider, delegator);

              case 2:
                method = _context13.sent;
                _context13.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context13.abrupt("return", _context13.sent);

              case 6:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function requestRemoveDelegator(_x13, _x14) {
        return _requestRemoveDelegator.apply(this, arguments);
      }

      return requestRemoveDelegator;
    }()
  }, {
    key: "cancelRemoveDelegatorRequest",
    value: function () {
      var _cancelRemoveDelegatorRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(serviceProvider, delegator) {
        var method;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.getMethod('cancelRemoveDelegatorRequest', serviceProvider, delegator);

              case 2:
                method = _context14.sent;
                _context14.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function cancelRemoveDelegatorRequest(_x15, _x16) {
        return _cancelRemoveDelegatorRequest.apply(this, arguments);
      }

      return cancelRemoveDelegatorRequest;
    }()
  }, {
    key: "removeDelegator",
    value: function () {
      var _removeDelegator = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(serviceProvider, delegator) {
        var _tx$events3, _tx$events3$RemoveDel;

        var method, tx, returnValues;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.getMethod('removeDelegator', serviceProvider, delegator);

              case 2:
                method = _context15.sent;
                _context15.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                tx = _context15.sent;
                returnValues = (_tx$events3 = tx.events) === null || _tx$events3 === void 0 ? void 0 : (_tx$events3$RemoveDel = _tx$events3['RemoveDelegatorRequestEvaluated']) === null || _tx$events3$RemoveDel === void 0 ? void 0 : _tx$events3$RemoveDel.returnValues;
                return _context15.abrupt("return", {
                  txReceipt: tx,
                  delegator: returnValues._delegator,
                  serviceProvider: returnValues._serviceProvider,
                  unstakedAmount: Utils$b.toBN(returnValues._unstakedAmount)
                });

              case 8:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function removeDelegator(_x17, _x18) {
        return _removeDelegator.apply(this, arguments);
      }

      return removeDelegator;
    }() // ========================================= View Functions =========================================

  }, {
    key: "getDelegatorsList",
    value: function () {
      var _getDelegatorsList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(serviceProvider) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getMethod('getDelegatorsList', serviceProvider);

              case 2:
                method = _context16.sent;
                _context16.next = 5;
                return method.call();

              case 5:
                info = _context16.sent;
                return _context16.abrupt("return", info);

              case 7:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getDelegatorsList(_x19) {
        return _getDelegatorsList.apply(this, arguments);
      }

      return getDelegatorsList;
    }()
  }, {
    key: "getTotalDelegatedToServiceProvider",
    value: function () {
      var _getTotalDelegatedToServiceProvider = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(serviceProvider) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this.getMethod('getTotalDelegatedToServiceProvider', serviceProvider);

              case 2:
                method = _context17.sent;
                _context17.next = 5;
                return method.call();

              case 5:
                info = _context17.sent;
                return _context17.abrupt("return", Utils$b.toBN(info));

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getTotalDelegatedToServiceProvider(_x20) {
        return _getTotalDelegatedToServiceProvider.apply(this, arguments);
      }

      return getTotalDelegatedToServiceProvider;
    }()
  }, {
    key: "getTotalDelegatorStake",
    value: function () {
      var _getTotalDelegatorStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(delegator) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getMethod('getTotalDelegatorStake', delegator);

              case 2:
                method = _context18.sent;
                _context18.next = 5;
                return method.call();

              case 5:
                info = _context18.sent;
                return _context18.abrupt("return", Utils$b.toBN(info));

              case 7:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getTotalDelegatorStake(_x21) {
        return _getTotalDelegatorStake.apply(this, arguments);
      }

      return getTotalDelegatorStake;
    }()
  }, {
    key: "getTotalLockedDelegationForServiceProvider",
    value: function () {
      var _getTotalLockedDelegationForServiceProvider = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(serviceProvider) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.getMethod('getTotalLockedDelegationForServiceProvider', serviceProvider);

              case 2:
                method = _context19.sent;
                _context19.next = 5;
                return method.call();

              case 5:
                info = _context19.sent;
                return _context19.abrupt("return", Utils$b.toBN(info));

              case 7:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getTotalLockedDelegationForServiceProvider(_x22) {
        return _getTotalLockedDelegationForServiceProvider.apply(this, arguments);
      }

      return getTotalLockedDelegationForServiceProvider;
    }()
  }, {
    key: "getDelegatorStakeForServiceProvider",
    value: function () {
      var _getDelegatorStakeForServiceProvider = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(delegator, serviceProvider) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getMethod('getDelegatorStakeForServiceProvider', delegator, serviceProvider);

              case 2:
                method = _context20.sent;
                _context20.next = 5;
                return method.call();

              case 5:
                info = _context20.sent;
                return _context20.abrupt("return", Utils$b.toBN(info));

              case 7:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getDelegatorStakeForServiceProvider(_x23, _x24) {
        return _getDelegatorStakeForServiceProvider.apply(this, arguments);
      }

      return getDelegatorStakeForServiceProvider;
    }()
  }, {
    key: "getPendingUndelegateRequest",
    value: function () {
      var _getPendingUndelegateRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(delegator) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this.getMethod('getPendingUndelegateRequest', delegator);

              case 2:
                method = _context21.sent;
                _context21.next = 5;
                return method.call();

              case 5:
                info = _context21.sent;
                return _context21.abrupt("return", {
                  amount: Utils$b.toBN(info.amount),
                  lockupExpiryBlock: parseInt(info.lockupExpiryBlock),
                  target: info.target
                });

              case 7:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getPendingUndelegateRequest(_x25) {
        return _getPendingUndelegateRequest.apply(this, arguments);
      }

      return getPendingUndelegateRequest;
    }()
  }, {
    key: "getPendingRemoveDelegatorRequest",
    value: function () {
      var _getPendingRemoveDelegatorRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(serviceProvider, delegator) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getMethod('getPendingRemoveDelegatorRequest', serviceProvider, delegator);

              case 2:
                method = _context22.sent;
                _context22.next = 5;
                return method.call();

              case 5:
                info = _context22.sent;
                return _context22.abrupt("return", {
                  lockupExpiryBlock: parseInt(info)
                });

              case 7:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getPendingRemoveDelegatorRequest(_x26, _x27) {
        return _getPendingRemoveDelegatorRequest.apply(this, arguments);
      }

      return getPendingRemoveDelegatorRequest;
    }()
  }, {
    key: "getUndelegateLockupDuration",
    value: function () {
      var _getUndelegateLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.getMethod('getUndelegateLockupDuration');

              case 2:
                method = _context23.sent;
                _context23.next = 5;
                return method.call();

              case 5:
                info = _context23.sent;
                return _context23.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getUndelegateLockupDuration() {
        return _getUndelegateLockupDuration.apply(this, arguments);
      }

      return getUndelegateLockupDuration;
    }()
  }, {
    key: "getMaxDelegators",
    value: function () {
      var _getMaxDelegators = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getMethod('getMaxDelegators');

              case 2:
                method = _context24.sent;
                _context24.next = 5;
                return method.call();

              case 5:
                info = _context24.sent;
                return _context24.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getMaxDelegators() {
        return _getMaxDelegators.apply(this, arguments);
      }

      return getMaxDelegators;
    }()
  }, {
    key: "getMinDelegationAmount",
    value: function () {
      var _getMinDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this.getMethod('getMinDelegationAmount');

              case 2:
                method = _context25.sent;
                _context25.next = 5;
                return method.call();

              case 5:
                info = _context25.sent;
                return _context25.abrupt("return", Utils$b.toBN(info));

              case 7:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getMinDelegationAmount() {
        return _getMinDelegationAmount.apply(this, arguments);
      }

      return getMinDelegationAmount;
    }()
  }, {
    key: "getRemoveDelegatorLockupDuration",
    value: function () {
      var _getRemoveDelegatorLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.getMethod('getRemoveDelegatorLockupDuration');

              case 2:
                method = _context26.sent;
                _context26.next = 5;
                return method.call();

              case 5:
                info = _context26.sent;
                return _context26.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getRemoveDelegatorLockupDuration() {
        return _getRemoveDelegatorLockupDuration.apply(this, arguments);
      }

      return getRemoveDelegatorLockupDuration;
    }()
  }, {
    key: "getRemoveDelegatorEvalDuration",
    value: function () {
      var _getRemoveDelegatorEvalDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return this.getMethod('getRemoveDelegatorEvalDuration');

              case 2:
                method = _context27.sent;
                _context27.next = 5;
                return method.call();

              case 5:
                info = _context27.sent;
                return _context27.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getRemoveDelegatorEvalDuration() {
        return _getRemoveDelegatorEvalDuration.apply(this, arguments);
      }

      return getRemoveDelegatorEvalDuration;
    }()
  }, {
    key: "getGovernanceAddress",
    value: function () {
      var _getGovernanceAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getMethod('getGovernanceAddress');

              case 2:
                method = _context28.sent;
                _context28.next = 5;
                return method.call();

              case 5:
                info = _context28.sent;
                return _context28.abrupt("return", info);

              case 7:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getGovernanceAddress() {
        return _getGovernanceAddress.apply(this, arguments);
      }

      return getGovernanceAddress;
    }()
  }, {
    key: "getServiceProviderFactoryAddress",
    value: function () {
      var _getServiceProviderFactoryAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return this.getMethod('getServiceProviderFactoryAddress');

              case 2:
                method = _context29.sent;
                _context29.next = 5;
                return method.call();

              case 5:
                info = _context29.sent;
                return _context29.abrupt("return", info);

              case 7:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getServiceProviderFactoryAddress() {
        return _getServiceProviderFactoryAddress.apply(this, arguments);
      }

      return getServiceProviderFactoryAddress;
    }()
  }, {
    key: "getClaimsManagerAddress",
    value: function () {
      var _getClaimsManagerAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this.getMethod('getClaimsManagerAddress');

              case 2:
                method = _context30.sent;
                _context30.next = 5;
                return method.call();

              case 5:
                info = _context30.sent;
                return _context30.abrupt("return", info);

              case 7:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getClaimsManagerAddress() {
        return _getClaimsManagerAddress.apply(this, arguments);
      }

      return getClaimsManagerAddress;
    }()
  }, {
    key: "getStakingAddress",
    value: function () {
      var _getStakingAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                _context31.next = 2;
                return this.getMethod('getStakingAddress');

              case 2:
                method = _context31.sent;
                _context31.next = 5;
                return method.call();

              case 5:
                info = _context31.sent;
                return _context31.abrupt("return", info);

              case 7:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getStakingAddress() {
        return _getStakingAddress.apply(this, arguments);
      }

      return getStakingAddress;
    }()
  }, {
    key: "getSPMinDelegationAmount",
    value: function () {
      var _getSPMinDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(_ref8) {
        var serviceProvider, method, info;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                serviceProvider = _ref8.serviceProvider;
                _context32.next = 3;
                return this.getMethod('getSPMinDelegationAmount', serviceProvider);

              case 3:
                method = _context32.sent;
                _context32.next = 6;
                return method.call();

              case 6:
                info = _context32.sent;
                return _context32.abrupt("return", Utils$b.toBN(info));

              case 8:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getSPMinDelegationAmount(_x28) {
        return _getSPMinDelegationAmount.apply(this, arguments);
      }

      return getSPMinDelegationAmount;
    }()
  }, {
    key: "updateSPMinDelegationAmount",
    value: function () {
      var _updateSPMinDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(_ref9) {
        var serviceProvider, amount, method;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                serviceProvider = _ref9.serviceProvider, amount = _ref9.amount;
                _context33.next = 3;
                return this.getMethod('updateSPMinDelegationAmount', serviceProvider, amount);

              case 3:
                method = _context33.sent;
                _context33.next = 6;
                return this.web3Manager.sendTransaction(method);

              case 6:
                return _context33.abrupt("return", _context33.sent);

              case 7:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function updateSPMinDelegationAmount(_x29) {
        return _updateSPMinDelegationAmount.apply(this, arguments);
      }

      return updateSPMinDelegationAmount;
    }()
  }, {
    key: "updateRemoveDelegatorLockupDuration",
    value: function () {
      var _updateRemoveDelegatorLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(duration) {
        var method;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return this.getGovernedMethod('updateRemoveDelegatorLockupDuration', duration);

              case 2:
                method = _context34.sent;
                _context34.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context34.abrupt("return", _context34.sent);

              case 6:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function updateRemoveDelegatorLockupDuration(_x30) {
        return _updateRemoveDelegatorLockupDuration.apply(this, arguments);
      }

      return updateRemoveDelegatorLockupDuration;
    }()
  }, {
    key: "updateUndelegateLockupDuration",
    value: function () {
      var _updateUndelegateLockupDuration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(duration) {
        var method;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                _context35.next = 2;
                return this.getGovernedMethod('updateUndelegateLockupDuration', duration);

              case 2:
                method = _context35.sent;
                _context35.next = 5;
                return this.web3Manager.sendTransaction(method);

              case 5:
                return _context35.abrupt("return", _context35.sent);

              case 6:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function updateUndelegateLockupDuration(_x31) {
        return _updateUndelegateLockupDuration.apply(this, arguments);
      }

      return updateUndelegateLockupDuration;
    }()
  }]);

  return DelegateManagerClient;
}(GovernedContractClient);

var ClaimsManagerClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(ClaimsManagerClient, _ContractClient);

  var _super = _createSuper(ClaimsManagerClient);

  function ClaimsManagerClient() {
    _classCallCheck(this, ClaimsManagerClient);

    return _super.apply(this, arguments);
  }

  _createClass(ClaimsManagerClient, [{
    key: "getFundingRoundBlockDiff",
    value:
    /* ------- GETTERS ------- */
    // Get the duration of a funding round in blocks
    function () {
      var _getFundingRoundBlockDiff = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getMethod('getFundingRoundBlockDiff');

              case 2:
                method = _context.sent;
                _context.next = 5;
                return method.call();

              case 5:
                info = _context.sent;
                return _context.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getFundingRoundBlockDiff() {
        return _getFundingRoundBlockDiff.apply(this, arguments);
      }

      return getFundingRoundBlockDiff;
    }() // Get the last block where a funding round was initiated

  }, {
    key: "getLastFundedBlock",
    value: function () {
      var _getLastFundedBlock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getMethod('getLastFundedBlock');

              case 2:
                method = _context2.sent;
                _context2.next = 5;
                return method.call();

              case 5:
                info = _context2.sent;
                return _context2.abrupt("return", parseInt(info));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getLastFundedBlock() {
        return _getLastFundedBlock.apply(this, arguments);
      }

      return getLastFundedBlock;
    }() // Get the amount funded per round in wei

  }, {
    key: "getFundsPerRound",
    value: function () {
      var _getFundsPerRound = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getMethod('getFundsPerRound');

              case 2:
                method = _context3.sent;
                _context3.next = 5;
                return method.call();

              case 5:
                info = _context3.sent;
                return _context3.abrupt("return", Utils$b.toBN(info));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getFundsPerRound() {
        return _getFundsPerRound.apply(this, arguments);
      }

      return getFundsPerRound;
    }() // Get the total amount claimed in the current round

  }, {
    key: "getTotalClaimedInRound",
    value: function () {
      var _getTotalClaimedInRound = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('getTotalClaimedInRound');

              case 2:
                method = _context4.sent;
                _context4.next = 5;
                return method.call();

              case 5:
                info = _context4.sent;
                return _context4.abrupt("return", Utils$b.toBN(info));

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getTotalClaimedInRound() {
        return _getTotalClaimedInRound.apply(this, arguments);
      }

      return getTotalClaimedInRound;
    }() // Get the Governance address

  }, {
    key: "getGovernanceAddress",
    value: function () {
      var _getGovernanceAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getMethod('getGovernanceAddress');

              case 2:
                method = _context5.sent;
                _context5.next = 5;
                return method.call();

              case 5:
                info = _context5.sent;
                return _context5.abrupt("return", info);

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getGovernanceAddress() {
        return _getGovernanceAddress.apply(this, arguments);
      }

      return getGovernanceAddress;
    }() // Get the ServiceProviderFactory address

  }, {
    key: "getServiceProviderFactoryAddress",
    value: function () {
      var _getServiceProviderFactoryAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getMethod('getServiceProviderFactoryAddress');

              case 2:
                method = _context6.sent;
                _context6.next = 5;
                return method.call();

              case 5:
                info = _context6.sent;
                return _context6.abrupt("return", info);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getServiceProviderFactoryAddress() {
        return _getServiceProviderFactoryAddress.apply(this, arguments);
      }

      return getServiceProviderFactoryAddress;
    }() // Get the DelegateManager address

  }, {
    key: "getDelegateManagerAddress",
    value: function () {
      var _getDelegateManagerAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getMethod('getDelegateManagerAddress');

              case 2:
                method = _context7.sent;
                _context7.next = 5;
                return method.call();

              case 5:
                info = _context7.sent;
                return _context7.abrupt("return", info);

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getDelegateManagerAddress() {
        return _getDelegateManagerAddress.apply(this, arguments);
      }

      return getDelegateManagerAddress;
    }() // Get the Staking address

  }, {
    key: "getStakingAddress",
    value: function () {
      var _getStakingAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getMethod('getStakingAddress');

              case 2:
                method = _context8.sent;
                _context8.next = 5;
                return method.call();

              case 5:
                info = _context8.sent;
                return _context8.abrupt("return", info);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getStakingAddress() {
        return _getStakingAddress.apply(this, arguments);
      }

      return getStakingAddress;
    }() // Returns boolean indicating whether a claim is considered pending

  }, {
    key: "claimPending",
    value: function () {
      var _claimPending = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(address) {
        var method, info;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getMethod('claimPending', address);

              case 2:
                method = _context9.sent;
                _context9.next = 5;
                return method.call();

              case 5:
                info = _context9.sent;
                return _context9.abrupt("return", info);

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function claimPending(_x) {
        return _claimPending.apply(this, arguments);
      }

      return claimPending;
    }() // Returns boolean indicating whether a claim is considered pending

  }, {
    key: "initiateRound",
    value: function () {
      var _initiateRound = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var txRetries,
            method,
            _args10 = arguments;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                txRetries = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : 5;
                _context10.next = 3;
                return this.getMethod('initiateRound');

              case 3:
                method = _context10.sent;
                _context10.next = 6;
                return this.web3Manager.sendTransaction(method, null, null, txRetries);

              case 6:
                return _context10.abrupt("return", _context10.sent);

              case 7:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function initiateRound() {
        return _initiateRound.apply(this, arguments);
      }

      return initiateRound;
    }() // Fetches the claim processed events

  }, {
    key: "getClaimProcessedEvents",
    value: function () {
      var _getClaimProcessedEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(_ref) {
        var claimer, _ref$queryStartBlock, queryStartBlock, contract, events;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                claimer = _ref.claimer, _ref$queryStartBlock = _ref.queryStartBlock, queryStartBlock = _ref$queryStartBlock === void 0 ? 0 : _ref$queryStartBlock;
                _context11.next = 3;
                return this.getContract();

              case 3:
                contract = _context11.sent;
                _context11.next = 6;
                return contract.getPastEvents('ClaimProcessed', {
                  fromBlock: queryStartBlock,
                  filter: {
                    _claimer: claimer
                  }
                });

              case 6:
                events = _context11.sent;
                return _context11.abrupt("return", events.map(function (event) {
                  return {
                    blockNumber: parseInt(event.blockNumber),
                    claimer: event.returnValues['_claimer'],
                    rewards: Utils$b.toBN(event.returnValues['_rewards']),
                    oldTotal: Utils$b.toBN(event.returnValues['_oldTotal']),
                    newTotal: Utils$b.toBN(event.returnValues['_newTotal'])
                  };
                }));

              case 8:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getClaimProcessedEvents(_x2) {
        return _getClaimProcessedEvents.apply(this, arguments);
      }

      return getClaimProcessedEvents;
    }()
  }]);

  return ClaimsManagerClient;
}(ContractClient$7);

var ClaimDistributionClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(ClaimDistributionClient, _ContractClient);

  var _super = _createSuper(ClaimDistributionClient);

  function ClaimDistributionClient() {
    _classCallCheck(this, ClaimDistributionClient);

    return _super.apply(this, arguments);
  }

  _createClass(ClaimDistributionClient, [{
    key: "isClaimed",
    value: // ===================== Contract Methods =====================

    /**
     * Calls the contract method to check if the claim index has been claimed
     */
    function () {
      var _isClaimed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(index) {
        var method, isClaimed;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getMethod('isClaimed', index);

              case 2:
                method = _context.sent;
                _context.next = 5;
                return method.call();

              case 5:
                isClaimed = _context.sent;
                return _context.abrupt("return", isClaimed);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function isClaimed(_x) {
        return _isClaimed.apply(this, arguments);
      }

      return isClaimed;
    }()
    /**
     * Proxies the calls the contract method to make a claim
     * @param index
     * @param account
     * @param amount
     * @param merkleProof
     * @returns transaction
     */

  }, {
    key: "claim",
    value: function () {
      var _claim = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(index, account, amount, merkleProof) {
        var method, contractAddress, tx;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getMethod('claim', index, account, amount, merkleProof);

              case 2:
                method = _context2.sent;
                _context2.next = 5;
                return this.getAddress();

              case 5:
                contractAddress = _context2.sent;
                _context2.next = 8;
                return this.web3Manager.relayTransaction(method, contractAddress, account);

              case 8:
                tx = _context2.sent;
                return _context2.abrupt("return", tx);

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function claim(_x2, _x3, _x4, _x5) {
        return _claim.apply(this, arguments);
      }

      return claim;
    }()
  }]);

  return ClaimDistributionClient;
}(ContractClient$7);

var WormholeClient = /*#__PURE__*/function () {
  function WormholeClient(ethWeb3Manager, contractABI, contractAddress, audiusTokenClient) {
    _classCallCheck(this, WormholeClient);

    this.ethWeb3Manager = ethWeb3Manager;
    this.contractABI = contractABI;
    this.contractAddress = contractAddress;
    this.web3 = this.ethWeb3Manager.getWeb3();
    this.audiusTokenClient = audiusTokenClient;
    this.WormholeContract = new this.web3.eth.Contract(this.contractABI, this.contractAddress);
  } // Get the name of the contract


  _createClass(WormholeClient, [{
    key: "nonces",
    value: function () {
      var _nonces = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(wallet) {
        var nonce, number;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.WormholeContract.methods.nonces(wallet).call({
                  _audiusBustCache: Date.now()
                });

              case 2:
                nonce = _context.sent;
                number = this.web3.utils.toBN(nonce).toNumber();
                return _context.abrupt("return", number);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function nonces(_x) {
        return _nonces.apply(this, arguments);
      }

      return nonces;
    }()
    /* ------- SETTERS ------- */

  }, {
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(fromAcct, wormholeAddress, relayer) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                method = this.WormholeContract.methods.initialize(this.audiusTokenClient.contractAddress, wormholeAddress);
                _context2.next = 3;
                return this.ethWeb3Manager.relayTransaction(method, this.contractAddress, fromAcct, relayer,
                /* retries */
                0);

              case 3:
                tx = _context2.sent;
                return _context2.abrupt("return", {
                  txReceipt: tx
                });

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function initialize(_x2, _x3, _x4) {
        return _initialize.apply(this, arguments);
      }

      return initialize;
    }()
    /**
     * Transfers in eth from the user's wallet to the wormhole contract and
     * specifies a solana wallet to realized the tokens in SOL
     */

  }, {
    key: "transferTokens",
    value: function () {
      var _transferTokens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(fromAcct, amount, chainId, solanaAccount, arbiterFee, deadline, signedDigest, relayer) {
        var method, tx;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                method = this.WormholeContract.methods.transferTokens(fromAcct, amount, chainId, solanaAccount, arbiterFee, deadline, signedDigest.v, signedDigest.r, signedDigest.s);
                _context3.next = 3;
                return this.ethWeb3Manager.relayTransaction(method, this.contractAddress, fromAcct, relayer,
                /* retries */
                0, null);

              case 3:
                tx = _context3.sent;
                return _context3.abrupt("return", tx);

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function transferTokens(_x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12) {
        return _transferTokens.apply(this, arguments);
      }

      return transferTokens;
    }()
  }]);

  return WormholeClient;
}();

var EthRewardsManagerClient = /*#__PURE__*/function (_ContractClient) {
  _inherits(EthRewardsManagerClient, _ContractClient);

  var _super = _createSuper(EthRewardsManagerClient);

  function EthRewardsManagerClient() {
    _classCallCheck(this, EthRewardsManagerClient);

    return _super.apply(this, arguments);
  }

  _createClass(EthRewardsManagerClient, [{
    key: "token",
    value:
    /* ------- GETTERS ------- */
    // Get the token used by the contract
    function () {
      var _token = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getMethod('token');

              case 2:
                method = _context.sent;
                _context.next = 5;
                return method.call();

              case 5:
                info = _context.sent;
                return _context.abrupt("return", info);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function token() {
        return _token.apply(this, arguments);
      }

      return token;
    }() // Get the Governance address

  }, {
    key: "getGovernanceAddress",
    value: function () {
      var _getGovernanceAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getMethod('getGovernanceAddress');

              case 2:
                method = _context2.sent;
                _context2.next = 5;
                return method.call();

              case 5:
                info = _context2.sent;
                return _context2.abrupt("return", info);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getGovernanceAddress() {
        return _getGovernanceAddress.apply(this, arguments);
      }

      return getGovernanceAddress;
    }() // Get the recipient address

  }, {
    key: "getRecipientAddress",
    value: function () {
      var _getRecipientAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getMethod('getRecipientAddress');

              case 2:
                method = _context3.sent;
                _context3.next = 5;
                return method.call();

              case 5:
                info = _context3.sent;
                return _context3.abrupt("return", info);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getRecipientAddress() {
        return _getRecipientAddress.apply(this, arguments);
      }

      return getRecipientAddress;
    }() // Get the anti abuse oracle addresses

  }, {
    key: "getAntiAbuseOracleAddresses",
    value: function () {
      var _getAntiAbuseOracleAddresses = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var method, info;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('getAntiAbuseOracleAddresses');

              case 2:
                method = _context4.sent;
                _context4.next = 5;
                return method.call();

              case 5:
                info = _context4.sent;
                return _context4.abrupt("return", info);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAntiAbuseOracleAddresses() {
        return _getAntiAbuseOracleAddresses.apply(this, arguments);
      }

      return getAntiAbuseOracleAddresses;
    }()
  }]);

  return EthRewardsManagerClient;
}(ContractClient$7);

var TrustedNotifierManagerClient = /*#__PURE__*/function (_GovernedContractClie) {
  _inherits(TrustedNotifierManagerClient, _GovernedContractClie);

  var _super = _createSuper(TrustedNotifierManagerClient);

  function TrustedNotifierManagerClient() {
    _classCallCheck(this, TrustedNotifierManagerClient);

    return _super.apply(this, arguments);
  }

  _createClass(TrustedNotifierManagerClient, [{
    key: "registerNotifier",
    value:
    /**
     * Register Trusted Notifier with specified fields (wallet, endpoint, email)
     * @notice Only callable by Governance contract
     * @notice All fields must be unique and non-falsey
     * @notice New Trusted Notifier is assigned an auto-incremented integer ID
     * @returns Newly assigned integer ID
     */
    function () {
      var _registerNotifier = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(wallet, endpoint, email) {
        var privateKey,
            method,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                privateKey = _args.length > 3 && _args[3] !== undefined ? _args[3] : null;
                _context.next = 3;
                return this.getGovernedMethod('registerNotifier', wallet, endpoint, email);

              case 3:
                method = _context.sent;
                _context.t0 = this.web3Manager;
                _context.t1 = method;
                _context.next = 8;
                return this.governanceClient.getAddress();

              case 8:
                _context.t2 = _context.sent;
                _context.t3 = privateKey;
                _context.next = 12;
                return _context.t0.sendTransaction.call(_context.t0, _context.t1, _context.t2, _context.t3);

              case 12:
                return _context.abrupt("return", _context.sent);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function registerNotifier(_x, _x2, _x3) {
        return _registerNotifier.apply(this, arguments);
      }

      return registerNotifier;
    }()
    /**
     * Deregister Trusted Notifier associated with wallet
     * @notice Only callable by Governance contract or wallet
     * @returns ID of deregistered Trusted Notifier
     */

  }, {
    key: "deregisterNotifier",
    value: function () {
      var _deregisterNotifier = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(wallet) {
        var privateKey,
            method,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                privateKey = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;
                _context2.next = 3;
                return this.getGovernedMethod('deregisterNotifier', wallet);

              case 3:
                method = _context2.sent;
                _context2.t0 = this.web3Manager;
                _context2.t1 = method;
                _context2.next = 8;
                return this.governanceClient.getAddress();

              case 8:
                _context2.t2 = _context2.sent;
                _context2.t3 = privateKey;
                _context2.next = 12;
                return _context2.t0.sendTransaction.call(_context2.t0, _context2.t1, _context2.t2, _context2.t3);

              case 12:
                return _context2.abrupt("return", _context2.sent);

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function deregisterNotifier(_x4) {
        return _deregisterNotifier.apply(this, arguments);
      }

      return deregisterNotifier;
    }()
  }, {
    key: "getLatestNotifierID",
    value: function () {
      var _getLatestNotifierID = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var method, ID;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getMethod('getLatestNotifierID');

              case 2:
                method = _context3.sent;
                _context3.next = 5;
                return method.call();

              case 5:
                ID = _context3.sent;
                return _context3.abrupt("return", parseInt(ID));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getLatestNotifierID() {
        return _getLatestNotifierID.apply(this, arguments);
      }

      return getLatestNotifierID;
    }()
    /**
     * Returns all TrustedNotifier info associated with ID
     */

  }, {
    key: "getNotifierForID",
    value: function () {
      var _getNotifierForID = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(ID) {
        var method, notifierInfo;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('getNotifierForID', ID);

              case 2:
                method = _context4.sent;
                _context4.next = 5;
                return method.call();

              case 5:
                notifierInfo = _context4.sent;
                return _context4.abrupt("return", {
                  wallet: notifierInfo.wallet,
                  endpoint: notifierInfo.endpoint.replace(/\/$/, ''),
                  email: notifierInfo.email.replace(/\/$/, '')
                });

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getNotifierForID(_x5) {
        return _getNotifierForID.apply(this, arguments);
      }

      return getNotifierForID;
    }()
    /**
     * Returns all TrustedNotifier info associated with wallet
     */

  }, {
    key: "getNotifierForWallet",
    value: function () {
      var _getNotifierForWallet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(wallet) {
        var method, notifierInfo;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getMethod('getNotifierForWallet', wallet);

              case 2:
                method = _context5.sent;
                _context5.next = 5;
                return method.call();

              case 5:
                notifierInfo = _context5.sent;
                return _context5.abrupt("return", {
                  ID: notifierInfo.ID,
                  endpoint: notifierInfo.endpoint.replace(/\/$/, ''),
                  email: notifierInfo.email.replace(/\/$/, '')
                });

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getNotifierForWallet(_x6) {
        return _getNotifierForWallet.apply(this, arguments);
      }

      return getNotifierForWallet;
    }()
    /**
     * Returns all TrustedNotifier info associated with endpoint
     */

  }, {
    key: "getNotifierForEndpoint",
    value: function () {
      var _getNotifierForEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(endpoint) {
        var method, notifierInfo;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getMethod('getNotifierForEndpoint', endpoint);

              case 2:
                method = _context6.sent;
                _context6.next = 5;
                return method.call();

              case 5:
                notifierInfo = _context6.sent;
                return _context6.abrupt("return", {
                  ID: notifierInfo.ID,
                  wallet: notifierInfo.wallet,
                  email: notifierInfo.email.replace(/\/$/, '')
                });

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getNotifierForEndpoint(_x7) {
        return _getNotifierForEndpoint.apply(this, arguments);
      }

      return getNotifierForEndpoint;
    }()
    /**
     * Returns all TrustedNotifier info associated with email
     */

  }, {
    key: "getNotifierForEmail",
    value: function () {
      var _getNotifierForEmail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(email) {
        var method, notifierInfo;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getMethod('getNotifierForEmail', email);

              case 2:
                method = _context7.sent;
                _context7.next = 5;
                return method.call();

              case 5:
                notifierInfo = _context7.sent;
                return _context7.abrupt("return", {
                  ID: notifierInfo.ID,
                  wallet: notifierInfo.wallet,
                  endpoint: notifierInfo.endpoint.replace(/\/$/, '')
                });

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getNotifierForEmail(_x8) {
        return _getNotifierForEmail.apply(this, arguments);
      }

      return getNotifierForEmail;
    }()
  }]);

  return TrustedNotifierManagerClient;
}(GovernedContractClient);

var AudiusTokenABI = Utils$b.importEthContractABI('AudiusToken.json').abi;
var RegistryABI$1 = Utils$b.importEthContractABI('Registry.json').abi;
var GovernanceABI = Utils$b.importEthContractABI('Governance.json').abi;
var ServiceTypeManagerABI = Utils$b.importEthContractABI('ServiceTypeManager.json').abi;
var ServiceProviderFactoryABI = Utils$b.importEthContractABI('ServiceProviderFactory.json').abi;
var StakingABI = Utils$b.importEthContractABI('Staking.json').abi;
var DelegateManagerABI = Utils$b.importEthContractABI('DelegateManagerV2.json').abi;
var ClaimsManagerABI = Utils$b.importEthContractABI('ClaimsManager.json').abi;
var ClaimDistributionABI = Utils$b.importEthContractABI('AudiusClaimDistributor.json').abi;
var WormholeClientABI = Utils$b.importEthContractABI('WormholeClient.json').abi;
var EthRewardsManagerABI = Utils$b.importEthContractABI('EthRewardsManager.json').abi;
var TrustedNotifierManagerABI = Utils$b.importEthContractABI('TrustedNotifierManager.json').abi;
var GovernanceRegistryKey = 'Governance';
var ServiceTypeManagerProxyKey = 'ServiceTypeManagerProxy';
var ServiceProviderFactoryRegistryKey = 'ServiceProviderFactory';
var StakingProxyKey = 'StakingProxy';
var DelegateManagerRegistryKey = 'DelegateManager';
var ClaimsManagerProxyKey = 'ClaimsManagerProxy';
var ClaimDistributionRegistryKey = 'ClaimDistribution';
var EthRewardsManagerProxyKey = 'EthRewardsManagerProxy';
var TrustedNotifierManagerProxyKey = 'TrustedNotifierManagerProxy';
var TWO_MINUTES = 2 * 60 * 1000;
var serviceType = Object.freeze({
  DISCOVERY_PROVIDER: 'discovery-node',
  CREATOR_NODE: 'content-node'
});
var serviceTypeList = Object.values(serviceType);
var EthContracts = /*#__PURE__*/function () {
  function EthContracts(ethWeb3Manager, tokenContractAddress, registryAddress, claimDistributionContractAddress, wormholeContractAddress, isServer) {
    var logger = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : console;
    var isDebug = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;

    _classCallCheck(this, EthContracts);

    this.ethWeb3Manager = ethWeb3Manager;
    this.tokenContractAddress = tokenContractAddress;
    this.claimDistributionContractAddress = claimDistributionContractAddress;
    this.wormholeContractAddress = wormholeContractAddress;
    this.registryAddress = registryAddress;
    this.isServer = isServer;
    this.logger = logger;
    this.isDebug = isDebug;
    this.expectedServiceVersions = null;
    this.AudiusTokenClient = new AudiusTokenClient(this.ethWeb3Manager, AudiusTokenABI, this.tokenContractAddress);
    this.RegistryClient = new RegistryClient$2(this.ethWeb3Manager, RegistryABI$1, this.registryAddress);
    this.getRegistryAddressForContract = this.getRegistryAddressForContract.bind(this);
    this.StakingProxyClient = new StakingProxyClient(this.ethWeb3Manager, StakingABI, StakingProxyKey, this.getRegistryAddressForContract, this.AudiusTokenClient, this.logger);
    this.GovernanceClient = new GovernanceClient(this.ethWeb3Manager, GovernanceABI, GovernanceRegistryKey, this.getRegistryAddressForContract, this.AudiusTokenClient, this.StakingProxyClient, this.logger);
    this.ClaimsManagerClient = new ClaimsManagerClient(this.ethWeb3Manager, ClaimsManagerABI, ClaimsManagerProxyKey, this.getRegistryAddressForContract, this.logger);
    this.EthRewardsManagerClient = new EthRewardsManagerClient(this.ethWeb3Manager, EthRewardsManagerABI, EthRewardsManagerProxyKey, this.getRegistryAddressForContract, this.logger);
    this.ServiceTypeManagerClient = new ServiceTypeManagerClient(this.ethWeb3Manager, ServiceTypeManagerABI, ServiceTypeManagerProxyKey, this.getRegistryAddressForContract, this.GovernanceClient, this.logger);
    this.ServiceProviderFactoryClient = new ServiceProviderFactoryClient(this.ethWeb3Manager, ServiceProviderFactoryABI, ServiceProviderFactoryRegistryKey, this.getRegistryAddressForContract, this.AudiusTokenClient, this.StakingProxyClient, this.GovernanceClient, this.logger, this.isDebug);
    this.DelegateManagerClient = new DelegateManagerClient(this.ethWeb3Manager, DelegateManagerABI, DelegateManagerRegistryKey, this.getRegistryAddressForContract, this.AudiusTokenClient, this.StakingProxyClient, this.GovernanceClient, this.logger);

    if (this.claimDistributionContractAddress) {
      this.ClaimDistributionClient = new ClaimDistributionClient(this.ethWeb3Manager, ClaimDistributionABI, ClaimDistributionRegistryKey, this.getRegistryAddressForContract, this.logger, this.claimDistributionContractAddress);
    }

    this.WormholeClient = new WormholeClient(this.ethWeb3Manager, WormholeClientABI, this.wormholeContractAddress, this.AudiusTokenClient);
    this.TrustedNotifierManagerClient = new TrustedNotifierManagerClient(this.ethWeb3Manager, TrustedNotifierManagerABI, TrustedNotifierManagerProxyKey, this.getRegistryAddressForContract, this.GovernanceClient, this.logger);
    this.contractClients = [this.ServiceTypeManagerClient, this.StakingProxyClient, this.ServiceProviderFactoryClient]; // Whether or not we are running in `regressed` mode, meaning we were
    // unable to select a discovery provider that was up-to-date. Clients may
    // want to consider blocking writes.

    this._regressedMode = false;
  }

  _createClass(EthContracts, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(!this.ethWeb3Manager || !this.tokenContractAddress || !this.registryAddress)) {
                  _context2.next = 2;
                  break;
                }

                throw new Error('Failed to initialize EthContracts');

              case 2:
                if (!this.isServer) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 5;
                return Promise.all(this.contractClients.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(client) {
                    return regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return client.init();

                          case 2:
                            return _context.abrupt("return", _context.sent);

                          case 3:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
    /**
     * Estabilishes that connection to discovery providers has regressed
     */

  }, {
    key: "enterRegressedMode",
    value: function enterRegressedMode() {
      var _this = this;

      console.info('Entering regressed mode');
      this._regressedMode = true;
      setTimeout(function () {
        console.info('Leaving regressed mode');
        _this._regressedMode = false;
      }, TWO_MINUTES);
    }
  }, {
    key: "isInRegressedMode",
    value: function isInRegressedMode() {
      return this._regressedMode;
    }
  }, {
    key: "getRegistryAddressForContract",
    value: function () {
      var _getRegistryAddressForContract = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(contractName) {
        var _this$contracts, _this$contractAddress;

        var address;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names
                this.contracts = (_this$contracts = this.contracts) !== null && _this$contracts !== void 0 ? _this$contracts : _defineProperty({}, this.registryAddress, 'registry');
                this.contractAddresses = (_this$contractAddress = this.contractAddresses) !== null && _this$contractAddress !== void 0 ? _this$contractAddress : {
                  registry: this.registryAddress
                };

                if (this.contractAddresses[contractName]) {
                  _context3.next = 8;
                  break;
                }

                _context3.next = 5;
                return this.RegistryClient.getContract(contractName);

              case 5:
                address = _context3.sent;
                this.contracts[address] = contractName;
                this.contractAddresses[contractName] = address;

              case 8:
                return _context3.abrupt("return", this.contractAddresses[contractName]);

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getRegistryAddressForContract(_x2) {
        return _getRegistryAddressForContract.apply(this, arguments);
      }

      return getRegistryAddressForContract;
    }()
  }, {
    key: "getCurrentVersion",
    value: function () {
      var _getCurrentVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(serviceType) {
        var version;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                _context4.next = 3;
                return this.ServiceTypeManagerClient.getCurrentVersion(serviceType);

              case 3:
                version = _context4.sent;
                return _context4.abrupt("return", version);

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](0);
                console.log("Error retrieving version for ".concat(serviceType));
                return _context4.abrupt("return", '');

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 7]]);
      }));

      function getCurrentVersion(_x3) {
        return _getCurrentVersion.apply(this, arguments);
      }

      return getCurrentVersion;
    }()
    /*
     * Determine the latest version for deployed services such as discovery provider and cache
     */

  }, {
    key: "getExpectedServiceVersions",
    value: function () {
      var _getExpectedServiceVersions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var _this2 = this;

        var versions, expectedVersions;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return Promise.all(serviceTypeList.map( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(serviceType) {
                    return regeneratorRuntime.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _context5.next = 2;
                            return _this2.getCurrentVersion(serviceType);

                          case 2:
                            return _context5.abrupt("return", _context5.sent);

                          case 3:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function (_x4) {
                    return _ref3.apply(this, arguments);
                  };
                }()));

              case 2:
                versions = _context6.sent;
                expectedVersions = serviceTypeList.reduce(function (map, serviceType, i) {
                  if (versions[i]) {
                    map[serviceType] = versions[i];
                  }

                  return map;
                }, {});
                return _context6.abrupt("return", expectedVersions);

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function getExpectedServiceVersions() {
        return _getExpectedServiceVersions.apply(this, arguments);
      }

      return getExpectedServiceVersions;
    }()
    /**
     * Determine whether major and minor versions match for two version strings
     * Version string 2 must have equivalent major/minor versions and a patch >= version1
     * @param version1 string 1
     * @param version2 string 2
     */

  }, {
    key: "isValidSPVersion",
    value: function isValidSPVersion(version1, version2) {
      return semver__default["default"].major(version1) === semver__default["default"].major(version2) && semver__default["default"].minor(version1) === semver__default["default"].minor(version2) && semver__default["default"].patch(version2) >= semver__default["default"].patch(version1);
    }
    /**
     * Determines whether the major and minor versions are equal
     * @param version1 string 1
     * @param version2 string 2
     */

  }, {
    key: "hasSameMajorAndMinorVersion",
    value: function hasSameMajorAndMinorVersion(version1, version2) {
      return semver__default["default"].major(version1) === semver__default["default"].major(version2) && semver__default["default"].minor(version1) === semver__default["default"].minor(version2);
    }
  }, {
    key: "getServiceProviderList",
    value: function () {
      var _getServiceProviderList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(spType) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.ServiceProviderFactoryClient.getServiceProviderList(spType);

              case 2:
                return _context7.abrupt("return", _context7.sent);

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getServiceProviderList(_x5) {
        return _getServiceProviderList.apply(this, arguments);
      }

      return getServiceProviderList;
    }()
  }, {
    key: "getNumberOfVersions",
    value: function () {
      var _getNumberOfVersions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(spType) {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.ServiceTypeManagerClient.getNumberOfVersions(spType);

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getNumberOfVersions(_x6) {
        return _getNumberOfVersions.apply(this, arguments);
      }

      return getNumberOfVersions;
    }()
  }, {
    key: "getVersion",
    value: function () {
      var _getVersion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(spType, queryIndex) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.ServiceTypeManagerClient.getVersion(spType, queryIndex);

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getVersion(_x7, _x8) {
        return _getVersion.apply(this, arguments);
      }

      return getVersion;
    }()
  }, {
    key: "getServiceTypeInfo",
    value: function () {
      var _getServiceTypeInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(spType) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.ServiceTypeManagerClient.getServiceTypeInfo(spType);

              case 2:
                return _context10.abrupt("return", _context10.sent);

              case 3:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getServiceTypeInfo(_x9) {
        return _getServiceTypeInfo.apply(this, arguments);
      }

      return getServiceTypeInfo;
    }()
  }]);

  return EthContracts;
}();

var ethContracts = /*#__PURE__*/Object.freeze({
  __proto__: null,
  serviceType: serviceType,
  EthContracts: EthContracts
});

var require$$4$1 = /*@__PURE__*/getAugmentedNamespace(ethContracts);

/**
 * All errors returned by RewardsManager
 */
var RewardsManagerError$2 = {
  // The owner of the input isn't set to the program address generated by the program.
  INCORRECT_OWNER: 'INCORRECT_OWNER',
  // Signature with an already met principal
  SIGN_COLLISION: 'SIGN_COLLISION',
  // Unexpected signer met
  WRONG_SIGNER: 'WRONG_SIGNER',
  // Isn't enough signers keys
  NOT_ENOUGH_SIGNERS: 'NOT_ENOUGH_SIGNERS',
  // Secp256 instruction missing
  SECP256_INSTRUCTION_MISSING: 'SECP256_INSTRUCTION_MISSING',
  // Instruction load error
  INSTRUCTION_LOAD_ERROR: 'INSTRUCTION_LOAD_ERROR',
  // Repeated senders
  REPEATED_SENDERS: 'REPEATED_SENDERS',
  // Signature verification failed
  SIGNATURE_VERIFICATION_FAILED: 'SIGNATURE_VERIFICATION_FAILED',
  // Some signers have same operators
  OPERATOR_COLLISION: 'OPERATOR_COLLISION',
  // Funds already sent
  ALREADY_SENT: 'ALREADY_SENT',
  // Incorrect messages
  INCORRECT_MESSAGES: 'INCORRECT_MESSAGES',
  // Messages overflow
  MESSAGE_OVERFLOW: 'MESSAGE_OVERFLOW',
  // Math overflow
  MATH_OVERFLOW: 'MATH_OVERFLOW',
  // Invalid recipient
  INVALID_RECIPIENT: 'INVALID_RECIPIENT',
  // Unmapped error
  UNKNOWN: 'UNKNOWN',
  fromErrorCode: function fromErrorCode(code) {
    var errors = [RewardsManagerError$2.INCORRECT_OWNER, RewardsManagerError$2.SIGN_COLLISION, RewardsManagerError$2.WRONG_SIGNER, RewardsManagerError$2.NOT_ENOUGH_SIGNERS, RewardsManagerError$2.SECP256_INSTRUCTION_MISSING, RewardsManagerError$2.INSTRUCTION_LOAD_ERROR, RewardsManagerError$2.REPEATED_SENDERS, RewardsManagerError$2.SIGNATURE_VERIFICATION_FAILED, RewardsManagerError$2.OPERATOR_COLLISION, RewardsManagerError$2.ALREADY_SENT, RewardsManagerError$2.INCORRECT_MESSAGES, RewardsManagerError$2.MESSAGE_OVERFLOW, RewardsManagerError$2.MATH_OVERFLOW, RewardsManagerError$2.INVALID_RECIPIENT];
    return errors[code] || RewardsManagerError$2.UNKNOWN;
  }
};
var ClaimableProgramError$1 = {
  // Signature verification failed
  SIGNATURE_VERIFICATION_FAILED: 'SIGNATURE_VERIFICATION_FAILED',
  /// Secp256 instruction losing
  SECP256_INSTRUCTION_LOSING: 'SECP256_INSTRUCTION_LOSING',
  /// Instruction load error
  INSTRUCTION_LOAD_ERROR: 'INSTRUCTION_LOAD_ERROR',
  /// User nonce verification error
  NONCE_VERIFICATION_ERROR: 'NONCE_VERIFICATION_ERROR',
  // Unmapped error
  UNKNOWN: 'UNKNOWN',
  fromErrorCode: function fromErrorCode(code) {
    var errors = [ClaimableProgramError$1.SIGNATURE_VERIFICATION_FAILED, ClaimableProgramError$1.SECP256_INSTRUCTION_LOSING, ClaimableProgramError$1.INSTRUCTION_LOAD_ERROR, ClaimableProgramError$1.NONCE_VERIFICATION_ERROR];
    return errors[code] || ClaimableProgramError$1.UNKNOWN;
  }
};
var errors = {
  RewardsManagerError: RewardsManagerError$2,
  ClaimableProgramError: ClaimableProgramError$1
};

var SystemProgram$3 = require$$1__default["default"].SystemProgram,
    PublicKey$5 = require$$1__default["default"].PublicKey,
    Secp256k1Program$1 = require$$1__default["default"].Secp256k1Program,
    SYSVAR_INSTRUCTIONS_PUBKEY$1 = require$$1__default["default"].SYSVAR_INSTRUCTIONS_PUBKEY,
    SYSVAR_RENT_PUBKEY$3 = require$$1__default["default"].SYSVAR_RENT_PUBKEY,
    TransactionInstruction$2 = require$$1__default["default"].TransactionInstruction;
var borsh$2 = require$$1__default$1["default"];
var SolanaUtils$4 = utils;
var secp256k1 = require$$4__default["default"];
var ClaimableProgramError = errors.ClaimableProgramError;
var encoder$1 = new TextEncoder();
var TRANSFER_NONCE_PREFIX = 'N_';
/**
 * Derives the 'transfer nonce account' - the account which contains the nonce for transfers
 * and is used to prevent replay attacks
 *
 * @param {string} ethAddress
 * @param {PublicKey} rewardProgramId
 * @param {PublicKey} rewardManager
 * @returns {Promise<PublicKey>}
 */

var deriveTransferNonceAccount = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
    var ethAddress, mintKey, claimableTokenProgramKey, ethAddressArr, seed, res;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            ethAddress = _ref.ethAddress, mintKey = _ref.mintKey, claimableTokenProgramKey = _ref.claimableTokenProgramKey;
            ethAddressArr = SolanaUtils$4.ethAddressToArray(ethAddress);
            seed = Uint8Array.from([].concat(_toConsumableArray(encoder$1.encode(TRANSFER_NONCE_PREFIX)), _toConsumableArray(ethAddressArr)));
            _context.next = 5;
            return SolanaUtils$4.findProgramAddressWithAuthority(claimableTokenProgramKey, mintKey, seed);

          case 5:
            res = _context.sent;
            return _context.abrupt("return", res[1]);

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function deriveTransferNonceAccount(_x) {
    return _ref2.apply(this, arguments);
  };
}();

var NonceAccount = /*#__PURE__*/_createClass(function NonceAccount(_ref3) {
  var version = _ref3.version,
      nonce = _ref3.nonce;

  _classCallCheck(this, NonceAccount);

  this.version = version;
  this.nonce = nonce;
});

var NonceAccountSchema = new Map([[NonceAccount, {
  kind: 'struct',
  fields: [['version', 'u8'], ['nonce', 'u64']]
}]]);
/**
 * Retrieves the nonce account for transfers, if non-existant it returns 0
 * @param {object} params
 * @param {object} params.connection Solana web3 connection
 * @param {string} params.ethAddress Eth Address
 * @param {PublicKey} params.mintKey Public key of the minted spl token
 * @param {PublicKey} params.claimableTokenProgramKey Program public key
 */

function getAccountNonce(_x2) {
  return _getAccountNonce.apply(this, arguments);
}
/**
 * Transfer wAUDIO between wallets on solana
 */


function _getAccountNonce() {
  _getAccountNonce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref4) {
    var connection, ethAddress, mintKey, claimableTokenProgramKey, nonce, transferNonceAccount, accInfo, nonceAccount;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            connection = _ref4.connection, ethAddress = _ref4.ethAddress, mintKey = _ref4.mintKey, claimableTokenProgramKey = _ref4.claimableTokenProgramKey;
            nonce = 0;
            _context2.next = 4;
            return deriveTransferNonceAccount({
              ethAddress: ethAddress,
              mintKey: mintKey,
              claimableTokenProgramKey: claimableTokenProgramKey
            });

          case 4:
            transferNonceAccount = _context2.sent;
            _context2.next = 7;
            return connection.getAccountInfoAndContext(transferNonceAccount);

          case 7:
            accInfo = _context2.sent;

            if (accInfo.value) {
              nonceAccount = borsh$2.deserialize(NonceAccountSchema, NonceAccount, accInfo.value.data);
              nonce = nonceAccount.nonce;
            }

            return _context2.abrupt("return", {
              accountNonce: transferNonceAccount,
              nonce: nonce
            });

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getAccountNonce.apply(this, arguments);
}

var TransferInstructionData = /*#__PURE__*/_createClass(function TransferInstructionData(_ref5) {
  var targetPubKey = _ref5.targetPubKey,
      amount = _ref5.amount,
      nonce = _ref5.nonce;

  _classCallCheck(this, TransferInstructionData);

  this.target_pubkey = targetPubKey;
  this.amount = amount;
  this.nonce = nonce;
});

var transferInstructionDataSchema = new Map([[TransferInstructionData, {
  kind: 'struct',
  fields: [['target_pubkey', [32]], // type pubkey of length 32 bytes
  ['amount', 'u64'], ['nonce', 'u64']]
}]]);
/**
 * transferWAudioBalance transfers wrapped Audio from one generated solana account to another.
 * For it to work, you have to have the eth private key belonging to the eth public key
 * that generated the solana account
 *
 * @param {BN} amount amount to send
 * @param {string} senderEthAddress sender's eth address (e.g. you)
 * @param {string} senderEthPrivateKey sender's eth private key
 * @param {string} senderSolanaAddress sender's solana address
 * @param {string} recipientSolanaAddress recipient's solana address
 * @param {string} claimableTokenPDA
 * @param {PublicKey} solanaTokenProgramKey spl token key
 * @param {Connection} connection
 * @returns
 */

function transferWAudioBalance$1(_x3) {
  return _transferWAudioBalance.apply(this, arguments);
}

function _transferWAudioBalance() {
  _transferWAudioBalance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref6) {
    var amount, senderEthAddress, senderEthPrivateKey, senderSolanaAddress, recipientSolanaAddress, claimableTokenPDA, solanaTokenProgramKey, feePayerKey, claimableTokenProgramKey, connection, mintKey, transactionHandler, senderSolanaPubkey, recipientPubkey, _yield$getAccountNonc, accountNonce, nonce, accounts, ethPrivateKeyArr, ethPubkey, instructionData, serializedInstructionData, _SolanaUtils$signByte, signature, recoveryId, secpTransactionInstruction, ethAddressArr, transferDataInstr, instructions;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            amount = _ref6.amount, senderEthAddress = _ref6.senderEthAddress, senderEthPrivateKey = _ref6.senderEthPrivateKey, senderSolanaAddress = _ref6.senderSolanaAddress, recipientSolanaAddress = _ref6.recipientSolanaAddress, claimableTokenPDA = _ref6.claimableTokenPDA, solanaTokenProgramKey = _ref6.solanaTokenProgramKey, feePayerKey = _ref6.feePayerKey, claimableTokenProgramKey = _ref6.claimableTokenProgramKey, connection = _ref6.connection, mintKey = _ref6.mintKey, transactionHandler = _ref6.transactionHandler;
            senderSolanaPubkey = new PublicKey$5(senderSolanaAddress);
            recipientPubkey = new PublicKey$5(recipientSolanaAddress);
            _context3.next = 5;
            return getAccountNonce({
              connection: connection,
              mintKey: mintKey,
              ethAddress: senderEthAddress,
              claimableTokenProgramKey: claimableTokenProgramKey
            });

          case 5:
            _yield$getAccountNonc = _context3.sent;
            accountNonce = _yield$getAccountNonc.accountNonce;
            nonce = _yield$getAccountNonc.nonce;
            accounts = [// 0. `[sw]` Fee payer
            {
              pubkey: feePayerKey,
              isSigner: true,
              isWritable: false
            }, // 1. `[w]` Token acc from which tokens will be send (bank account)
            {
              pubkey: senderSolanaPubkey,
              isSigner: false,
              isWritable: true
            }, // 2. `[w]` Receiver token acc
            {
              pubkey: recipientPubkey,
              isSigner: false,
              isWritable: true
            }, // 3. `[w]` Nonce Account
            {
              pubkey: accountNonce,
              isSigner: false,
              isWritable: true
            }, // 4. `[r]` Banks token account authority
            {
              pubkey: claimableTokenPDA,
              isSigner: false,
              isWritable: false
            }, // 5. `[r]` Sysvar Rent id
            {
              pubkey: SYSVAR_RENT_PUBKEY$3,
              isSigner: false,
              isWritable: false
            }, // 6. `[r]` Sysvar instruction id
            {
              pubkey: SYSVAR_INSTRUCTIONS_PUBKEY$1,
              isSigner: false,
              isWritable: false
            }, // 7. `[r]` System program id
            {
              pubkey: SystemProgram$3.programId,
              isSigner: false,
              isWritable: false
            }, // 8. `[r]` SPL token account id
            {
              pubkey: solanaTokenProgramKey,
              isSigner: false,
              isWritable: false
            }]; // eth pubkey is different from the ethAddress - addresses are len 20, pub keys are len 64

            ethPrivateKeyArr = Buffer.from(senderEthPrivateKey, 'hex');
            ethPubkey = secp256k1.publicKeyCreate(ethPrivateKeyArr, false).slice(1);
            instructionData = new TransferInstructionData({
              targetPubKey: recipientPubkey.toBuffer(),
              amount: amount,
              nonce: nonce
            });
            serializedInstructionData = borsh$2.serialize(transferInstructionDataSchema, instructionData);
            _SolanaUtils$signByte = SolanaUtils$4.signBytes(Buffer.from(serializedInstructionData), senderEthPrivateKey), signature = _SolanaUtils$signByte.signature, recoveryId = _SolanaUtils$signByte.recoveryId;
            secpTransactionInstruction = Secp256k1Program$1.createInstructionWithPublicKey({
              publicKey: Buffer.from(ethPubkey),
              message: Buffer.from(serializedInstructionData),
              signature: signature,
              recoveryId: recoveryId
            });
            ethAddressArr = SolanaUtils$4.ethAddressToArray(senderEthAddress);
            transferDataInstr = Uint8Array.of.apply(Uint8Array, [1].concat(_toConsumableArray(ethAddressArr)));
            instructions = [secpTransactionInstruction, new TransactionInstruction$2({
              keys: accounts,
              programId: claimableTokenProgramKey.toString(),
              data: Buffer.from(transferDataInstr)
            })];
            return _context3.abrupt("return", transactionHandler.handleTransaction({
              instructions: instructions,
              errorMapping: ClaimableProgramError,
              feePayerOverride: feePayerKey
            }));

          case 19:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _transferWAudioBalance.apply(this, arguments);
}

var transfer = {
  deriveTransferNonceAccount: deriveTransferNonceAccount,
  transferWAudioBalance: transferWAudioBalance$1
};

var PublicKey$4 = require$$1__default["default"].PublicKey,
    SystemProgram$2 = require$$1__default["default"].SystemProgram,
    SYSVAR_RENT_PUBKEY$2 = require$$1__default["default"].SYSVAR_RENT_PUBKEY,
    TransactionInstruction$1 = require$$1__default["default"].TransactionInstruction;
var borsh$1 = require$$1__default$1["default"];
var bs58$1 = bs58__default["default"];
var ethAddressToArray = utils.ethAddressToArray;

var CreateTokenAccountInstructionData = /*#__PURE__*/_createClass(function CreateTokenAccountInstructionData(_ref) {
  var ethAddress = _ref.ethAddress;

  _classCallCheck(this, CreateTokenAccountInstructionData);

  this.hashed_eth_pk = ethAddress;
});

var createTokenAccountInstructionSchema = new Map([[CreateTokenAccountInstructionData, {
  kind: 'struct',
  fields: [['hashed_eth_pk', [20]]]
}]]);
/**
 * Gets the back account address for a user given their ethAddress
 * @param {string} ethAddress
 * @param {PublicKey} claimableTokenPDA
 * @param {PublicKey} solanaTokenProgramKey
 * @returns
 */

var getBankAccountAddress$2 = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(ethAddress, claimableTokenPDA, solanaTokenProgramKey) {
    var ethAddressArr, b58EthAddress, accountToGenerate;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            ethAddressArr = ethAddressToArray(ethAddress); // We b58 encode our eth address to use as seed later on

            b58EthAddress = bs58$1.encode(ethAddressArr);
            _context.next = 4;
            return PublicKey$4.createWithSeed(
            /* from pubkey / base */
            claimableTokenPDA,
            /* seed */
            b58EthAddress,
            /* programId / owner */
            solanaTokenProgramKey);

          case 4:
            accountToGenerate = _context.sent;
            return _context.abrupt("return", accountToGenerate);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getBankAccountAddress(_x, _x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * createUserBank deterministically creates a Solana wAudio token account
 * from a provided ethAddress
 * @param {string} ethAddress
 * @param {PublicKey} claimableTokenPDAKey
 * @param {PublicKey} feePayerKey
 * @param {PublicKey} mintKey
 * @param {PublicKey} solanaTokenProgramKey
 * @param {PublicKey} claimableTokenProgramKey
 * @param {*} transactionHandler
 * @param {string?} recentBlockhash
 * @returns
 */


var createUserBankFrom$1 = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref3) {
    var ethAddress, claimableTokenPDAKey, feePayerKey, mintKey, solanaTokenProgramKey, claimableTokenProgramKey, transactionHandler, recentBlockhash, ethAddressArr, instructionData, serializedInstructionData, serializedInstructionEnum, accountToGenerate, accounts, instructions;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            ethAddress = _ref3.ethAddress, claimableTokenPDAKey = _ref3.claimableTokenPDAKey, feePayerKey = _ref3.feePayerKey, mintKey = _ref3.mintKey, solanaTokenProgramKey = _ref3.solanaTokenProgramKey, claimableTokenProgramKey = _ref3.claimableTokenProgramKey, transactionHandler = _ref3.transactionHandler, recentBlockhash = _ref3.recentBlockhash;
            // Create instruction data
            ethAddressArr = ethAddressToArray(ethAddress);
            instructionData = new CreateTokenAccountInstructionData({
              ethAddress: ethAddressArr
            });
            serializedInstructionData = borsh$1.serialize(createTokenAccountInstructionSchema, instructionData); // 0th index in the Rust instruction enum

            serializedInstructionEnum = Uint8Array.of.apply(Uint8Array, [0].concat(_toConsumableArray(serializedInstructionData))); // Create the account we aim to generate

            _context2.next = 7;
            return getBankAccountAddress$2(ethAddress, claimableTokenPDAKey, solanaTokenProgramKey);

          case 7:
            accountToGenerate = _context2.sent;
            accounts = [// 0. `[sw]` Account to pay for creating token acc
            {
              pubkey: feePayerKey,
              isSigner: true,
              isWritable: true
            }, // 1. `[r]` Mint account
            {
              pubkey: mintKey,
              isSigner: false,
              isWritable: false
            }, // 2. `[r]` Base acc used in PDA token acc (need because of create_with_seed instruction)
            {
              pubkey: claimableTokenPDAKey,
              isSigner: false,
              isWritable: false
            }, // 3. `[w]` PDA token account to create
            {
              pubkey: accountToGenerate,
              isSigner: false,
              isWritable: true
            }, // `[r]` Rent id
            {
              pubkey: SYSVAR_RENT_PUBKEY$2,
              isSigner: false,
              isWritable: false
            }, // 5. `[r]` SPL token account id
            {
              pubkey: solanaTokenProgramKey,
              isSigner: false,
              isWritable: false
            }, // 6. `[r]` System program id
            {
              pubkey: SystemProgram$2.programId,
              isSigner: false,
              isWritable: false
            }];
            instructions = [new TransactionInstruction$1({
              keys: accounts,
              programId: claimableTokenProgramKey.toString(),
              data: Buffer.from(serializedInstructionEnum)
            })];
            return _context2.abrupt("return", transactionHandler.handleTransaction({
              instructions: instructions,
              recentBlockhash: recentBlockhash,
              feePayerOverride: feePayerKey
            }));

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function createUserBankFrom(_x4) {
    return _ref4.apply(this, arguments);
  };
}();

var userBank = {
  getBankAccountAddress: getBankAccountAddress$2,
  createUserBankFrom: createUserBankFrom$1
};

var ASSOCIATED_TOKEN_PROGRAM_ID = require$$0__default$1["default"].ASSOCIATED_TOKEN_PROGRAM_ID,
    Token = require$$0__default$1["default"].Token;
var PublicKey$3 = require$$1__default["default"].PublicKey,
    SystemProgram$1 = require$$1__default["default"].SystemProgram,
    SYSVAR_RENT_PUBKEY$1 = require$$1__default["default"].SYSVAR_RENT_PUBKEY,
    Keypair = require$$1__default["default"].Keypair;
/**
 * Finds the associated token address given a solana wallet public key
 * @param {PublicKey} solanaWalletKey Public Key for a given solana account (a wallet)
 * @param {PublicKey} mintKey
 * @param {PublicKey} solanaTokenProgramKey
 * @returns {PublicKey} token account public key
 */

function findAssociatedTokenAddress(_x) {
  return _findAssociatedTokenAddress$1.apply(this, arguments);
}
/**
 * Gets token account information (e.g. balance, ownership, etc.)
 * @param {PublicKey} tokenAccountAddressKey
 * @param {PublicKey} mintKey
 * @param {PublicKey} solanaTokenProgramKey
 * @param {Connection} connection
 * @returns {AccountInfo}
 */


function _findAssociatedTokenAddress$1() {
  _findAssociatedTokenAddress$1 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
    var solanaWalletKey, mintKey, solanaTokenProgramKey, addresses;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            solanaWalletKey = _ref.solanaWalletKey, mintKey = _ref.mintKey, solanaTokenProgramKey = _ref.solanaTokenProgramKey;
            _context.next = 3;
            return PublicKey$3.findProgramAddress([solanaWalletKey.toBuffer(), solanaTokenProgramKey.toBuffer(), mintKey.toBuffer()], ASSOCIATED_TOKEN_PROGRAM_ID);

          case 3:
            addresses = _context.sent;
            return _context.abrupt("return", addresses[0]);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _findAssociatedTokenAddress$1.apply(this, arguments);
}

function getAssociatedTokenAccountInfo(_x2) {
  return _getAssociatedTokenAccountInfo$1.apply(this, arguments);
}
/**
 * Creates an associated token account for a given solana account (a wallet)
 * @param {PublicKey} feePayerKey
 * @param {PublicKey} solanaWalletKey the wallet we wish to create a token account for
 * @param {PublicKey} mintKey
 * @param {PublicKey} solanaTokenProgramKey
 * @param {Connection} connection
 * @param {IdentityService} identityService
 */


function _getAssociatedTokenAccountInfo$1() {
  _getAssociatedTokenAccountInfo$1 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
    var tokenAccountAddressKey, mintKey, solanaTokenProgramKey, connection, token, info;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            tokenAccountAddressKey = _ref2.tokenAccountAddressKey, mintKey = _ref2.mintKey, solanaTokenProgramKey = _ref2.solanaTokenProgramKey, connection = _ref2.connection;
            token = new Token(connection, mintKey, solanaTokenProgramKey, Keypair.generate());
            _context2.next = 4;
            return token.getAccountInfo(tokenAccountAddressKey);

          case 4:
            info = _context2.sent;
            return _context2.abrupt("return", info);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getAssociatedTokenAccountInfo$1.apply(this, arguments);
}

function createAssociatedTokenAccount(_x3) {
  return _createAssociatedTokenAccount$1.apply(this, arguments);
}

function _createAssociatedTokenAccount$1() {
  _createAssociatedTokenAccount$1 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref3) {
    var feePayerKey, solanaWalletKey, mintKey, solanaTokenProgramKey, connection, identityService, associatedTokenAddress, accounts, _yield$connection$get, blockhash, transactionData, response;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            feePayerKey = _ref3.feePayerKey, solanaWalletKey = _ref3.solanaWalletKey, mintKey = _ref3.mintKey, solanaTokenProgramKey = _ref3.solanaTokenProgramKey, connection = _ref3.connection, identityService = _ref3.identityService;
            _context3.next = 3;
            return findAssociatedTokenAddress({
              solanaWalletKey: solanaWalletKey,
              mintKey: mintKey,
              solanaTokenProgramKey: solanaTokenProgramKey
            });

          case 3:
            associatedTokenAddress = _context3.sent;
            accounts = [// 0. `[sw]` Funding account (must be a system account)
            {
              pubkey: feePayerKey,
              isSigner: true,
              isWritable: true
            }, // 1. `[w]` Associated token account address to be created
            {
              pubkey: associatedTokenAddress,
              isSigner: false,
              isWritable: true
            }, // 2. `[r]` Wallet address for the new associated token account
            {
              pubkey: solanaWalletKey,
              isSigner: false,
              isWritable: false
            }, // 3. `[r]` The token mint for the new associated token account
            {
              pubkey: mintKey,
              isSigner: false,
              isWritable: false
            }, // 4. `[r]` System program
            {
              pubkey: SystemProgram$1.programId,
              isSigner: false,
              isWritable: false
            }, // 5. `[r]` SPL Token program
            {
              pubkey: solanaTokenProgramKey,
              isSigner: false,
              isWritable: false
            }, // 6. `[r]` Rent sysvar
            {
              pubkey: SYSVAR_RENT_PUBKEY$1,
              isSigner: false,
              isWritable: false
            }];
            _context3.next = 7;
            return connection.getLatestBlockhash();

          case 7:
            _yield$connection$get = _context3.sent;
            blockhash = _yield$connection$get.blockhash;
            transactionData = {
              recentBlockhash: blockhash,
              instructions: [{
                keys: accounts.map(function (account) {
                  return {
                    pubkey: account.pubkey.toString(),
                    isSigner: account.isSigner,
                    isWritable: account.isWritable
                  };
                }),
                programId: ASSOCIATED_TOKEN_PROGRAM_ID.toString(),
                data: Buffer.from([])
              }]
            };
            _context3.next = 12;
            return identityService.solanaRelay(transactionData);

          case 12:
            response = _context3.sent;
            return _context3.abrupt("return", response);

          case 14:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _createAssociatedTokenAccount$1.apply(this, arguments);
}

var tokenAccount = {
  findAssociatedTokenAddress: findAssociatedTokenAddress,
  getAssociatedTokenAccountInfo: getAssociatedTokenAccountInfo,
  createAssociatedTokenAccount: createAssociatedTokenAccount
};

var BN$3 = bn.exports;
var MIN_WAUDIO_AMOUNT = new BN$3('10000000000'); // 10^10

/**
 * Converts Wei Audio (BN) to wAudio (BN).
 * wAudio has only 8 digits of precision vs. 18 in Wei Audio.
 * The amount must be >= 10^10 and have no remainder when divided by 10^10.
 * @param {BN} amount Wei Audio amount
 */

var wAudioFromWeiAudio$2 = function wAudioFromWeiAudio(amount) {
  if (amount.lt(MIN_WAUDIO_AMOUNT)) {
    throw new Error("".concat(amount.toString(), " is below minimum bounds ").concat(MIN_WAUDIO_AMOUNT.toString()));
  }

  var _amount$divmod = amount.divmod(MIN_WAUDIO_AMOUNT),
      div = _amount$divmod.div,
      mod = _amount$divmod.mod;

  if (!mod.isZero()) {
    throw new Error("".concat(amount.toString(), " is too precise for conversion to wAudio. Remainder: ").concat(mod.toString()));
  }

  return div;
};

var wAudio = {
  wAudioFromWeiAudio: wAudioFromWeiAudio$2
};

var require$$18 = /*@__PURE__*/getAugmentedNamespace(utils$1);

var SolanaUtils$3 = utils;
var Transaction = require$$1__default["default"].Transaction,
    PublicKey$2 = require$$1__default["default"].PublicKey;
/**
 * Handles sending Solana transactions, either directly via `sendAndConfirmTransaction`,
 * or via IdentityService's relay.
 */

var TransactionHandler$1 = /*#__PURE__*/function () {
  /**
   * Creates an instance of TransactionHandler.
   *
   * @param {{
   *  connection: Connection,
   *  useRelay: boolean,
   *  identityService: Object,
   *  feePayerKeypairs: KeyPair[]
   *  skipPreflight: boolean
   * }} {
   *  connection,
   *  useRelay,
   *  identityService = null,
   *  feePayerKeypairs = null,
   *  skipPreflight = true
   * }
   * @memberof TransactionHandler
   */
  function TransactionHandler(_ref) {
    var connection = _ref.connection,
        useRelay = _ref.useRelay,
        _ref$identityService = _ref.identityService,
        identityService = _ref$identityService === void 0 ? null : _ref$identityService,
        _ref$feePayerKeypairs = _ref.feePayerKeypairs,
        feePayerKeypairs = _ref$feePayerKeypairs === void 0 ? null : _ref$feePayerKeypairs,
        _ref$skipPreflight = _ref.skipPreflight,
        skipPreflight = _ref$skipPreflight === void 0 ? true : _ref$skipPreflight,
        _ref$retryTimeoutMs = _ref.retryTimeoutMs,
        retryTimeoutMs = _ref$retryTimeoutMs === void 0 ? 60000 : _ref$retryTimeoutMs,
        _ref$pollingFrequency = _ref.pollingFrequencyMs,
        pollingFrequencyMs = _ref$pollingFrequency === void 0 ? 300 : _ref$pollingFrequency,
        _ref$sendingFrequency = _ref.sendingFrequencyMs,
        sendingFrequencyMs = _ref$sendingFrequency === void 0 ? 300 : _ref$sendingFrequency;

    _classCallCheck(this, TransactionHandler);

    this.connection = connection;
    this.useRelay = useRelay;
    this.identityService = identityService;
    this.feePayerKeypairs = feePayerKeypairs;
    this.skipPreflight = skipPreflight;
    this.retryTimeoutMs = retryTimeoutMs;
    this.pollingFrequencyMs = pollingFrequencyMs;
    this.sendingFrequencyMs = sendingFrequencyMs;
  }
  /**
   * Primary method to send a Solana transaction.
   *
   * @typedef {Object} HandleTransactionReturn
   * @property {Object} res the result
   * @property {string} [error=null] the optional error
   *  Will be a string if `errorMapping` is passed to the handler.
   * @property {string|number} [error_code=null] the optional error code.
   * @property {string} [recentBlockhash=null] optional recent blockhash to prefer over fetching
   * @property {boolean} [skipPreflight=null] optional per transaction override to skipPreflight
   * @property {any} [logger=console] optional logger
   * @property {any} [feePayerOverride=null] optional fee payer override
   *
   * @param {Array<TransactionInstruction>} instructions an array of `TransactionInstructions`
   * @param {*} [errorMapping=null] an optional error mapping. Should expose a `fromErrorCode` method.
   * @param {Array<{publicKey: string, signature: Buffer}>} [signature=null] optional signatures
   * @returns {Promise<HandleTransactionReturn>}
   * @memberof TransactionHandler
   */


  _createClass(TransactionHandler, [{
    key: "handleTransaction",
    value: function () {
      var _handleTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref2) {
        var instructions, _ref2$errorMapping, errorMapping, _ref2$recentBlockhash, recentBlockhash, _ref2$logger, logger, _ref2$skipPreflight, skipPreflight, _ref2$feePayerOverrid, feePayerOverride, _ref2$sendBlockhash, sendBlockhash, _ref2$signatures, signatures, _ref2$retry, retry, result;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                instructions = _ref2.instructions, _ref2$errorMapping = _ref2.errorMapping, errorMapping = _ref2$errorMapping === void 0 ? null : _ref2$errorMapping, _ref2$recentBlockhash = _ref2.recentBlockhash, recentBlockhash = _ref2$recentBlockhash === void 0 ? null : _ref2$recentBlockhash, _ref2$logger = _ref2.logger, logger = _ref2$logger === void 0 ? console : _ref2$logger, _ref2$skipPreflight = _ref2.skipPreflight, skipPreflight = _ref2$skipPreflight === void 0 ? null : _ref2$skipPreflight, _ref2$feePayerOverrid = _ref2.feePayerOverride, feePayerOverride = _ref2$feePayerOverrid === void 0 ? null : _ref2$feePayerOverrid, _ref2$sendBlockhash = _ref2.sendBlockhash, sendBlockhash = _ref2$sendBlockhash === void 0 ? true : _ref2$sendBlockhash, _ref2$signatures = _ref2.signatures, signatures = _ref2$signatures === void 0 ? null : _ref2$signatures, _ref2$retry = _ref2.retry, retry = _ref2$retry === void 0 ? true : _ref2$retry;
                result = null;

                if (!this.useRelay) {
                  _context.next = 8;
                  break;
                }

                _context.next = 5;
                return this._relayTransaction(instructions, recentBlockhash, skipPreflight, feePayerOverride, sendBlockhash, signatures, retry);

              case 5:
                result = _context.sent;
                _context.next = 11;
                break;

              case 8:
                _context.next = 10;
                return this._locallyConfirmTransaction(instructions, recentBlockhash, logger, skipPreflight, feePayerOverride, signatures, retry);

              case 10:
                result = _context.sent;

              case 11:
                if (result.error && result.errorCode !== null && errorMapping) {
                  result.errorCode = errorMapping.fromErrorCode(result.errorCode);
                }

                return _context.abrupt("return", result);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function handleTransaction(_x) {
        return _handleTransaction.apply(this, arguments);
      }

      return handleTransaction;
    }()
  }, {
    key: "_relayTransaction",
    value: function () {
      var _relayTransaction2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(instructions, recentBlockhash, skipPreflight) {
        var feePayerOverride,
            sendBlockhash,
            signatures,
            retry,
            relayable,
            transactionData,
            response,
            error,
            errorCode,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                feePayerOverride = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : null;
                sendBlockhash = _args2.length > 4 ? _args2[4] : undefined;
                signatures = _args2.length > 5 ? _args2[5] : undefined;
                retry = _args2.length > 6 ? _args2[6] : undefined;
                relayable = instructions.map(SolanaUtils$3.prepareInstructionForRelay);
                transactionData = {
                  signatures: signatures,
                  instructions: relayable,
                  skipPreflight: skipPreflight === null ? this.skipPreflight : skipPreflight,
                  feePayerOverride: feePayerOverride ? feePayerOverride.toString() : null,
                  retry: retry
                };

                if (!(sendBlockhash || Array.isArray(signatures))) {
                  _context2.next = 13;
                  break;
                }

                _context2.t0 = recentBlockhash;

                if (_context2.t0) {
                  _context2.next = 12;
                  break;
                }

                _context2.next = 11;
                return this.connection.getLatestBlockhash('confirmed');

              case 11:
                _context2.t0 = _context2.sent.blockhash;

              case 12:
                transactionData.recentBlockhash = _context2.t0;

              case 13:
                _context2.prev = 13;
                _context2.next = 16;
                return this.identityService.solanaRelay(transactionData);

              case 16:
                response = _context2.sent;
                return _context2.abrupt("return", {
                  res: response,
                  error: null,
                  errorCode: null
                });

              case 20:
                _context2.prev = 20;
                _context2.t1 = _context2["catch"](13);
                error = _context2.t1.response && _context2.t1.response.data && _context2.t1.response.data.error || _context2.t1.message;
                errorCode = this._parseSolanaErrorCode(error);
                return _context2.abrupt("return", {
                  res: null,
                  error: error,
                  errorCode: errorCode
                });

              case 25:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[13, 20]]);
      }));

      function _relayTransaction(_x2, _x3, _x4) {
        return _relayTransaction2.apply(this, arguments);
      }

      return _relayTransaction;
    }()
  }, {
    key: "_locallyConfirmTransaction",
    value: function () {
      var _locallyConfirmTransaction2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(instructions, recentBlockhash, logger, skipPreflight) {
        var _this = this;

        var feePayerOverride,
            signatures,
            retry,
            feePayerKeypairOverride,
            feePayerAccount,
            tx,
            rawTransaction,
            sendRawTransaction,
            txid,
            error,
            errorCode,
            done,
            sendCount,
            startTime,
            _error,
            _errorCode,
            _args5 = arguments;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                feePayerOverride = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : null;
                signatures = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : null;
                retry = _args5.length > 6 && _args5[6] !== undefined ? _args5[6] : true;

                feePayerKeypairOverride = function () {
                  if (feePayerOverride && _this.feePayerKeypairs) {
                    var stringFeePayer = feePayerOverride.toString();
                    return _this.feePayerKeypairs.find(function (keypair) {
                      return keypair.publicKey.toString() === stringFeePayer;
                    });
                  }

                  return null;
                }();

                feePayerAccount = feePayerKeypairOverride || this.feePayerKeypairs && this.feePayerKeypairs[0];

                if (feePayerAccount) {
                  _context5.next = 8;
                  break;
                }

                logger.error('transactionHandler: Local feepayer keys missing for direct confirmation!');
                return _context5.abrupt("return", {
                  res: null,
                  error: 'Missing keys',
                  errorCode: null
                });

              case 8:
                _context5.t0 = recentBlockhash;

                if (_context5.t0) {
                  _context5.next = 13;
                  break;
                }

                _context5.next = 12;
                return this.connection.getLatestBlockhash('confirmed');

              case 12:
                _context5.t0 = _context5.sent.blockhash;

              case 13:
                recentBlockhash = _context5.t0;
                // Construct the txn
                tx = new Transaction({
                  recentBlockhash: recentBlockhash
                });
                instructions.forEach(function (i) {
                  return tx.add(i);
                });
                tx.feePayer = feePayerAccount.publicKey;
                tx.sign(feePayerAccount);

                if (Array.isArray(signatures)) {
                  signatures.forEach(function (_ref3) {
                    var publicKey = _ref3.publicKey,
                        signature = _ref3.signature;
                    tx.addSignature(new PublicKey$2(publicKey), signature);
                  });
                }

                rawTransaction = tx.serialize(); // Send the txn

                sendRawTransaction = /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            return _context3.abrupt("return", _this.connection.sendRawTransaction(rawTransaction, {
                              skipPreflight: skipPreflight === null ? _this.skipPreflight : skipPreflight,
                              commitment: 'processed',
                              preflightCommitment: 'processed',
                              maxRetries: retry ? 0 : undefined
                            }));

                          case 1:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function sendRawTransaction() {
                    return _ref4.apply(this, arguments);
                  };
                }();

                _context5.prev = 21;
                _context5.next = 24;
                return sendRawTransaction();

              case 24:
                txid = _context5.sent;
                _context5.next = 33;
                break;

              case 27:
                _context5.prev = 27;
                _context5.t1 = _context5["catch"](21);
                // Rarely, this intiial send will fail
                logger.warn("transactionHandler: Initial send failed: ".concat(_context5.t1));
                error = _context5.t1.message;
                errorCode = this._parseSolanaErrorCode(error);
                return _context5.abrupt("return", {
                  res: null,
                  error: error,
                  errorCode: errorCode
                });

              case 33:
                done = false; // Start up resubmission loop

                sendCount = 0;
                startTime = Date.now();

                if (retry) {

                  _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                    var elapsed;
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            elapsed = Date.now() - startTime; // eslint-disable-next-line no-unmodified-loop-condition

                          case 1:
                            if (!(!done && elapsed < _this.retryTimeoutMs)) {
                              _context4.next = 9;
                              break;
                            }

                            try {
                              sendRawTransaction();
                            } catch (e) {
                              logger.warn("transactionHandler: error in send loop: ".concat(e, " for txId ").concat(txid));
                            }

                            sendCount++;
                            _context4.next = 6;
                            return delay(_this.sendingFrequencyMs);

                          case 6:
                            elapsed = Date.now() - startTime;
                            _context4.next = 1;
                            break;

                          case 9:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }))();
                } // Await for tx confirmation


                _context5.prev = 37;
                _context5.next = 40;
                return this._awaitTransactionSignatureConfirmation(txid, logger);

              case 40:
                done = true;
                logger.info("transactionHandler: finished for txid ".concat(txid, " with ").concat(sendCount, " retries"));
                return _context5.abrupt("return", {
                  res: txid,
                  error: null,
                  errorCode: null
                });

              case 45:
                _context5.prev = 45;
                _context5.t2 = _context5["catch"](37);
                logger.warn("transactionHandler: error in awaitTransactionSignature: ".concat(JSON.stringify(_context5.t2), ", ").concat(txid));
                done = true;
                _error = _context5.t2.message;
                _errorCode = this._parseSolanaErrorCode(_error);
                return _context5.abrupt("return", {
                  res: null,
                  error: _error,
                  errorCode: _errorCode
                });

              case 52:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[21, 27], [37, 45]]);
      }));

      function _locallyConfirmTransaction(_x5, _x6, _x7, _x8) {
        return _locallyConfirmTransaction2.apply(this, arguments);
      }

      return _locallyConfirmTransaction;
    }()
  }, {
    key: "_awaitTransactionSignatureConfirmation",
    value: function () {
      var _awaitTransactionSignatureConfirmation2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(txid, logger) {
        var _this2 = this;

        var done, result;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                done = false;
                _context8.next = 3;
                return new Promise(function (resolve, reject) {

                  _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
                    return regeneratorRuntime.wrap(function _callee7$(_context7) {
                      while (1) {
                        switch (_context7.prev = _context7.next) {
                          case 0:
                            // Setup timeout if nothing else finishes
                            setTimeout(function () {
                              if (done) {
                                return;
                              }

                              done = true;
                              var message = "transactionHandler: Timed out in await, ".concat(txid);
                              logger.warn(message);
                              reject(new Error(message));
                            }, _this2.retryTimeoutMs); // Setup WS listener

                            // Setup WS listener
                            try {
                              _this2.connection.onSignature(txid, function (result) {
                                if (done) return;
                                done = true;

                                if (result.err) {
                                  var err = JSON.stringify(result.err);
                                  logger.warn("transactionHandler: Error in onSignature ".concat(txid, ", ").concat(err));
                                  reject(new Error(err));
                                } else {
                                  resolve(txid);
                                }
                              }, 'processed');
                            } catch (e) {
                              done = true;
                              logger.error("transactionHandler: WS error in setup ".concat(txid, ", ").concat(e));
                            } // Setup polling


                          case 2:
                            if (done) {
                              _context7.next = 9;
                              break;
                            }

                            _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
                              var signatureStatuses, _result, err;

                              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                                while (1) {
                                  switch (_context6.prev = _context6.next) {
                                    case 0:
                                      _context6.prev = 0;
                                      _context6.next = 3;
                                      return _this2.connection.getSignatureStatuses([txid]);

                                    case 3:
                                      signatureStatuses = _context6.sent;
                                      _result = signatureStatuses === null || signatureStatuses === void 0 ? void 0 : signatureStatuses.value[0]; // Early return this iteration if already done, or no result

                                      if (!(done || !_result)) {
                                        _context6.next = 7;
                                        break;
                                      }

                                      return _context6.abrupt("return");

                                    case 7:
                                      if (!_result.err) {
                                        _context6.next = 13;
                                        break;
                                      }

                                      err = JSON.stringify(_result.err);
                                      logger.error("transactionHandler: polling saw result error: ".concat(err, ", tx: ").concat(txid));
                                      done = true;
                                      reject(new Error(err));
                                      return _context6.abrupt("return");

                                    case 13:
                                      if (_result.confirmations || _result.confirmationStatus === 'confirmed' || _result.confirmationStatus === 'finalized') {
                                        _context6.next = 15;
                                        break;
                                      }

                                      return _context6.abrupt("return");

                                    case 15:
                                      // Otherwise, we made it
                                      done = true;
                                      resolve(txid);
                                      _context6.next = 22;
                                      break;

                                    case 19:
                                      _context6.prev = 19;
                                      _context6.t0 = _context6["catch"](0);

                                      if (!done) {
                                        logger.error("transactionHandler: REST polling connection error: ".concat(_context6.t0, ", tx: ").concat(txid));
                                      }

                                    case 22:
                                    case "end":
                                      return _context6.stop();
                                  }
                                }
                              }, _callee6, null, [[0, 19]]);
                            }))();

                            _context7.next = 7;
                            return delay(_this2.pollingFrequencyMs);

                          case 7:
                            _context7.next = 2;
                            break;

                          case 9:
                          case "end":
                            return _context7.stop();
                        }
                      }
                    }, _callee7);
                  }))();
                });

              case 3:
                result = _context8.sent;
                done = true;
                return _context8.abrupt("return", result);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      function _awaitTransactionSignatureConfirmation(_x9, _x10) {
        return _awaitTransactionSignatureConfirmation2.apply(this, arguments);
      }

      return _awaitTransactionSignatureConfirmation;
    }()
    /**
     * Attempts to parse an error code out of a message of the form:
     * "... custom program error: 0x1", where the return in this case would be the number 1.
     * Returns null for unparsable strings.
     */

  }, {
    key: "_parseSolanaErrorCode",
    value: function _parseSolanaErrorCode(errorMessage) {
      if (!errorMessage) return null; // Match on custom solana program errors

      var matcher = /(?:custom program error: 0x)(.*)$/;
      var res = errorMessage.match(matcher);
      if (res && res.length === 2) return parseInt(res[1], 16) || null; // Match on custom anchor errors

      var matcher2 = /(?:"Custom":)(\d+)/;
      var res2 = errorMessage.match(matcher2);
      if (res2 && res2.length === 2) return parseInt(res2[1], 10) || null;
      return null;
    }
  }]);

  return TransactionHandler;
}();

function delay(_x11) {
  return _delay.apply(this, arguments);
}

function _delay() {
  _delay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(ms) {
    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            return _context9.abrupt("return", new Promise(function (resolve) {
              return setTimeout(resolve, ms);
            }));

          case 1:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _delay.apply(this, arguments);
}

var transactionHandler = {
  TransactionHandler: TransactionHandler$1
};

var TOKEN_PROGRAM_ID = require$$0__default$1["default"].TOKEN_PROGRAM_ID;
var Secp256k1Program = require$$1__default["default"].Secp256k1Program,
    SystemProgram = require$$1__default["default"].SystemProgram,
    SYSVAR_INSTRUCTIONS_PUBKEY = require$$1__default["default"].SYSVAR_INSTRUCTIONS_PUBKEY,
    SYSVAR_RENT_PUBKEY = require$$1__default["default"].SYSVAR_RENT_PUBKEY,
    TransactionInstruction = require$$1__default["default"].TransactionInstruction;
var borsh = require$$1__default$1["default"];
var getBankAccountAddress$1 = userBank.getBankAccountAddress;
var BN$2 = bn.exports;
var SolanaUtils$2 = utils;
var RewardsManagerError$1 = errors.RewardsManagerError; // Various prefixes used for rewards

var SENDER_SEED_PREFIX = 'S_';
var VERIFY_TRANSFER_SEED_PREFIX = 'V_';
var TRANSFER_PREFIX = 'T_';
var ADD_SENDER_MESSAGE_PREFIX = 'add'; // Enum cases for instructions

var CREATE_SENDER_PUBLIC_ENUM_VALUE = 4;
var SUBMIT_INSTRUCTION_ENUM_VALUE = 6;
var EVALUATE_INSTRUCTION_ENUM_VALUE = 7;
var ATTESTATION_INSTRUCTIONS_PER_TRANSACTION = 4;
var encoder = new TextEncoder();

var SubmitAttestationInstructionData = /*#__PURE__*/_createClass(
/**
 * Creates an instance of SubmitAttestationInstructionData.
 * @param {{transferId: string}} {
 *     transferId
 *   }
 * @memberof SubmitAttestationInstructionData
 */
function SubmitAttestationInstructionData(_ref) {
  var transferId = _ref.transferId;

  _classCallCheck(this, SubmitAttestationInstructionData);

  this.id = transferId;
});

var submitAttestationInstructionSchema = new Map([[SubmitAttestationInstructionData, {
  kind: 'struct',
  fields: [['id', 'string']]
}]]);

var ValidateAttestationsInstructionData = /*#__PURE__*/_createClass(
/**
 * Creates an instance of ValidateAttestationsInstructionData.
 * @param {{
 *     amount: number,
 *     id: string,
 *     ethRecipient: Uint8Array
 *   }} {
 *     amount,
 *     id,
 *     ethRecipient
 *   }
 * @memberof ValidateAttestationsInstructionData
 */
function ValidateAttestationsInstructionData(_ref2) {
  var amount = _ref2.amount,
      id = _ref2.id,
      ethRecipient = _ref2.ethRecipient;

  _classCallCheck(this, ValidateAttestationsInstructionData);

  this.amount = amount;
  this.id = id;
  this.eth_recipient = ethRecipient;
});

var validateAttestationsInstructionSchema = new Map([[ValidateAttestationsInstructionData, {
  kind: 'struct',
  fields: [['amount', 'u64'], ['id', 'string'], ['eth_recipient', [20]]]
}]]);

var CreateSenderPublicInstructionData = /*#__PURE__*/_createClass(
/**
 * Creates an instance of CreateSenderPublicInstructionData
 * @param {{
 *    ethAddress: Uint8Array
 *    operator: Uint8Array
 * }} {
 *    ethAddress,
 *    operator
 * }
 */
function CreateSenderPublicInstructionData(_ref3) {
  var ethAddress = _ref3.ethAddress,
      operator = _ref3.operator;

  _classCallCheck(this, CreateSenderPublicInstructionData);

  this.eth_address = ethAddress;
  this.operator = operator;
});

var createSenderPublicInstructionSchema = new Map([[CreateSenderPublicInstructionData, {
  kind: 'struct',
  fields: [['eth_address', [20]], ['operator', [20]]]
}]]);
/**
 * @typedef {Object} AttestationMeta
 * @property {string} ethAddress
 * @property {string} signature
 */

/**
 * Submits attestations from Discovery Nodes and AAO that a user has completed a challenge.
 *
 *
 * @param {{
 *   rewardManagerProgramId: PublicKey,
 *   rewardManagerAccount: PublicKey,
 *   attestations: AttestationMeta[]
 *   oracleAttestation: AttestationMeta
 *   challengeId: string,
 *   specifier: string,
 *   feePayer: PublicKey,
 *   attestationSignature: string,
 *   recipientEthAddress: string,
 *   tokenAmount: BN,
 *   transactionHandler: TransactionHandler,
 *   instructionsPerTransaction?: number,
 *   logger: any
 * }} {
 *   rewardManagerProgramId,
 *   rewardManagerAccount,
 *   attestations,
 *   oracleAttestation,
 *   challengeId,
 *   specifier,
 *   feePayer,
 *   recipientEthAddress,
 *   tokenAmount,
 *   transactionHandler,
 *   instructionsPerTransaction,
 *   logger
 * }
 */

function submitAttestations$1(_x) {
  return _submitAttestations.apply(this, arguments);
}
/**
 * Creates a new rewards signer (one that can attest)
 *
 * @param {{
 *   rewardManagerProgramId: PublicKey,
 *   rewardManagerAccount: PublicKey,
 *   senderEthAddress: string,
 *   feePayer: PublicKey,
 *   operatorEthAddress: string,
 *   attestations: AttestationMeta[],
 *   identityService: any
 *   connection: Connection
 * }} {
 *   rewardManagerProgramId,
 *   rewardManagerAccount,
 *   senderEthAddress,
 *   feePayer,
 *   operatorEthAddress,
 *   attestations,
 *   identityService,
 *   connection
 * }
 */


function _submitAttestations() {
  _submitAttestations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref4) {
    var rewardManagerProgramId, rewardManagerAccount, attestations, oracleAttestation, challengeId, specifier, feePayer, recipientEthAddress, tokenAmount, transactionHandler, _ref4$instructionsPer, instructionsPerTransaction, _ref4$logger, logger, transferId, _yield$deriveMessageA3, _yield$deriveMessageA4, rewardManagerAuthority, derivedMessageAccount, encodedSenderMessage, instructions, encodedOracleMessage, oracleSecp, oracleTransfer, bucketedInstructions, results, _iterator, _step, res;

    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            rewardManagerProgramId = _ref4.rewardManagerProgramId, rewardManagerAccount = _ref4.rewardManagerAccount, attestations = _ref4.attestations, oracleAttestation = _ref4.oracleAttestation, challengeId = _ref4.challengeId, specifier = _ref4.specifier, feePayer = _ref4.feePayer, recipientEthAddress = _ref4.recipientEthAddress, tokenAmount = _ref4.tokenAmount, transactionHandler = _ref4.transactionHandler, _ref4$instructionsPer = _ref4.instructionsPerTransaction, instructionsPerTransaction = _ref4$instructionsPer === void 0 ? ATTESTATION_INSTRUCTIONS_PER_TRANSACTION : _ref4$instructionsPer, _ref4$logger = _ref4.logger, logger = _ref4$logger === void 0 ? console : _ref4$logger;
            // Construct combined transfer ID
            transferId = SolanaUtils$2.constructTransferId(challengeId, specifier); // Derive the message account we'll use to store the attestations

            _context8.next = 4;
            return deriveMessageAccount(transferId, rewardManagerProgramId, rewardManagerAccount);

          case 4:
            _yield$deriveMessageA3 = _context8.sent;
            _yield$deriveMessageA4 = _slicedToArray(_yield$deriveMessageA3, 2);
            rewardManagerAuthority = _yield$deriveMessageA4[0];
            derivedMessageAccount = _yield$deriveMessageA4[1];
            encodedSenderMessage = SolanaUtils$2.constructAttestation(recipientEthAddress, tokenAmount, transferId, oracleAttestation.ethAddress); // Add instructions from DN attestations - each attestation
            // needs a pairing of SECP recovery instruction and submit
            // attestation instruction.

            _context8.next = 11;
            return Promise.all(attestations.reduce(function (instructions, meta, i) {
              var secpInstruction = Promise.resolve(generateAttestationSecpInstruction({
                attestationMeta: meta,
                recipientEthAddress: recipientEthAddress,
                tokenAmount: tokenAmount,
                transferId: transferId,
                instructionIndex: 2 * i % instructionsPerTransaction,
                encodedSenderMessage: encodedSenderMessage
              }));
              var verifyInstruction = generateSubmitAttestationInstruction({
                attestationMeta: meta,
                derivedMessageAccount: derivedMessageAccount,
                rewardManagerAccount: rewardManagerAccount,
                rewardManagerProgramId: rewardManagerProgramId,
                rewardManagerAuthority: rewardManagerAuthority,
                transferId: transferId,
                feePayer: feePayer
              });
              return [].concat(_toConsumableArray(instructions), [secpInstruction, verifyInstruction]);
            }, []));

          case 11:
            instructions = _context8.sent;
            encodedOracleMessage = SolanaUtils$2.constructAttestation(recipientEthAddress, tokenAmount, transferId); // Add instructions from oracle attestation

            _context8.next = 15;
            return generateAttestationSecpInstruction({
              attestationMeta: oracleAttestation,
              recipientEthAddress: recipientEthAddress,
              instructionIndex: instructions.length % instructionsPerTransaction,
              tokenAmount: tokenAmount,
              transferId: transferId,
              encodedSenderMessage: encodedOracleMessage
            });

          case 15:
            oracleSecp = _context8.sent;
            _context8.next = 18;
            return generateSubmitAttestationInstruction({
              attestationMeta: oracleAttestation,
              derivedMessageAccount: derivedMessageAccount,
              rewardManagerAccount: rewardManagerAccount,
              rewardManagerProgramId: rewardManagerProgramId,
              rewardManagerAuthority: rewardManagerAuthority,
              transferId: transferId,
              feePayer: feePayer
            });

          case 18:
            oracleTransfer = _context8.sent;
            // Break the instructions up into multiple transactions as per `instructionsPerTransaction`
            instructions = [].concat(_toConsumableArray(instructions), [oracleSecp, oracleTransfer]);
            bucketedInstructions = instructions.reduce(function (acc, cur) {
              if (acc[acc.length - 1].length < instructionsPerTransaction) {
                acc[acc.length - 1].push(cur);
              } else {
                acc.push([cur]);
              }

              return acc;
            }, [[]]);
            _context8.next = 23;
            return Promise.all(bucketedInstructions.map(function (i) {
              return transactionHandler.handleTransaction({
                instructions: i,
                errorMapping: RewardsManagerError$1,
                logger: logger,
                skipPreflight: false,
                feePayerOverride: feePayer,
                sendBlockhash: false
              });
            }));

          case 23:
            results = _context8.sent;
            logger.info("submitAttestations: submitted attestations with results: ".concat(JSON.stringify(results))); // If there's any error in any of the transactions, just return that one

            _iterator = _createForOfIteratorHelper(results);
            _context8.prev = 26;

            _iterator.s();

          case 28:
            if ((_step = _iterator.n()).done) {
              _context8.next = 34;
              break;
            }

            res = _step.value;

            if (!(res.error || res.errorCode)) {
              _context8.next = 32;
              break;
            }

            return _context8.abrupt("return", res);

          case 32:
            _context8.next = 28;
            break;

          case 34:
            _context8.next = 39;
            break;

          case 36:
            _context8.prev = 36;
            _context8.t0 = _context8["catch"](26);

            _iterator.e(_context8.t0);

          case 39:
            _context8.prev = 39;

            _iterator.f();

            return _context8.finish(39);

          case 42:
            return _context8.abrupt("return", results[0]);

          case 43:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, null, [[26, 36, 39, 42]]);
  }));
  return _submitAttestations.apply(this, arguments);
}

function createSender(_x2) {
  return _createSender$1.apply(this, arguments);
}
/**
 * Evaluates previously submitted attestations, disbursing if successful.
 *
 * @param {{
 *   rewardManagerProgramId: PublicKey
 *   rewardManagerAccount: PublicKey
 *   rewardManagerTokenSource: PublicKey
 *   challengeId: string
 *   specifier: string
 *   recipientEthAddress: string
 *   userBankProgramAccount: PublicKey,
 *   oracleEthAddress: string
 *   feePayer: PublicKey
 *   tokenAmount: BN
 *   tokenAmount: BN,
 *   transactionHandler: TransactionHandler,
 *   logger: any
 * }} {
 *   rewardManagerProgramId,
 *   rewardManagerAccount,
 *   rewardManagerTokenSource,
 *   challengeId,
 *   specifier,
 *   recipientEthAddress,
 *   userBankProgramAccount,
 *   oracleEthAddress,
 *   feePayer,
 *   tokenAmount,
 *   transactionHandler,
 *   logger
 * }
 */


function _createSender$1() {
  _createSender$1 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_ref5) {
    var rewardManagerProgramId, rewardManagerAccount, senderEthAddress, feePayer, operatorEthAddress, attestations, transactionHandler, _yield$SolanaUtils$fi5, _yield$SolanaUtils$fi6, rewardManagerAuthority, encodedSenderMessage, signerEthAddresses, signerInstructions, createSenderInstruction, instructions;

    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            rewardManagerProgramId = _ref5.rewardManagerProgramId, rewardManagerAccount = _ref5.rewardManagerAccount, senderEthAddress = _ref5.senderEthAddress, feePayer = _ref5.feePayer, operatorEthAddress = _ref5.operatorEthAddress, attestations = _ref5.attestations, transactionHandler = _ref5.transactionHandler;
            _context9.next = 3;
            return SolanaUtils$2.findProgramAddressFromPubkey(rewardManagerProgramId, rewardManagerAccount);

          case 3:
            _yield$SolanaUtils$fi5 = _context9.sent;
            _yield$SolanaUtils$fi6 = _slicedToArray(_yield$SolanaUtils$fi5, 1);
            rewardManagerAuthority = _yield$SolanaUtils$fi6[0];
            encodedSenderMessage = constructCreateSenderMessage(senderEthAddress, rewardManagerAccount);
            signerEthAddresses = attestations.map(function (meta) {
              return meta.ethAddress;
            });
            signerInstructions = attestations.map(function (meta, i) {
              return generateCreateSenderSecpInstruction({
                ethAddress: senderEthAddress,
                attestationMeta: meta,
                instructionIndex: i,
                encodedSenderMessage: encodedSenderMessage
              });
            });
            _context9.next = 11;
            return generateCreateSenderInstruction({
              senderEthAddress: senderEthAddress,
              operatorEthAddress: operatorEthAddress,
              rewardManagerAccount: rewardManagerAccount,
              rewardManagerAuthority: rewardManagerAuthority,
              rewardManagerProgramId: rewardManagerProgramId,
              feePayer: feePayer,
              signerEthAddresses: signerEthAddresses
            });

          case 11:
            createSenderInstruction = _context9.sent;
            instructions = [].concat(_toConsumableArray(signerInstructions), [createSenderInstruction]);
            return _context9.abrupt("return", transactionHandler.handleTransaction({
              instructions: instructions,
              errorMapping: RewardsManagerError$1,
              feePayerOverride: feePayer
            }));

          case 14:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _createSender$1.apply(this, arguments);
}

var evaluateAttestations$1 = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref6) {
    var rewardManagerProgramId, rewardManagerAccount, rewardManagerTokenSource, challengeId, specifier, recipientEthAddress, userBankProgramAccount, oracleEthAddress, feePayer, tokenAmount, transactionHandler, _ref6$logger, logger, transferId, _yield$deriveMessageA, _yield$deriveMessageA2, rewardManagerAuthority, verifiedMessagesAccount, transferAccount, recipientBankAccount, derivedAAOAddress, accounts, instructionData, serializedInstructionData, serializedInstructionEnum, transferInstruction;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            rewardManagerProgramId = _ref6.rewardManagerProgramId, rewardManagerAccount = _ref6.rewardManagerAccount, rewardManagerTokenSource = _ref6.rewardManagerTokenSource, challengeId = _ref6.challengeId, specifier = _ref6.specifier, recipientEthAddress = _ref6.recipientEthAddress, userBankProgramAccount = _ref6.userBankProgramAccount, oracleEthAddress = _ref6.oracleEthAddress, feePayer = _ref6.feePayer, tokenAmount = _ref6.tokenAmount, transactionHandler = _ref6.transactionHandler, _ref6$logger = _ref6.logger, logger = _ref6$logger === void 0 ? console : _ref6$logger;
            // Get transfer ID
            transferId = SolanaUtils$2.constructTransferId(challengeId, specifier); // Derive the messages account we previously stored attestations in

            _context.next = 4;
            return deriveMessageAccount(transferId, rewardManagerProgramId, rewardManagerAccount);

          case 4:
            _yield$deriveMessageA = _context.sent;
            _yield$deriveMessageA2 = _slicedToArray(_yield$deriveMessageA, 2);
            rewardManagerAuthority = _yield$deriveMessageA2[0];
            verifiedMessagesAccount = _yield$deriveMessageA2[1];
            _context.next = 10;
            return deriveTransferAccount(transferId, rewardManagerProgramId, rewardManagerAccount);

          case 10:
            transferAccount = _context.sent;
            _context.next = 13;
            return getBankAccountAddress$1(recipientEthAddress, userBankProgramAccount, TOKEN_PROGRAM_ID);

          case 13:
            recipientBankAccount = _context.sent;
            _context.next = 16;
            return deriveSolanaSenderFromEthAddress$1(oracleEthAddress, rewardManagerProgramId, rewardManagerAccount);

          case 16:
            derivedAAOAddress = _context.sent;
            // Construct the requried accounts
            ///   0. `[]` Verified messages
            ///   1. `[]` Reward manager
            ///   2. `[]` Reward manager authority
            ///   3. `[]` Reward token source
            ///   4. `[]` Reward token recipient
            ///   5. `[]` Transfer account
            ///   6. `[]` Bot oracle
            ///   7. `[]` Payer
            ///   8. `[]` Sysvar rent
            ///   9. `[]` Token program id
            ///  10. `[]` System program id
            accounts = [{
              pubkey: verifiedMessagesAccount,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: rewardManagerAccount,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: rewardManagerAuthority,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: rewardManagerTokenSource,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: recipientBankAccount,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: transferAccount,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: derivedAAOAddress,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: feePayer,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: TOKEN_PROGRAM_ID,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SystemProgram.programId,
              isSigner: false,
              isWritable: false
            }]; // Construct the instruction data

            instructionData = new ValidateAttestationsInstructionData({
              amount: tokenAmount.toNumber(),
              id: transferId,
              ethRecipient: SolanaUtils$2.ethAddressToArray(recipientEthAddress)
            });
            serializedInstructionData = borsh.serialize(validateAttestationsInstructionSchema, instructionData);
            serializedInstructionEnum = Buffer.from(Uint8Array.of.apply(Uint8Array, [EVALUATE_INSTRUCTION_ENUM_VALUE].concat(_toConsumableArray(serializedInstructionData))));
            transferInstruction = new TransactionInstruction({
              keys: accounts,
              programId: rewardManagerProgramId,
              data: serializedInstructionEnum
            });
            return _context.abrupt("return", transactionHandler.handleTransaction({
              instructions: [transferInstruction],
              errorMapping: RewardsManagerError$1,
              logger: logger,
              skipPreflight: false,
              feePayerOverride: feePayer,
              sendBlockhash: false
            }));

          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function evaluateAttestations(_x3) {
    return _ref7.apply(this, arguments);
  };
}(); // Helpers
// Generate particular instructions

/**
 *
 * Helper function to generate a submit attestation instruction.
 * @param {{
 *   attestationMeta: AttestationMeta,
 *   derivedMessageAccount: PublicKey
 *   rewardManagerAccount: PublicKey
 *   rewardManagerAuthority: PublicKey
 *   rewardManagerProgramId: PublicKey
 *   feePayer: PublicKey
 *   transferId: string
 * }} {
 *   attestationMeta,
 *   derivedMessageAccount,
 *   rewardManagerAccount,
 *   rewardManagerAuthority,
 *   rewardManagerProgramId,
 *   feePayer,
 *   transferId
 * }
 * @returns {Promise<TransactionInstruction>}
 */


var generateSubmitAttestationInstruction = /*#__PURE__*/function () {
  var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref8) {
    var attestationMeta, derivedMessageAccount, rewardManagerAccount, rewardManagerAuthority, rewardManagerProgramId, feePayer, transferId, derivedSender, verifyInstructionAccounts, instructionData, serializedInstructionData, serializedInstructionEnum;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            attestationMeta = _ref8.attestationMeta, derivedMessageAccount = _ref8.derivedMessageAccount, rewardManagerAccount = _ref8.rewardManagerAccount, rewardManagerAuthority = _ref8.rewardManagerAuthority, rewardManagerProgramId = _ref8.rewardManagerProgramId, feePayer = _ref8.feePayer, transferId = _ref8.transferId;
            _context2.next = 3;
            return deriveSolanaSenderFromEthAddress$1(attestationMeta.ethAddress, rewardManagerProgramId, rewardManagerAccount);

          case 3:
            derivedSender = _context2.sent;
            ///   Submit attestations
            ///   0. `[writable]` Verified messages - New or existing account PDA storing verified messages
            ///   1. `[]` Reward manager
            ///   2. `[]` Reward manager authority
            ///   3. `[signer]` Funder
            ///   4. `[]` Sender
            ///   5. `[]` Sysvar rent
            ///   6. `[]` Instruction info
            ///   7. `[]` System program id
            verifyInstructionAccounts = [{
              pubkey: derivedMessageAccount,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: rewardManagerAccount,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: rewardManagerAuthority,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: feePayer,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: derivedSender,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SystemProgram.programId,
              isSigner: false,
              isWritable: false
            }];
            instructionData = new SubmitAttestationInstructionData({
              transferId: transferId
            });
            serializedInstructionData = borsh.serialize(submitAttestationInstructionSchema, instructionData);
            serializedInstructionEnum = Buffer.from(Uint8Array.of.apply(Uint8Array, [SUBMIT_INSTRUCTION_ENUM_VALUE].concat(_toConsumableArray(serializedInstructionData))));
            return _context2.abrupt("return", new TransactionInstruction({
              keys: verifyInstructionAccounts,
              programId: rewardManagerProgramId,
              data: serializedInstructionEnum
            }));

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function generateSubmitAttestationInstruction(_x4) {
    return _ref9.apply(this, arguments);
  };
}();
/**
 * Encodes a given signature to a 64 byte array for SECP recovery
 * @param {string} signature
 * @returns {{encodedSignature: string, recoveryId: number}} encodedSignature
 */


var encodeSignature = function encodeSignature(signature) {
  // Perform signature manipulations:
  // - remove the 0x prefix for BN
  // - lose the final byte / recovery ID: the secp instruction constructor
  //   requires only 'r', 's' from the signature, while 'v', the recovery ID,
  //   is passed as a separate argument.
  //   https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7
  //
  var strippedSignature = signature.replace('0x', '');
  var recoveryIdStr = strippedSignature.slice(strippedSignature.length - 2);
  var recoveryId = new BN$2(recoveryIdStr, 'hex').toNumber();
  strippedSignature = strippedSignature.slice(0, strippedSignature.length - 2); // Pad to 64 bytes - otherwise, signatures starting with '0' would result
  // in < 64 byte arrays

  var encodedSignature = Uint8Array.of.apply(Uint8Array, _toConsumableArray(new BN$2(strippedSignature, 'hex').toArray('be', 64)));
  return {
    encodedSignature: encodedSignature,
    recoveryId: recoveryId
  };
};
/**
 *
 * @param {{
 *   attestationMeta: AttestationMeta
 *   recipientEthAddress: string
 *   tokenAmount: BN
 *   transferId: string
 *   instructionIndex: number
 *   encodedSenderMessage: string
 * }} {
 *   attestationMeta,
 *   recipientEthAddress,
 *   tokenAmount,
 *   transferId,
 *   instructionIndex,
 *   encodedSenderMessage
 * }
 * @returns {TransactionInstruction}
 */


var generateAttestationSecpInstruction = function generateAttestationSecpInstruction(_ref10) {
  var attestationMeta = _ref10.attestationMeta;
      _ref10.recipientEthAddress;
      _ref10.tokenAmount;
      _ref10.transferId;
      var instructionIndex = _ref10.instructionIndex,
      encodedSenderMessage = _ref10.encodedSenderMessage;

  var _encodeSignature = encodeSignature(attestationMeta.signature),
      encodedSignature = _encodeSignature.encodedSignature,
      recoveryId = _encodeSignature.recoveryId;

  return Secp256k1Program.createInstructionWithEthAddress({
    ethAddress: SolanaUtils$2.ethAddressToArray(attestationMeta.ethAddress),
    message: encodedSenderMessage,
    signature: encodedSignature,
    recoveryId: recoveryId,
    instructionIndex: instructionIndex
  });
};
/**
 *
 * @param {{
 *   ethAddress: string
 *   attestationMeta: AttestationMeta
 *   instructionIndex: number
 *   encodedSenderMessage: string
 * }} {
 *   ethAddress,
 *   attestationMeta,
 *   instructionIndex,
 *   encodedSenderMessage
 * }
 * @returns {TransactionInstruction}
 */


var generateCreateSenderSecpInstruction = function generateCreateSenderSecpInstruction(_ref11) {
  _ref11.ethAddress;
      var attestationMeta = _ref11.attestationMeta,
      instructionIndex = _ref11.instructionIndex,
      encodedSenderMessage = _ref11.encodedSenderMessage;

  var _encodeSignature2 = encodeSignature(attestationMeta.signature),
      encodedSignature = _encodeSignature2.encodedSignature,
      recoveryId = _encodeSignature2.recoveryId;

  return Secp256k1Program.createInstructionWithEthAddress({
    ethAddress: attestationMeta.ethAddress,
    message: encodedSenderMessage,
    signature: encodedSignature,
    recoveryId: recoveryId,
    instructionIndex: instructionIndex
  });
};
/**
 *
 * Helper function generate a create sender instruction.
 * @param {{
 *   senderEthAddress: string,
 *   operatorEthAddress: string,
 *   rewardManagerAccount: PublicKey,
 *   rewardManagerAuthority: PublicKey,
 *   rewardManagerProgramId: PublicKey,
 *   feePayer: PublicKey,
 *   signerEthAddresses: string[]
 * }} {
 *   senderEthAddress,
 *   operatorEthAddress,
 *   rewardManagerAccount,
 *   rewardManagerAuthority,
 *   rewardManagerProgramId,
 *   feePayer,
 *   signerEthAddresses
 * }
 * @returns {TransactionInstruction}
 */


var generateCreateSenderInstruction = /*#__PURE__*/function () {
  var _ref13 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref12) {
    var senderEthAddress, operatorEthAddress, rewardManagerAccount, rewardManagerAuthority, rewardManagerProgramId, feePayer, signerEthAddresses, derivedSenderSolanaAddress, signerSolanaPubKeys, createSenderInstructionAccounts, createSenderPublicInstructionData, serializedInstructionData, serializedInstructionEnum;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            senderEthAddress = _ref12.senderEthAddress, operatorEthAddress = _ref12.operatorEthAddress, rewardManagerAccount = _ref12.rewardManagerAccount, rewardManagerAuthority = _ref12.rewardManagerAuthority, rewardManagerProgramId = _ref12.rewardManagerProgramId, feePayer = _ref12.feePayer, signerEthAddresses = _ref12.signerEthAddresses;
            _context4.next = 3;
            return deriveSolanaSenderFromEthAddress$1(senderEthAddress, rewardManagerProgramId, rewardManagerAccount);

          case 3:
            derivedSenderSolanaAddress = _context4.sent;
            _context4.next = 6;
            return Promise.all(signerEthAddresses.map( /*#__PURE__*/function () {
              var _ref14 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(signerEthAddress) {
                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        return _context3.abrupt("return", deriveSolanaSenderFromEthAddress$1(signerEthAddress, rewardManagerProgramId, rewardManagerAccount));

                      case 1:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x6) {
                return _ref14.apply(this, arguments);
              };
            }()));

          case 6:
            signerSolanaPubKeys = _context4.sent;
            /// 0. `[]` Reward manager
            /// 1. `[]` Reward manager authority
            /// 2. `[signer]` Funder
            /// 3. `[writable]` new_sender
            /// 4. `[]` Bunch of senders which prove creating another one
            createSenderInstructionAccounts = [{
              pubkey: rewardManagerAccount,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: rewardManagerAuthority,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: feePayer,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: derivedSenderSolanaAddress,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SystemProgram.programId,
              isSigner: false,
              isWritable: false
            }].concat(_toConsumableArray(signerSolanaPubKeys.map(function (pubkey) {
              return {
                pubkey: pubkey,
                isSigner: false,
                isWritable: false
              };
            })));
            createSenderPublicInstructionData = new CreateSenderPublicInstructionData({
              ethAddress: SolanaUtils$2.ethAddressToArray(senderEthAddress),
              operator: SolanaUtils$2.ethAddressToArray(operatorEthAddress)
            });
            serializedInstructionData = borsh.serialize(createSenderPublicInstructionSchema, createSenderPublicInstructionData);
            serializedInstructionEnum = Buffer.from(Uint8Array.of.apply(Uint8Array, [CREATE_SENDER_PUBLIC_ENUM_VALUE].concat(_toConsumableArray(serializedInstructionData))));
            return _context4.abrupt("return", new TransactionInstruction({
              keys: createSenderInstructionAccounts,
              programId: rewardManagerProgramId,
              data: serializedInstructionEnum
            }));

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function generateCreateSenderInstruction(_x5) {
    return _ref13.apply(this, arguments);
  };
}(); // Misc

/**
 * Derives the Solana account associated with a given sender Eth address.
 *
 * @param {string} ethAddress
 * @param {PublicKey} rewardManagerProgramId
 * @param {PublicKey} rewardManagerAccount
 * @returns {Promise<PublicKey>}
 */


var deriveSolanaSenderFromEthAddress$1 = /*#__PURE__*/function () {
  var _ref15 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(ethAddress, rewardManagerProgramId, rewardManagerAccount) {
    var ethAddressArr, encodedPrefix, _yield$SolanaUtils$fi, _yield$SolanaUtils$fi2, derivedSender;

    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            ethAddressArr = SolanaUtils$2.ethAddressToArray(ethAddress);
            encodedPrefix = encoder.encode(SENDER_SEED_PREFIX);
            _context5.next = 4;
            return SolanaUtils$2.findProgramAddressWithAuthority(rewardManagerProgramId, rewardManagerAccount, new Uint8Array([].concat(_toConsumableArray(encodedPrefix), _toConsumableArray(ethAddressArr))));

          case 4:
            _yield$SolanaUtils$fi = _context5.sent;
            _yield$SolanaUtils$fi2 = _slicedToArray(_yield$SolanaUtils$fi, 2);
            derivedSender = _yield$SolanaUtils$fi2[1];
            return _context5.abrupt("return", derivedSender);

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function deriveSolanaSenderFromEthAddress(_x7, _x8, _x9) {
    return _ref15.apply(this, arguments);
  };
}();
/**
 * Constructs a create signer message for an existing "signer" eth address
 * @param {string} ethAddress
 * @returns {Uint8Array}
 */


var constructCreateSenderMessage = function constructCreateSenderMessage(ethAddress, rewardManagerAccount) {
  var encodedPrefix = encoder.encode(ADD_SENDER_MESSAGE_PREFIX);
  var ethAddressArr = SolanaUtils$2.ethAddressToArray(ethAddress);
  var rewardManagerAccountArr = rewardManagerAccount.toBytes();
  var items = [encodedPrefix, rewardManagerAccountArr, ethAddressArr];
  var res = items.slice(1).reduce(function (prev, cur, i) {
    return Uint8Array.of.apply(Uint8Array, _toConsumableArray(prev).concat(_toConsumableArray(cur)));
  }, Uint8Array.from(items[0]));
  return res;
};
/**
 * Derives the 'transfer account' - the account which represents a single successful disbursement
 * and is used to dedupe - from the transferId and other info
 *
 * @param {string} transferId
 * @param {PublicKey} rewardProgramId
 * @param {PublicKey} rewardManager
 * @returns {Promise<PublicKey>}
 */


var deriveTransferAccount = /*#__PURE__*/function () {
  var _ref16 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(transferId, rewardProgramId, rewardManager) {
    var seed, _yield$SolanaUtils$fi3, _yield$SolanaUtils$fi4, derivedAddress;

    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            seed = Uint8Array.from([].concat(_toConsumableArray(encoder.encode(TRANSFER_PREFIX)), _toConsumableArray(encoder.encode(transferId))));
            _context6.next = 3;
            return SolanaUtils$2.findProgramAddressWithAuthority(rewardProgramId, rewardManager, seed);

          case 3:
            _yield$SolanaUtils$fi3 = _context6.sent;
            _yield$SolanaUtils$fi4 = _slicedToArray(_yield$SolanaUtils$fi3, 2);
            derivedAddress = _yield$SolanaUtils$fi4[1];
            return _context6.abrupt("return", derivedAddress);

          case 7:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function deriveTransferAccount(_x10, _x11, _x12) {
    return _ref16.apply(this, arguments);
  };
}();
/**
 * Derives the account to store messages for a single challenge
 *
 * @param {string} transferId
 * @param {PublicKey} rewardsProgramId
 * @param {PublicKey} rewardManager
 * @returns {Promise<[PublicKey, PublicKey, number]>}
 */


var deriveMessageAccount = /*#__PURE__*/function () {
  var _ref17 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(transferId, rewardsProgramId, rewardManager) {
    var encodedPrefix, encodedTransferId, seeds;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            encodedPrefix = encoder.encode(VERIFY_TRANSFER_SEED_PREFIX);
            encodedTransferId = encoder.encode(transferId);
            seeds = Uint8Array.from([].concat(_toConsumableArray(encodedPrefix), _toConsumableArray(encodedTransferId)));
            return _context7.abrupt("return", SolanaUtils$2.findProgramAddressWithAuthority(rewardsProgramId, rewardManager, seeds));

          case 4:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function deriveMessageAccount(_x13, _x14, _x15) {
    return _ref17.apply(this, arguments);
  };
}();

var rewards$1 = {
  submitAttestations: submitAttestations$1,
  evaluateAttestations: evaluateAttestations$1,
  createSender: createSender,
  deriveSolanaSenderFromEthAddress: deriveSolanaSenderFromEthAddress$1
};

var solanaWeb3 = require$$1__default["default"];
var splToken = require$$0__default$1["default"];
var anchor = anchor__default["default"];
var idl = AudiusData__default["default"].idl;
var transferWAudioBalance = transfer.transferWAudioBalance;
var getBankAccountAddress = userBank.getBankAccountAddress,
    createUserBankFrom = userBank.createUserBankFrom;
var _createAssociatedTokenAccount = tokenAccount.createAssociatedTokenAccount,
    _getAssociatedTokenAccountInfo = tokenAccount.getAssociatedTokenAccountInfo,
    _findAssociatedTokenAddress = tokenAccount.findAssociatedTokenAddress;
var wAudioFromWeiAudio$1 = wAudio.wAudioFromWeiAudio;
var Utils$a = require$$18.Utils;
var SolanaUtils$1 = utils;
var TransactionHandler = transactionHandler.TransactionHandler;
var submitAttestations = rewards$1.submitAttestations,
    evaluateAttestations = rewards$1.evaluateAttestations,
    _createSender = rewards$1.createSender,
    deriveSolanaSenderFromEthAddress = rewards$1.deriveSolanaSenderFromEthAddress;
var AUDIO_DECMIALS = require$$5.AUDIO_DECMIALS,
    WAUDIO_DECMIALS$1 = require$$5.WAUDIO_DECMIALS;
var PublicKey$1 = solanaWeb3.PublicKey; // Somewhat arbitrary close-to-zero number of Sol. For context, creating a UserBank costs ~0.002 SOL.
// Without this padding, we could reach some low non-zero number of SOL where transactions would fail
// despite a remaining balance.

var ZERO_SOL_EPSILON = 0.005;
var SOL_PER_LAMPORT = 0.000000001; // Generous default connection confirmation timeout to better cope with RPC congestion

var DEFAULT_CONNECTION_CONFIRMATION_TIMEOUT_MS = 180 * 1000;
/**
 * @typedef {import("./rewards.js").AttestationMeta} AttestationMeta
 */

/**
 * SolanaWeb3Manager acts as the interface to solana contracts from a client.
 * It wraps methods to create and lookup user banks, transfer balances, and
 * interact with the @solana/web3 library.
 *
 * Note: Callers of this class should specify all $AUDIO amounts in units of wei.
 * The internals of this class should handle the conversion from wei AUDIO to wormhole
 * $AUDIO amounts.
 */

var SolanaWeb3Manager = /*#__PURE__*/function () {
  /**
   * @param {Object} solanaWeb3Config
   * @param {string} solanaWeb3Config.solanaClusterEndpoint
   *  the solana cluster RPC endpoint
   * @param {string} solanaWeb3Config.mintAddress
   *  address for the wAudio mint - Audius (Wormhole) token
   * @param {string} solanaWeb3Config.solanaTokenAddress
   *  the SPL token program address
   * @param {string} solanaWeb3Config.claimableTokenPDA
   *  the program derived address for the claimable token program (using the mint)
   * @param {string} solanaWeb3Config.feePayerAddress
   *  the address for the specific fee payer to be used in relayed transactions
   * @param {string} solanaWeb3Config.claimableTokenProgramAddress
   *  the address for the claimable token program used to create banks and transfer wAudio
   * @param {string} solanaWeb3Config.rewardsManagerProgramId
   *  the ID of the rewards manager program
   * @param {string} solanaWeb3Config.rewardsManagerProgramPDA
   *  the manager account of the rewards manager program
   * @param {string} solanaWeb3Config.rewardsManagerTokenPDA
   *  the token holder account of the rewards manager program
   * @param {boolean} solanaWeb3Config.useRelay
   *  whether to submit transactions via a relay, or locally
   * @param {KeyPair} solanaWeb3Config.feePayerKepairs
   *  KeyPairs for feepayers
   * @param {number} [solanaWeb3Config.confirmationTimeout] optional default confirmation timeout
   * @param {PublicKey} [solanaWeb3Config.audiusDataProgramId]
   *  Program ID for audius-data anchor program
   * @param {PublicKey} [solanaWeb3Config.audiusDataAdminStorageKeypairPublicKey]
   *  PK for audius-data admin storage keypair
   * @param {anchor.Idl} [solanaWeb3Config.audiusDataIdl]
   *  IDL for audius-data program
   * @param {IdentityService} identityService
   * @param {Web3Manager} web3Manager
   */
  function SolanaWeb3Manager(solanaWeb3Config, identityService, web3Manager) {
    _classCallCheck(this, SolanaWeb3Manager);

    this.solanaWeb3Config = solanaWeb3Config;
    this.identityService = identityService;
    this.web3Manager = web3Manager;
    this.solanaWeb3 = solanaWeb3;
    this.splToken = splToken;
  }

  _createClass(SolanaWeb3Manager, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this$solanaWeb3Confi, solanaClusterEndpoint, mintAddress, solanaTokenAddress, claimableTokenPDA, feePayerAddress, claimableTokenProgramAddress, rewardsManagerProgramId, rewardsManagerProgramPDA, rewardsManagerTokenPDA, useRelay, feePayerKeypairs, confirmationTimeout, audiusDataProgramId, audiusDataAdminStorageKeypairPublicKey, audiusDataIdl, connection, anchorProvider;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this$solanaWeb3Confi = this.solanaWeb3Config, solanaClusterEndpoint = _this$solanaWeb3Confi.solanaClusterEndpoint, mintAddress = _this$solanaWeb3Confi.mintAddress, solanaTokenAddress = _this$solanaWeb3Confi.solanaTokenAddress, claimableTokenPDA = _this$solanaWeb3Confi.claimableTokenPDA, feePayerAddress = _this$solanaWeb3Confi.feePayerAddress, claimableTokenProgramAddress = _this$solanaWeb3Confi.claimableTokenProgramAddress, rewardsManagerProgramId = _this$solanaWeb3Confi.rewardsManagerProgramId, rewardsManagerProgramPDA = _this$solanaWeb3Confi.rewardsManagerProgramPDA, rewardsManagerTokenPDA = _this$solanaWeb3Confi.rewardsManagerTokenPDA, useRelay = _this$solanaWeb3Confi.useRelay, feePayerKeypairs = _this$solanaWeb3Confi.feePayerKeypairs, confirmationTimeout = _this$solanaWeb3Confi.confirmationTimeout, audiusDataProgramId = _this$solanaWeb3Confi.audiusDataProgramId, audiusDataAdminStorageKeypairPublicKey = _this$solanaWeb3Confi.audiusDataAdminStorageKeypairPublicKey, audiusDataIdl = _this$solanaWeb3Confi.audiusDataIdl;
                this.solanaClusterEndpoint = solanaClusterEndpoint;
                this.connection = new solanaWeb3.Connection(this.solanaClusterEndpoint, {
                  confirmTransactionInitialTimeout: confirmationTimeout || DEFAULT_CONNECTION_CONFIRMATION_TIMEOUT_MS
                });
                this.transactionHandler = new TransactionHandler({
                  connection: this.connection,
                  useRelay: useRelay,
                  identityService: this.identityService,
                  feePayerKeypairs: feePayerKeypairs
                });
                this.mintAddress = mintAddress;
                this.mintKey = SolanaUtils$1.newPublicKeyNullable(mintAddress);
                this.solanaTokenAddress = solanaTokenAddress;
                this.solanaTokenKey = SolanaUtils$1.newPublicKeyNullable(solanaTokenAddress);

                if (feePayerAddress) {
                  this.feePayerAddress = feePayerAddress;
                  this.feePayerKey = SolanaUtils$1.newPublicKeyNullable(feePayerAddress);
                } else if (feePayerKeypairs && feePayerKeypairs.length) {
                  this.feePayerAddress = feePayerKeypairs[0].publicKey;
                  this.feePayerKey = SolanaUtils$1.newPublicKeyNullable(feePayerKeypairs[0].publicKey);
                }

                this.claimableTokenProgramKey = SolanaUtils$1.newPublicKeyNullable(claimableTokenProgramAddress);
                _context.t0 = claimableTokenPDA;

                if (_context.t0) {
                  _context.next = 20;
                  break;
                }

                if (!this.claimableTokenProgramKey) {
                  _context.next = 18;
                  break;
                }

                _context.next = 15;
                return SolanaUtils$1.findProgramAddressFromPubkey(this.claimableTokenProgramKey, this.mintKey);

              case 15:
                _context.t1 = _context.sent[0].toString();
                _context.next = 19;
                break;

              case 18:
                _context.t1 = null;

              case 19:
                _context.t0 = _context.t1;

              case 20:
                this.claimableTokenPDA = _context.t0;
                this.claimableTokenPDAKey = SolanaUtils$1.newPublicKeyNullable(this.claimableTokenPDA);
                this.rewardManagerProgramId = SolanaUtils$1.newPublicKeyNullable(rewardsManagerProgramId);
                this.rewardManagerProgramPDA = SolanaUtils$1.newPublicKeyNullable(rewardsManagerProgramPDA);
                this.rewardManagerTokenPDA = SolanaUtils$1.newPublicKeyNullable(rewardsManagerTokenPDA);
                this.audiusDataProgramId = audiusDataProgramId;
                this.audiusDataAdminStorageKeypairPublicKey = audiusDataAdminStorageKeypairPublicKey;
                this.audiusDataIdl = audiusDataIdl || idl;

                if (this.audiusDataProgramId && this.audiusDataAdminStorageKeypairPublicKey && this.audiusDataIdl) {
                  connection = new solanaWeb3.Connection(this.solanaClusterEndpoint, anchor.AnchorProvider.defaultOptions());
                  anchorProvider = new anchor.AnchorProvider(connection, solanaWeb3.Keypair.generate(), anchor.AnchorProvider.defaultOptions());
                  this.anchorProgram = new anchor.Program(this.audiusDataIdl, audiusDataProgramId, anchorProvider);
                }

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
    /**
     * Creates a solana bank account from the web3 provider's eth address
     */

  }, {
    key: "createUserBank",
    value: function () {
      var _createUserBank = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(feePayerOverride) {
        var ethAddress;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.web3Manager) {
                  _context2.next = 2;
                  break;
                }

                throw new Error('A web3Manager is required for this solanaWeb3Manager method');

              case 2:
                ethAddress = this.web3Manager.getWalletAddress();
                return _context2.abrupt("return", createUserBankFrom({
                  ethAddress: ethAddress,
                  claimableTokenPDAKey: this.claimableTokenPDAKey,
                  feePayerKey: SolanaUtils$1.newPublicKeyNullable(feePayerOverride) || this.feePayerKey,
                  mintKey: this.mintKey,
                  solanaTokenProgramKey: this.solanaTokenKey,
                  claimableTokenProgramKey: this.claimableTokenProgramKey,
                  connection: this.connection,
                  transactionHandler: this.transactionHandler
                }));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function createUserBank(_x) {
        return _createUserBank.apply(this, arguments);
      }

      return createUserBank;
    }()
    /**
     * Creates a token account for the provided solana address (a wallet)
     * See https://spl.solana.com/associated-token-account
     * @param {string} solanaAddress
     */

  }, {
    key: "createAssociatedTokenAccount",
    value: function () {
      var _createAssociatedTokenAccount2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(solanaAddress) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _createAssociatedTokenAccount({
                  feePayerKey: this.feePayerKey,
                  solanaWalletKey: new PublicKey$1(solanaAddress),
                  mintKey: this.mintKey,
                  solanaTokenProgramKey: this.solanaTokenKey,
                  connection: this.connection,
                  identityService: this.identityService
                });

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function createAssociatedTokenAccount(_x2) {
        return _createAssociatedTokenAccount2.apply(this, arguments);
      }

      return createAssociatedTokenAccount;
    }()
    /**
     * Finds the wAudio token account for a provided solana address (a wallet)
     * See https://spl.solana.com/associated-token-account
     * @param {string} solanaAddress
     */

  }, {
    key: "findAssociatedTokenAddress",
    value: function () {
      var _findAssociatedTokenAddress2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(solanaAddress) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", _findAssociatedTokenAddress({
                  solanaWalletKey: new PublicKey$1(solanaAddress),
                  mintKey: this.mintKey,
                  solanaTokenProgramKey: this.solanaTokenKey
                }));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function findAssociatedTokenAddress(_x3) {
        return _findAssociatedTokenAddress2.apply(this, arguments);
      }

      return findAssociatedTokenAddress;
    }()
    /**
     * Gets a solana bank account from the current we3 provider's eth address
     * @returns {PublicKey} UserBank
     */

  }, {
    key: "getUserBank",
    value: function () {
      var _getUserBank = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var ethAddress, bank;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (this.web3Manager) {
                  _context5.next = 2;
                  break;
                }

                throw new Error('A web3Manager is required for this solanaWeb3Manager method');

              case 2:
                ethAddress = this.web3Manager.getWalletAddress();
                _context5.next = 5;
                return getBankAccountAddress(ethAddress, this.claimableTokenPDAKey, this.solanaTokenKey);

              case 5:
                bank = _context5.sent;
                return _context5.abrupt("return", bank);

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getUserBank() {
        return _getUserBank.apply(this, arguments);
      }

      return getUserBank;
    }()
    /**
     * Gets the info for a user bank/wAudio token account given a solana address.
     * If the solanaAddress is not a valid token account, returns `null`
     * @returns {AccountInfo | null}
     */

  }, {
    key: "getAssociatedTokenAccountInfo",
    value: function () {
      var _getAssociatedTokenAccountInfo2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(solanaAddress) {
        var res;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;
                _context6.next = 3;
                return _getAssociatedTokenAccountInfo({
                  tokenAccountAddressKey: new PublicKey$1(solanaAddress),
                  mintKey: this.mintKey,
                  solanaTokenProgramKey: this.solanaTokenKey,
                  connection: this.connection
                });

              case 3:
                res = _context6.sent;
                return _context6.abrupt("return", res);

              case 7:
                _context6.prev = 7;
                _context6.t0 = _context6["catch"](0);
                return _context6.abrupt("return", null);

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[0, 7]]);
      }));

      function getAssociatedTokenAccountInfo(_x4) {
        return _getAssociatedTokenAccountInfo2.apply(this, arguments);
      }

      return getAssociatedTokenAccountInfo;
    }()
    /**
     * Gets the SPL waudio balance for a solana address in wei with 18 decimals
     * @returns {BN | null}
     */

  }, {
    key: "getWAudioBalance",
    value: function () {
      var _getWAudioBalance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(solanaAddress) {
        var tokenAccount, associatedTokenAccount, decimals;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.prev = 0;
                _context7.next = 3;
                return this.getAssociatedTokenAccountInfo(solanaAddress);

              case 3:
                tokenAccount = _context7.sent;

                if (tokenAccount) {
                  _context7.next = 13;
                  break;
                }

                _context7.next = 7;
                return this.findAssociatedTokenAddress(solanaAddress);

              case 7:
                associatedTokenAccount = _context7.sent;
                _context7.next = 10;
                return this.getAssociatedTokenAccountInfo(associatedTokenAccount.toString());

              case 10:
                tokenAccount = _context7.sent;

                if (tokenAccount) {
                  _context7.next = 13;
                  break;
                }

                return _context7.abrupt("return", null);

              case 13:
                // Multiply by 10^10 to maintain same decimals as eth $AUDIO
                decimals = AUDIO_DECMIALS - WAUDIO_DECMIALS$1;
                return _context7.abrupt("return", tokenAccount.amount.mul(Utils$a.toBN('1'.padEnd(decimals + 1, '0'))));

              case 17:
                _context7.prev = 17;
                _context7.t0 = _context7["catch"](0);
                return _context7.abrupt("return", null);

              case 20:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[0, 17]]);
      }));

      function getWAudioBalance(_x5) {
        return _getWAudioBalance.apply(this, arguments);
      }

      return getWAudioBalance;
    }()
    /**
     * Transfers audio from the web3 provider's eth address
     * @param {string} recipientSolanaAddress
     *  Recipient solana address which is either a user bank, wAudio token account,
     *  or a solana account. In the last case, an associated token account is created
     *  if one does not already exist for the solana account
     * @param {BN} amount the amount of $AUDIO to send in wei units of $AUDIO.
     * **IMPORTANT NOTE**
     * wAudio (Solana) does not support 10^-18 (wei) units of $AUDIO. The smallest
     * demarcation on that side is 10^-8, so the $AUDIO amount must be >= 10^8 and have no
     * remainder after a division with 10^8 or this method will throw.
     *
     * Generally speaking, callers into the solanaWeb3Manager should use BN.js representation
     * of wei $AUDIO for all method calls
     */

  }, {
    key: "transferWAudio",
    value: function () {
      var _transferWAudio = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(recipientSolanaAddress, amount) {
        var tokenAccountInfo, associatedTokenAccount, wAudioAmount, ethAddress, senderSolanaAddress;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (this.web3Manager) {
                  _context8.next = 2;
                  break;
                }

                throw new Error('A web3Manager is required for this solanaWeb3Manager method');

              case 2:
                _context8.next = 4;
                return this.getAssociatedTokenAccountInfo(recipientSolanaAddress);

              case 4:
                tokenAccountInfo = _context8.sent;

                if (tokenAccountInfo) {
                  _context8.next = 18;
                  break;
                }

                console.info('Provided recipient solana address was not a token account'); // If not, check to see if it already has an associated token account.

                _context8.next = 9;
                return this.findAssociatedTokenAddress(recipientSolanaAddress);

              case 9:
                associatedTokenAccount = _context8.sent;
                _context8.next = 12;
                return this.getAssociatedTokenAccountInfo(associatedTokenAccount.toString());

              case 12:
                tokenAccountInfo = _context8.sent;

                if (tokenAccountInfo) {
                  _context8.next = 17;
                  break;
                }

                console.info('Provided recipient solana address has no associated token account, creating');
                _context8.next = 17;
                return this.createAssociatedTokenAccount(recipientSolanaAddress);

              case 17:
                recipientSolanaAddress = associatedTokenAccount.toString();

              case 18:
                console.info("Transfering ".concat(amount.toString(), " wei $AUDIO to ").concat(recipientSolanaAddress));
                wAudioAmount = wAudioFromWeiAudio$1(amount);
                ethAddress = this.web3Manager.getWalletAddress();
                _context8.next = 23;
                return getBankAccountAddress(ethAddress, this.claimableTokenPDAKey, this.solanaTokenKey);

              case 23:
                senderSolanaAddress = _context8.sent;
                return _context8.abrupt("return", transferWAudioBalance({
                  amount: wAudioAmount,
                  senderEthAddress: ethAddress,
                  feePayerKey: this.feePayerKey,
                  senderEthPrivateKey: this.web3Manager.getOwnerWalletPrivateKey(),
                  senderSolanaAddress: senderSolanaAddress,
                  recipientSolanaAddress: recipientSolanaAddress,
                  claimableTokenPDA: this.claimableTokenPDAKey,
                  solanaTokenProgramKey: this.solanaTokenKey,
                  claimableTokenProgramKey: this.claimableTokenProgramKey,
                  connection: this.connection,
                  mintKey: this.mintKey,
                  transactionHandler: this.transactionHandler
                }));

              case 25:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function transferWAudio(_x6, _x7) {
        return _transferWAudio.apply(this, arguments);
      }

      return transferWAudio;
    }()
    /**
     * Submits attestations for challenge completion to the RewardsManager program on Solana.
     *
     * @param {{
     *     attestations: AttestationMeta[],
     *     oracleAttestation: AttestationMeta,
     *     challengeId: string,
     *     specifier: string,
     *     recipientEthAddress: string,
     *     tokenAmount: BN,
     *     instructionsPerTransaction?: number,
     *     logger: any
     *     feePayerOverride: string | null
     * }} {
     *     attestations,
     *     oracleAttestation,
     *     challengeId,
     *     specifier,
     *     recipientEthAddress,
     *     tokenAmount,
     *     instructionsPerTransaction,
     *     logger
     *     feePayerOverride
     *    }
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "submitChallengeAttestations",
    value: function () {
      var _submitChallengeAttestations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_ref) {
        var attestations, oracleAttestation, challengeId, specifier, recipientEthAddress, tokenAmount, instructionsPerTransaction, _ref$logger, logger, _ref$feePayerOverride, feePayerOverride;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                attestations = _ref.attestations, oracleAttestation = _ref.oracleAttestation, challengeId = _ref.challengeId, specifier = _ref.specifier, recipientEthAddress = _ref.recipientEthAddress, tokenAmount = _ref.tokenAmount, instructionsPerTransaction = _ref.instructionsPerTransaction, _ref$logger = _ref.logger, logger = _ref$logger === void 0 ? console : _ref$logger, _ref$feePayerOverride = _ref.feePayerOverride, feePayerOverride = _ref$feePayerOverride === void 0 ? null : _ref$feePayerOverride;
                return _context9.abrupt("return", submitAttestations({
                  rewardManagerProgramId: this.rewardManagerProgramId,
                  rewardManagerAccount: this.rewardManagerProgramPDA,
                  attestations: attestations,
                  oracleAttestation: oracleAttestation,
                  challengeId: challengeId,
                  specifier: specifier,
                  feePayer: SolanaUtils$1.newPublicKeyNullable(feePayerOverride) || this.feePayerKey,
                  recipientEthAddress: recipientEthAddress,
                  tokenAmount: tokenAmount,
                  transactionHandler: this.transactionHandler,
                  instructionsPerTransaction: instructionsPerTransaction,
                  logger: logger
                }));

              case 2:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function submitChallengeAttestations(_x8) {
        return _submitChallengeAttestations.apply(this, arguments);
      }

      return submitChallengeAttestations;
    }()
    /**
     * Evaluates existing submitted attestations, disbursing if successful.
     *
     * @param {{
     *    challengeId: string,
     *    specifier: string,
     *    recipientEthAddress: string
     *    oracleEthAddress: string
     *    logger: any
     *    feePayerOverride: string | null
     * }} {
     *     challengeId,
     *     specifier,
     *     recipientEthAddress,
     *     oracleEthAddress,
     *     tokenAmount,
     *     logger
     *     feePayerOverride
     *   }
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "evaluateChallengeAttestations",
    value: function () {
      var _evaluateChallengeAttestations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(_ref2) {
        var challengeId, specifier, recipientEthAddress, oracleEthAddress, tokenAmount, _ref2$logger, logger, _ref2$feePayerOverrid, feePayerOverride;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                challengeId = _ref2.challengeId, specifier = _ref2.specifier, recipientEthAddress = _ref2.recipientEthAddress, oracleEthAddress = _ref2.oracleEthAddress, tokenAmount = _ref2.tokenAmount, _ref2$logger = _ref2.logger, logger = _ref2$logger === void 0 ? console : _ref2$logger, _ref2$feePayerOverrid = _ref2.feePayerOverride, feePayerOverride = _ref2$feePayerOverrid === void 0 ? null : _ref2$feePayerOverrid;
                return _context10.abrupt("return", evaluateAttestations({
                  rewardManagerProgramId: this.rewardManagerProgramId,
                  rewardManagerAccount: this.rewardManagerProgramPDA,
                  rewardManagerTokenSource: this.rewardManagerTokenPDA,
                  challengeId: challengeId,
                  specifier: specifier,
                  recipientEthAddress: recipientEthAddress,
                  userBankProgramAccount: this.claimableTokenPDAKey,
                  oracleEthAddress: oracleEthAddress,
                  feePayer: SolanaUtils$1.newPublicKeyNullable(feePayerOverride) || this.feePayerKey,
                  tokenAmount: tokenAmount,
                  transactionHandler: this.transactionHandler,
                  logger: logger
                }));

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function evaluateChallengeAttestations(_x9) {
        return _evaluateChallengeAttestations.apply(this, arguments);
      }

      return evaluateChallengeAttestations;
    }()
    /**
     * Creates a new rewards signer (one that can attest)
     * @param {{
     *   senderEthAddress: string,
     *   operatorEthAddress: string,
     *   attestations: AttestationMeta[],
     *   feePayerOverride?: string
     * }} {
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "createSender",
    value: function () {
      var _createSender2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(_ref3) {
        var senderEthAddress, operatorEthAddress, attestations, _ref3$feePayerOverrid, feePayerOverride;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                senderEthAddress = _ref3.senderEthAddress, operatorEthAddress = _ref3.operatorEthAddress, attestations = _ref3.attestations, _ref3$feePayerOverrid = _ref3.feePayerOverride, feePayerOverride = _ref3$feePayerOverrid === void 0 ? null : _ref3$feePayerOverrid;
                return _context11.abrupt("return", _createSender({
                  rewardManagerProgramId: this.rewardManagerProgramId,
                  rewardManagerAccount: this.rewardManagerProgramPDA,
                  senderEthAddress: senderEthAddress,
                  feePayer: SolanaUtils$1.newPublicKeyNullable(feePayerOverride) || this.feePayerKey,
                  operatorEthAddress: operatorEthAddress,
                  attestations: attestations,
                  identityService: this.identityService,
                  connection: this.connection,
                  transactionHandler: this.transactionHandler
                }));

              case 2:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function createSender(_x10) {
        return _createSender2.apply(this, arguments);
      }

      return createSender;
    }()
    /**
     * Gets the balance of a PublicKey, in SOL
     *
     * @param {{
     *  publicKey: PublicKey
     * }} { publicKey }
     * @return {Promise<number>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "getBalance",
    value: function () {
      var _getBalance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(_ref4) {
        var publicKey, lamports;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                publicKey = _ref4.publicKey;
                _context12.next = 3;
                return this.connection.getBalance(publicKey);

              case 3:
                lamports = _context12.sent;
                return _context12.abrupt("return", lamports * SOL_PER_LAMPORT);

              case 5:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getBalance(_x11) {
        return _getBalance.apply(this, arguments);
      }

      return getBalance;
    }()
    /**
     * Gets whether a PublicKey has a usable balance
     *
     * @param {{
     *  publicKey: PublicKey,
     *  epsilon?: number
     * }} { publicKey }
     * @return {Promise<boolean>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "hasBalance",
    value: function () {
      var _hasBalance = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref5) {
        var publicKey, _ref5$epsilon, epsilon, balance;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                publicKey = _ref5.publicKey, _ref5$epsilon = _ref5.epsilon, epsilon = _ref5$epsilon === void 0 ? ZERO_SOL_EPSILON : _ref5$epsilon;
                _context13.next = 3;
                return this.getBalance({
                  publicKey: publicKey
                });

              case 3:
                balance = _context13.sent;
                return _context13.abrupt("return", balance > epsilon);

              case 5:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function hasBalance(_x12) {
        return _hasBalance.apply(this, arguments);
      }

      return hasBalance;
    }()
  }, {
    key: "getSlot",
    value: function () {
      var _getSlot = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                return _context14.abrupt("return", this.connection.getSlot('processed'));

              case 1:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getSlot() {
        return _getSlot.apply(this, arguments);
      }

      return getSlot;
    }()
  }, {
    key: "getRandomFeePayer",
    value: function () {
      var _getRandomFeePayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                return _context15.abrupt("return", this.identityService.getRandomFeePayer());

              case 1:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getRandomFeePayer() {
        return _getRandomFeePayer.apply(this, arguments);
      }

      return getRandomFeePayer;
    }()
    /**
     * Gets whether a given node registered on eth with `senderEthAddress` is registered on Solana
     *
     * @param {string} senderEthAddress
     * @return {Promise<boolean>}
     * @memberof SolanaWeb3Manager
     */

  }, {
    key: "getIsDiscoveryNodeRegistered",
    value: function () {
      var _getIsDiscoveryNodeRegistered = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(senderEthAddress) {
        var derivedSenderSolanaAddress, res;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return deriveSolanaSenderFromEthAddress(senderEthAddress, this.rewardManagerProgramId, this.rewardManagerProgramPDA);

              case 2:
                derivedSenderSolanaAddress = _context16.sent;
                _context16.next = 5;
                return this.connection.getAccountInfo(derivedSenderSolanaAddress);

              case 5:
                res = _context16.sent;
                return _context16.abrupt("return", !!res);

              case 7:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getIsDiscoveryNodeRegistered(_x13) {
        return _getIsDiscoveryNodeRegistered.apply(this, arguments);
      }

      return getIsDiscoveryNodeRegistered;
    }()
  }, {
    key: "findProgramAddress",
    value: function () {
      var _findProgramAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(programId, pubkey) {
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                return _context17.abrupt("return", PublicKey$1.findProgramAddress([pubkey.toBytes().slice(0, 32)], programId));

              case 1:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17);
      }));

      function findProgramAddress(_x14, _x15) {
        return _findProgramAddress.apply(this, arguments);
      }

      return findProgramAddress;
    }()
    /**
     * Finds a 'derived' address by finding a programAddress with
     * seeds array  as first 32 bytes of base + seeds
     * Returns [derivedAddress, bumpSeed]
     * @param {string} programId
     * @param {string} base
     * @param {Buffer | Uint8Array} seed
     * @returns the program address
     */

  }, {
    key: "findDerivedAddress",
    value: function () {
      var _findDerivedAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(programId, base, seed) {
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                return _context18.abrupt("return", PublicKey$1.findProgramAddress([base.toBytes().slice(0, 32), seed], programId));

              case 1:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18);
      }));

      function findDerivedAddress(_x16, _x17, _x18) {
        return _findDerivedAddress.apply(this, arguments);
      }

      return findDerivedAddress;
    }()
    /**
     * Finds the target PDA with the base audius admin as the initial seed
     * In conjunction with the secondary seed as the users id in bytes
     * @param {PublicKey} programId
     * @param {PublicKey} adminAccount
     * @param {Buffer | Uint8Array} seed
     */

  }, {
    key: "findDerivedPair",
    value: function () {
      var _findDerivedPair = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(programId, adminAccount, seed) {
        var _yield$this$findProgr, _yield$this$findProgr2, baseAuthorityAccount, derivedAddressInfo, derivedAddress, bumpSeed;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                programId = SolanaUtils$1.newPublicKeyNullable(programId);
                adminAccount = SolanaUtils$1.newPublicKeyNullable(adminAccount);
                _context19.next = 4;
                return this.findProgramAddress(programId, adminAccount);

              case 4:
                _yield$this$findProgr = _context19.sent;
                _yield$this$findProgr2 = _slicedToArray(_yield$this$findProgr, 1);
                baseAuthorityAccount = _yield$this$findProgr2[0];
                _context19.next = 9;
                return this.findDerivedAddress(programId, baseAuthorityAccount, seed);

              case 9:
                derivedAddressInfo = _context19.sent;
                derivedAddress = derivedAddressInfo[0];
                bumpSeed = derivedAddressInfo[1];
                return _context19.abrupt("return", {
                  baseAuthorityAccount: baseAuthorityAccount,
                  derivedAddress: derivedAddress,
                  bumpSeed: bumpSeed
                });

              case 13:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function findDerivedPair(_x19, _x20, _x21) {
        return _findDerivedPair.apply(this, arguments);
      }

      return findDerivedPair;
    }()
    /**
     * Fetch account on Solana given the program derived address
     * @param {PublicKey} pda the program derived address from findDerivedPair()
     */

  }, {
    key: "fetchAccount",
    value: function () {
      var _fetchAccount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(pda) {
        var account;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.prev = 0;
                _context20.next = 3;
                return this.anchorProgram.account.user.fetch(pda);

              case 3:
                account = _context20.sent;
                return _context20.abrupt("return", account);

              case 7:
                _context20.prev = 7;
                _context20.t0 = _context20["catch"](0);
                return _context20.abrupt("return", null);

              case 10:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this, [[0, 7]]);
      }));

      function fetchAccount(_x22) {
        return _fetchAccount.apply(this, arguments);
      }

      return fetchAccount;
    }()
    /**
     * Given the eth address buffer from the account, convert to hex
     * @param {Buffer} accountEthAddress
     * @returns hex string of input bytes
     */

  }, {
    key: "deriveEthWalletFromAddress",
    value: function () {
      var _deriveEthWalletFromAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(accountEthAddress) {
        var encodedEthAddress;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                encodedEthAddress = Buffer.from(accountEthAddress).toString('hex');

                if (!encodedEthAddress.startsWith('0x')) {
                  encodedEthAddress = '0x' + encodedEthAddress;
                }

                return _context21.abrupt("return", encodedEthAddress);

              case 3:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21);
      }));

      function deriveEthWalletFromAddress(_x23) {
        return _deriveEthWalletFromAddress.apply(this, arguments);
      }

      return deriveEthWalletFromAddress;
    }()
  }]);

  return SolanaWeb3Manager;
}();

var solanaWeb3Manager = SolanaWeb3Manager;

var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(ProviderSelection$2);

var Utils$9 = require$$18.Utils;
var Web3Manager = require$$3.Web3Manager;
var ProviderSelection = require$$2$1.ProviderSelection;

var RegistryClient$1 = /*#__PURE__*/function () {
  function RegistryClient(web3Manager, contractABI, contractAddress) {
    _classCallCheck(this, RegistryClient);

    this.web3Manager = web3Manager;
    this.contractABI = contractABI;
    this.contractAddress = contractAddress;
    var web3 = this.web3Manager.getWeb3();
    this.Registry = new web3.eth.Contract(contractABI, contractAddress);

    if (this.web3Manager instanceof Web3Manager && !this.web3Manager.web3Config.useExternalWeb3) {
      var providerEndpoints = this.web3Manager.web3Config.internalWeb3Config.web3ProviderEndpoints;
      this.providerSelector = new ProviderSelection(providerEndpoints);
    } else {
      this.providerSelector = null;
    }
  }

  _createClass(RegistryClient, [{
    key: "getContract",
    value: function () {
      var _getContract = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(contractRegistryKey) {
        var contract;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                Utils$9.checkStrLen(contractRegistryKey, 32);
                _context.next = 4;
                return this.Registry.methods.getContract(Utils$9.utf8ToHex(contractRegistryKey)).call();

              case 4:
                contract = _context.sent;
                return _context.abrupt("return", contract);

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](0);

                if (this.providerSelector) {
                  _context.next = 13;
                  break;
                }

                console.error("Failed to initialize contract ".concat(JSON.stringify(this.contractABI)), _context.t0);
                return _context.abrupt("return");

              case 13:
                return _context.abrupt("return", this.retryInit(contractRegistryKey));

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 8]]);
      }));

      function getContract(_x) {
        return _getContract.apply(this, arguments);
      }

      return getContract;
    }()
  }, {
    key: "retryInit",
    value: function () {
      var _retryInit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(contractRegistryKey) {
        var web3;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return this.selectNewEndpoint();

              case 3:
                web3 = this.web3Manager.getWeb3();
                this.Registry = new web3.eth.Contract(this.contractABI, this.contractAddress);
                _context2.next = 7;
                return this.getContract(contractRegistryKey);

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 10:
                _context2.prev = 10;
                _context2.t0 = _context2["catch"](0);
                console.error(_context2.t0.message);

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 10]]);
      }));

      function retryInit(_x2) {
        return _retryInit.apply(this, arguments);
      }

      return retryInit;
    }()
  }, {
    key: "selectNewEndpoint",
    value: function () {
      var _selectNewEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.providerSelector.addUnhealthy(this.web3Manager.getWeb3().currentProvider.host);

                if (!(this.providerSelector.getUnhealthySize() === this.providerSelector.getServicesSize())) {
                  _context3.next = 3;
                  break;
                }

                throw new Error("No available, healthy providers to get contract ".concat(JSON.stringify(this.contractABI)));

              case 3:
                _context3.next = 5;
                return this.providerSelector.select(this);

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function selectNewEndpoint() {
        return _selectNewEndpoint.apply(this, arguments);
      }

      return selectNewEndpoint;
    }()
  }]);

  return RegistryClient;
}();

var registryClient = RegistryClient$1;

var require$$0 = /*@__PURE__*/getAugmentedNamespace(ContractClient$8);

/**
 * This file includes schemas for use in EIP-712 compliant signature generation and
 * signature validation, generator functions for generating data
 * in the form needed by eth_personalSign / eth-sig-util's signTypedData functions,
 * generators for contract signing domains, and a helper function for generating
 * cryptographically secure nonces in nodejs or in the browser.
 * modeled off: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md
 */
var domains = {};

function getDomainData(contractName, signatureVersion, chainId, contractAddress) {
  return {
    name: contractName,
    version: signatureVersion,
    chainId: chainId,
    verifyingContract: contractAddress
  };
}

domains.getSocialFeatureFactoryDomain = function (chainId, contractAddress) {
  return getDomainData('Social Feature Factory', '1', chainId, contractAddress);
};

domains.getUserFactoryDomain = function (chainId, contractAddress) {
  return getDomainData('User Factory', '1', chainId, contractAddress);
};

domains.getTrackFactoryDomain = function (chainId, contractAddress) {
  return getDomainData('Track Factory', '1', chainId, contractAddress);
};

domains.getPlaylistFactoryDomain = function (chainId, contractAddress) {
  return getDomainData('Playlist Factory', '1', chainId, contractAddress);
};

domains.getUserLibraryFactoryDomain = function (chainId, contractAddress) {
  return getDomainData('User Library Factory', '1', chainId, contractAddress);
};

domains.getIPLDBlacklistFactoryDomain = function (chainId, contractAddress) {
  return getDomainData('IPLD Blacklist Factory', '1', chainId, contractAddress);
};

domains.getUserReplicaSetManagerDomain = function (chainId, contractAddress) {
  return getDomainData('User Replica Set Manager', '1', chainId, contractAddress);
};

var schemas = {};
/* contract signing domain */

schemas.domain = [{
  name: 'name',
  type: 'string'
}, {
  name: 'version',
  type: 'string'
}, {
  name: 'chainId',
  type: 'uint256'
}, {
  name: 'verifyingContract',
  type: 'address'
}];
/* user factory requests */

schemas.addUserRequest = [{
  name: 'handle',
  type: 'bytes16'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
/* rather than having a schema type for every update op, we have a type for each unique
 * structure */

schemas.updateUserBytes32 = [{
  name: 'userId',
  type: 'uint'
}, {
  name: 'newValue',
  type: 'bytes32'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.updateUserString = [{
  name: 'userId',
  type: 'uint'
}, {
  name: 'newValue',
  type: 'string'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.updateUserBool = [{
  name: 'userId',
  type: 'uint'
}, {
  name: 'newValue',
  type: 'bool'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
/* track factory requests */

schemas.addTrackRequest = [{
  name: 'trackOwnerId',
  type: 'uint'
}, {
  name: 'multihashDigest',
  type: 'bytes32'
}, {
  name: 'multihashHashFn',
  type: 'uint8'
}, {
  name: 'multihashSize',
  type: 'uint8'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.updateTrackRequest = [{
  name: 'trackId',
  type: 'uint'
}, {
  name: 'trackOwnerId',
  type: 'uint'
}, {
  name: 'multihashDigest',
  type: 'bytes32'
}, {
  name: 'multihashHashFn',
  type: 'uint8'
}, {
  name: 'multihashSize',
  type: 'uint8'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.deleteTrackRequest = [{
  name: 'trackId',
  type: 'uint'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
/* social features */

schemas.addTrackRepostRequest = [{
  name: 'userId',
  type: 'uint'
}, {
  name: 'trackId',
  type: 'uint'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.deleteTrackRepostRequest = schemas.addTrackRepostRequest;
schemas.addPlaylistRepostRequest = [{
  name: 'userId',
  type: 'uint'
}, {
  name: 'playlistId',
  type: 'uint'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.deletePlaylistRepostRequest = schemas.addPlaylistRepostRequest;
schemas.userFollowRequest = [{
  name: 'followerUserId',
  type: 'uint'
}, {
  name: 'followeeUserId',
  type: 'uint'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.deleteUserFollowRequest = schemas.userFollowRequest;
schemas.createPlaylistRequest = [{
  name: 'playlistOwnerId',
  type: 'uint'
}, {
  name: 'playlistName',
  type: 'string'
}, {
  name: 'isPrivate',
  type: 'bool'
}, {
  name: 'isAlbum',
  type: 'bool'
}, {
  name: 'trackIdsHash',
  type: 'bytes32'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.deletePlaylistRequest = [{
  name: 'playlistId',
  type: 'uint'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.addPlaylistTrackRequest = [{
  name: 'playlistId',
  type: 'uint'
}, {
  name: 'addedTrackId',
  type: 'uint'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.deletePlaylistTrackRequest = [{
  name: 'playlistId',
  type: 'uint'
}, {
  name: 'deletedTrackId',
  type: 'uint'
}, {
  name: 'deletedTrackTimestamp',
  type: 'uint'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.orderPlaylistTracksRequest = [{
  name: 'playlistId',
  type: 'uint'
}, {
  name: 'trackIdsHash',
  type: 'bytes32'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.updatePlaylistPrivacyRequest = [{
  name: 'playlistId',
  type: 'uint'
}, {
  name: 'updatedPlaylistPrivacy',
  type: 'bool'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.updatePlaylistNameRequest = [{
  name: 'playlistId',
  type: 'uint'
}, {
  name: 'updatedPlaylistName',
  type: 'string'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.updatePlaylistCoverPhotoRequest = [{
  name: 'playlistId',
  type: 'uint'
}, {
  name: 'playlistImageMultihashDigest',
  type: 'bytes32'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.updatePlaylistDescriptionRequest = [{
  name: 'playlistId',
  type: 'uint'
}, {
  name: 'playlistDescription',
  type: 'string'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.updatePlaylistUPCRequest = [{
  name: 'playlistId',
  type: 'uint'
}, {
  name: 'playlistUPC',
  type: 'bytes32'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.trackSaveRequest = [{
  name: 'userId',
  type: 'uint'
}, {
  name: 'trackId',
  type: 'uint'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.deleteTrackSaveRequest = schemas.trackSaveRequest;
schemas.playlistSaveRequest = [{
  name: 'userId',
  type: 'uint'
}, {
  name: 'playlistId',
  type: 'uint'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.deletePlaylistSaveRequest = schemas.playlistSaveRequest;
schemas.addIPLDBlacklist = [{
  name: 'multihashDigest',
  type: 'bytes32'
}, {
  name: 'nonce',
  type: 'bytes32'
}]; // User replica set manager schemas

schemas.proposeAddOrUpdateContentNode = [{
  name: 'cnodeSpId',
  type: 'uint'
}, {
  name: 'cnodeDelegateOwnerWallet',
  type: 'address'
}, {
  name: 'cnodeOwnerWallet',
  type: 'address'
}, {
  name: 'proposerSpId',
  type: 'uint'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
schemas.updateReplicaSet = [{
  name: 'userId',
  type: 'uint'
}, {
  name: 'primaryId',
  type: 'uint'
}, {
  name: 'secondaryIdsHash',
  type: 'bytes32'
}, {
  name: 'oldPrimaryId',
  type: 'uint'
}, {
  name: 'oldSecondaryIdsHash',
  type: 'bytes32'
}, {
  name: 'nonce',
  type: 'bytes32'
}];
var generators = {};

function getRequestData(domainDataFn, chainId, contractAddress, messageTypeName, messageSchema, message) {
  var domainData = domainDataFn(chainId, contractAddress);
  var types = {
    EIP712Domain: schemas.domain
  };
  types[messageTypeName] = messageSchema;
  return {
    types: types,
    domain: domainData,
    primaryType: messageTypeName,
    message: message
  };
}
/* User Factory Generators */


generators.getAddUserRequestData = function (chainId, contractAddress, handle, nonce) {
  var message = {
    handle: handle,
    nonce: nonce
  };
  return getRequestData(domains.getUserFactoryDomain, chainId, contractAddress, 'AddUserRequest', schemas.addUserRequest, message);
};

function _getUpdateUserRequestData(chainId, contractAddress, messageTypeName, schema, userId, newValue, nonce) {
  var message = {
    userId: userId,
    newValue: newValue,
    nonce: nonce
  };
  return getRequestData(domains.getUserFactoryDomain, chainId, contractAddress, messageTypeName, schema, message);
}

generators.getUpdateUserMultihashRequestData = function (chainId, contractAddress, userId, newValue, nonce) {
  return _getUpdateUserRequestData(chainId, contractAddress, 'UpdateUserMultihashRequest', schemas.updateUserBytes32, userId, newValue, nonce);
};

generators.getUpdateUserNameRequestData = function (chainId, contractAddress, userId, newValue, nonce) {
  return _getUpdateUserRequestData(chainId, contractAddress, 'UpdateUserNameRequest', schemas.updateUserBytes32, userId, newValue, nonce);
};

generators.getUpdateUserLocationRequestData = function (chainId, contractAddress, userId, newValue, nonce) {
  return _getUpdateUserRequestData(chainId, contractAddress, 'UpdateUserLocationRequest', schemas.updateUserBytes32, userId, newValue, nonce);
};

generators.getUpdateUserProfilePhotoRequestData = function (chainId, contractAddress, userId, newValue, nonce) {
  return _getUpdateUserRequestData(chainId, contractAddress, 'UpdateUserProfilePhotoRequest', schemas.updateUserBytes32, userId, newValue, nonce);
};

generators.getUpdateUserCoverPhotoRequestData = function (chainId, contractAddress, userId, newValue, nonce) {
  return _getUpdateUserRequestData(chainId, contractAddress, 'UpdateUserCoverPhotoRequest', schemas.updateUserBytes32, userId, newValue, nonce);
};

generators.getUpdateUserBioRequestData = function (chainId, contractAddress, userId, newValue, nonce) {
  return _getUpdateUserRequestData(chainId, contractAddress, 'UpdateUserBioRequest', schemas.updateUserString, userId, newValue, nonce);
};

generators.getUpdateUserCreatorNodeRequestData = function (chainId, contractAddress, userId, newValue, nonce) {
  return _getUpdateUserRequestData(chainId, contractAddress, 'UpdateUserCreatorNodeRequest', schemas.updateUserString, userId, newValue, nonce);
};

generators.getUpdateUserCreatorRequestData = function (chainId, contractAddress, userId, newValue, nonce) {
  return _getUpdateUserRequestData(chainId, contractAddress, 'UpdateUserCreatorRequest', schemas.updateUserBool, userId, newValue, nonce);
};

generators.getUpdateUserVerifiedRequestData = function (chainId, contractAddress, userId, newValue, nonce) {
  return _getUpdateUserRequestData(chainId, contractAddress, 'UpdateUserVerifiedRequest', schemas.updateUserBool, userId, newValue, nonce);
};
/* Track Factory Generators */


generators.getAddTrackRequestData = function (chainId, contractAddress, trackOwnerId, multihashDigest, multihashHashFn, multihashSize, nonce) {
  var message = {
    trackOwnerId: trackOwnerId,
    multihashDigest: multihashDigest,
    multihashHashFn: multihashHashFn,
    multihashSize: multihashSize,
    nonce: nonce
  };
  return getRequestData(domains.getTrackFactoryDomain, chainId, contractAddress, 'AddTrackRequest', schemas.addTrackRequest, message);
};

generators.getUpdateTrackRequestData = function (chainId, contractAddress, trackId, trackOwnerId, multihashDigest, multihashHashFn, multihashSize, nonce) {
  var message = {
    trackId: trackId,
    trackOwnerId: trackOwnerId,
    multihashDigest: multihashDigest,
    multihashHashFn: multihashHashFn,
    multihashSize: multihashSize,
    nonce: nonce
  };
  return getRequestData(domains.getTrackFactoryDomain, chainId, contractAddress, 'UpdateTrackRequest', schemas.updateTrackRequest, message);
};

generators.getDeleteTrackRequestData = function (chainId, contractAddress, trackId, nonce) {
  var message = {
    trackId: trackId,
    nonce: nonce
  };
  return getRequestData(domains.getTrackFactoryDomain, chainId, contractAddress, 'DeleteTrackRequest', schemas.deleteTrackRequest, message);
};
/* Social Feature Factory Generators */


generators.getAddTrackRepostRequestData = function (chainId, contractAddress, userId, trackId, nonce) {
  var message = {
    userId: userId,
    trackId: trackId,
    nonce: nonce
  };
  return getRequestData(domains.getSocialFeatureFactoryDomain, chainId, contractAddress, 'AddTrackRepostRequest', schemas.addTrackRepostRequest, message);
};

generators.getDeleteTrackRepostRequestData = function (chainId, contractAddress, userId, trackId, nonce) {
  var message = {
    userId: userId,
    trackId: trackId,
    nonce: nonce
  };
  return getRequestData(domains.getSocialFeatureFactoryDomain, chainId, contractAddress, 'DeleteTrackRepostRequest', schemas.deleteTrackRepostRequest, message);
};

generators.getAddPlaylistRepostRequestData = function (chainId, contractAddress, userId, playlistId, nonce) {
  var message = {
    userId: userId,
    playlistId: playlistId,
    nonce: nonce
  };
  return getRequestData(domains.getSocialFeatureFactoryDomain, chainId, contractAddress, 'AddPlaylistRepostRequest', schemas.addPlaylistRepostRequest, message);
};

generators.getDeletePlaylistRepostRequestData = function (chainId, contractAddress, userId, playlistId, nonce) {
  var message = {
    userId: userId,
    playlistId: playlistId,
    nonce: nonce
  };
  return getRequestData(domains.getSocialFeatureFactoryDomain, chainId, contractAddress, 'DeletePlaylistRepostRequest', schemas.deletePlaylistRepostRequest, message);
};

generators.getUserFollowRequestData = function (chainId, contractAddress, followerUserId, followeeUserId, nonce) {
  var message = {
    followerUserId: followerUserId,
    followeeUserId: followeeUserId,
    nonce: nonce
  };
  return getRequestData(domains.getSocialFeatureFactoryDomain, chainId, contractAddress, 'UserFollowRequest', schemas.userFollowRequest, message);
};

generators.getDeleteUserFollowRequestData = function (chainId, contractAddress, followerUserId, followeeUserId, nonce) {
  var message = {
    followerUserId: followerUserId,
    followeeUserId: followeeUserId,
    nonce: nonce
  };
  return getRequestData(domains.getSocialFeatureFactoryDomain, chainId, contractAddress, 'DeleteUserFollowRequest', schemas.deleteUserFollowRequest, message);
};

generators.getTrackSaveRequestData = function (chainId, contractAddress, userId, trackId, nonce) {
  var message = {
    userId: userId,
    trackId: trackId,
    nonce: nonce
  };
  return getRequestData(domains.getUserLibraryFactoryDomain, chainId, contractAddress, 'TrackSaveRequest', schemas.trackSaveRequest, message);
};

generators.getDeleteTrackSaveRequestData = function (chainId, contractAddress, userId, trackId, nonce) {
  var message = {
    userId: userId,
    trackId: trackId,
    nonce: nonce
  };
  return getRequestData(domains.getUserLibraryFactoryDomain, chainId, contractAddress, 'DeleteTrackSaveRequest', schemas.deleteTrackSaveRequest, message);
};

generators.getPlaylistSaveRequestData = function (chainId, contractAddress, userId, playlistId, nonce) {
  var message = {
    userId: userId,
    playlistId: playlistId,
    nonce: nonce
  };
  return getRequestData(domains.getUserLibraryFactoryDomain, chainId, contractAddress, 'PlaylistSaveRequest', schemas.playlistSaveRequest, message);
};

generators.getDeletePlaylistSaveRequestData = function (chainId, contractAddress, userId, playlistId, nonce) {
  var message = {
    userId: userId,
    playlistId: playlistId,
    nonce: nonce
  };
  return getRequestData(domains.getUserLibraryFactoryDomain, chainId, contractAddress, 'DeletePlaylistSaveRequest', schemas.deletePlaylistSaveRequest, message);
};
/* Playlist Factory Generators */

/* NOTE: Ensure the value for trackIds hash is generated using the following snippet prior to calling this generator function:
 * web3New.utils.soliditySha3(web3New.eth.abi.encodeParameter('uint[]', trackIds))
 */


generators.getCreatePlaylistRequestData = function (chainId, contractAddress, playlistOwnerId, playlistName, isPrivate, isAlbum, trackIdsHash, nonce) {
  var message = {
    playlistOwnerId: playlistOwnerId,
    playlistName: playlistName,
    isPrivate: isPrivate,
    isAlbum: isAlbum,
    trackIdsHash: trackIdsHash,
    nonce: nonce
  };
  return getRequestData(domains.getPlaylistFactoryDomain, chainId, contractAddress, 'CreatePlaylistRequest', schemas.createPlaylistRequest, message);
};

generators.getDeletePlaylistRequestData = function (chainId, contractAddress, playlistId, nonce) {
  var message = {
    playlistId: playlistId,
    nonce: nonce
  };
  return getRequestData(domains.getPlaylistFactoryDomain, chainId, contractAddress, 'DeletePlaylistRequest', schemas.deletePlaylistRequest, message);
};

generators.getAddPlaylistTrackRequestData = function (chainId, contractAddress, playlistId, addedTrackId, nonce) {
  var message = {
    playlistId: playlistId,
    addedTrackId: addedTrackId,
    nonce: nonce
  };
  return getRequestData(domains.getPlaylistFactoryDomain, chainId, contractAddress, 'AddPlaylistTrackRequest', schemas.addPlaylistTrackRequest, message);
};

generators.getDeletePlaylistTrackRequestData = function (chainId, contractAddress, playlistId, deletedTrackId, deletedTrackTimestamp, nonce) {
  var message = {
    playlistId: playlistId,
    deletedTrackId: deletedTrackId,
    deletedTrackTimestamp: deletedTrackTimestamp,
    nonce: nonce
  };
  return getRequestData(domains.getPlaylistFactoryDomain, chainId, contractAddress, 'DeletePlaylistTrackRequest', schemas.deletePlaylistTrackRequest, message);
};

generators.getOrderPlaylistTracksRequestData = function (chainId, contractAddress, playlistId, trackIdsHash, nonce) {
  var message = {
    playlistId: playlistId,
    trackIdsHash: trackIdsHash,
    nonce: nonce
  };
  return getRequestData(domains.getPlaylistFactoryDomain, chainId, contractAddress, 'OrderPlaylistTracksRequest', schemas.orderPlaylistTracksRequest, message);
};

generators.getUpdatePlaylistNameRequestData = function (chainId, contractAddress, playlistId, updatedPlaylistName, nonce) {
  var message = {
    playlistId: playlistId,
    updatedPlaylistName: updatedPlaylistName,
    nonce: nonce
  };
  return getRequestData(domains.getPlaylistFactoryDomain, chainId, contractAddress, 'UpdatePlaylistNameRequest', schemas.updatePlaylistNameRequest, message);
};

generators.getUpdatePlaylistPrivacyRequestData = function (chainId, contractAddress, playlistId, updatedPlaylistPrivacy, nonce) {
  var message = {
    playlistId: playlistId,
    updatedPlaylistPrivacy: updatedPlaylistPrivacy,
    nonce: nonce
  };
  return getRequestData(domains.getPlaylistFactoryDomain, chainId, contractAddress, 'UpdatePlaylistPrivacyRequest', schemas.updatePlaylistPrivacyRequest, message);
};

generators.getUpdatePlaylistCoverPhotoRequestData = function (chainId, contractAddress, playlistId, playlistImageMultihashDigest, nonce) {
  var message = {
    playlistId: playlistId,
    playlistImageMultihashDigest: playlistImageMultihashDigest,
    nonce: nonce
  };
  return getRequestData(domains.getPlaylistFactoryDomain, chainId, contractAddress, 'UpdatePlaylistCoverPhotoRequest', schemas.updatePlaylistCoverPhotoRequest, message);
};

generators.getUpdatePlaylistUPCRequestData = function (chainId, contractAddress, playlistId, playlistUPC, nonce) {
  var message = {
    playlistId: playlistId,
    playlistUPC: playlistUPC,
    nonce: nonce
  };
  return getRequestData(domains.getPlaylistFactoryDomain, chainId, contractAddress, 'UpdatePlaylistUPCRequest', schemas.updatePlaylistUPCRequest, message);
};

generators.getUpdatePlaylistDescriptionRequestData = function (chainId, contractAddress, playlistId, playlistDescription, nonce) {
  var message = {
    playlistId: playlistId,
    playlistDescription: playlistDescription,
    nonce: nonce
  };
  return getRequestData(domains.getPlaylistFactoryDomain, chainId, contractAddress, 'UpdatePlaylistDescriptionRequest', schemas.updatePlaylistDescriptionRequest, message);
};

generators.addIPLDToBlacklistRequestData = function (chainId, contractAddress, multihashDigest, nonce) {
  var message = {
    multihashDigest: multihashDigest,
    nonce: nonce
  };
  return getRequestData(domains.getIPLDBlacklistFactoryDomain, chainId, contractAddress, 'AddIPLDToBlacklistRequest', schemas.addIPLDBlacklist, message);
};
/* User Replica Set Manager Generators */


generators.getProposeAddOrUpdateContentNodeRequestData = function (chainId, contractAddress, cnodeSpId, cnodeDelegateOwnerWallet, cnodeOwnerWallet, proposerSpId, nonce) {
  var message = {
    cnodeSpId: cnodeSpId,
    cnodeDelegateOwnerWallet: cnodeDelegateOwnerWallet,
    cnodeOwnerWallet: cnodeOwnerWallet,
    proposerSpId: proposerSpId,
    nonce: nonce
  };
  return getRequestData(domains.getUserReplicaSetManagerDomain, chainId, contractAddress, 'ProposeAddOrUpdateContentNode', schemas.proposeAddOrUpdateContentNode, message);
};

generators.getUpdateReplicaSetRequestData = function (chainId, contractAddress, userId, primaryId, secondaryIdsHash, oldPrimaryId, oldSecondaryIdsHash, nonce) {
  var message = {
    userId: userId,
    primaryId: primaryId,
    secondaryIdsHash: secondaryIdsHash,
    oldPrimaryId: oldPrimaryId,
    oldSecondaryIdsHash: oldSecondaryIdsHash,
    nonce: nonce
  };
  return getRequestData(domains.getUserReplicaSetManagerDomain, chainId, contractAddress, 'UpdateReplicaSet', schemas.updateReplicaSet, message);
};
/** Return a secure random hex string of nChar length in a browser-compatible way
 *  Taken from https://stackoverflow.com/questions/37378237/how-to-generate-a-random-token-of-32-bit-in-javascript
 */


function browserRandomHash(nChar) {
  // convert number of characters to number of bytes
  var nBytes = Math.ceil(nChar = (+nChar || 8) / 2); // create a typed array of that many bytes

  var u = new Uint8Array(nBytes); // populate it wit crypto-random values

  window.crypto.getRandomValues(u); // convert it to an Array of Strings (e.g. '01', 'AF', ..)

  var zpad = function zpad(str) {
    return '00'.slice(str.length) + str;
  };

  var a = Array.prototype.map.call(u, function (x) {
    return zpad(x.toString(16));
  }); // Array of String to String

  var str = a.join('').toLowerCase(); // and snip off the excess digit if we want an odd number

  if (nChar % 2) str = str.slice(1); // return what we made

  return str;
} // We need to detect whether the nodejs crypto module is available to determine how to
// generate secure random numbers below


var nodeCrypto;

try {
  nodeCrypto = require('crypto');
} catch (e) {
  nodeCrypto = null;
}

function getNonce() {
  // detect whether we are in browser or in nodejs, and use the correct csprng
  if (typeof window === 'undefined' || window === null) {
    return '0x' + nodeCrypto.randomBytes(32).toString('hex');
  } else {
    return '0x' + browserRandomHash(64);
  }
}

var signatureSchemas$7 = {
  domains: domains,
  schemas: schemas,
  generators: generators,
  getNonce: getNonce
};

var safeBuffer = createModule("/$$rollup_base$$/node_modules/safe-buffer");

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

(function (module, exports) {
  /* eslint-disable node/no-deprecated-api */
  var buffer = require$$0__default$2["default"];
  var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }

  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }

  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
  }

  SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

  copyProps(Buffer, SafeBuffer);

  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number');
    }

    return Buffer(arg, encodingOrOffset, length);
  };

  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    var buf = Buffer(size);

    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }

    return buf;
  };

  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    return Buffer(size);
  };

  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    return buffer.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);

var ContractClient$6 = require$$0.ContractClient;
var signatureSchemas$6 = signatureSchemas$7;
var Utils$8 = require$$18.Utils;
var sigUtil$1 = sigUtil__default["default"];
var BufferSafe$1 = safeBuffer.exports.Buffer;

var UserFactoryClient$1 = /*#__PURE__*/function (_ContractClient) {
  _inherits(UserFactoryClient, _ContractClient);

  var _super = _createSuper(UserFactoryClient);

  function UserFactoryClient() {
    _classCallCheck(this, UserFactoryClient);

    return _super.apply(this, arguments);
  }

  _createClass(UserFactoryClient, [{
    key: "getUser",
    value:
    /* ------- GETTERS ------- */
    function () {
      var _getUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(userId) {
        var method;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getMethod('getUser', userId);

              case 2:
                method = _context.sent;
                return _context.abrupt("return", method.call());

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getUser(_x) {
        return _getUser.apply(this, arguments);
      }

      return getUser;
    }()
    /** valid = does not exist and meets handle requirements (defined on chain) */

  }, {
    key: "handleIsValid",
    value: function () {
      var _handleIsValid = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(handle) {
        var method;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getMethod('handleIsValid', Utils$8.utf8ToHex(handle));

              case 2:
                method = _context2.sent;
                return _context2.abrupt("return", method.call());

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function handleIsValid(_x2) {
        return _handleIsValid.apply(this, arguments);
      }

      return handleIsValid;
    }()
    /* ------- SETTERS ------- */

  }, {
    key: "addUser",
    value: function () {
      var _addUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(handle) {
        var nonce, chainId, contractAddress, signatureData, sig, method, tx;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                Utils$8.checkStrLen(handle, 16);
                nonce = signatureSchemas$6.getNonce();
                _context3.next = 4;
                return this.getEthNetId();

              case 4:
                chainId = _context3.sent;
                _context3.next = 7;
                return this.getAddress();

              case 7:
                contractAddress = _context3.sent;
                signatureData = signatureSchemas$6.generators.getAddUserRequestData(chainId, contractAddress, handle, nonce);
                _context3.next = 11;
                return this.web3Manager.signTypedData(signatureData);

              case 11:
                sig = _context3.sent;
                _context3.next = 14;
                return this.getMethod('addUser', this.web3Manager.getWalletAddress(), Utils$8.utf8ToHex(handle), nonce, sig);

              case 14:
                method = _context3.sent;
                _context3.next = 17;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 17:
                tx = _context3.sent;
                return _context3.abrupt("return", {
                  txReceipt: tx,
                  userId: parseInt(tx.events.AddUser.returnValues._userId, 10)
                });

              case 19:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function addUser(_x3) {
        return _addUser.apply(this, arguments);
      }

      return addUser;
    }()
  }, {
    key: "updateMultihash",
    value: function () {
      var _updateMultihash = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(userId, multihashDigest) {
        var _yield$this$getUpdate, _yield$this$getUpdate2, nonce, sig, method, contractAddress, tx;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getUpdateNonceAndSig(signatureSchemas$6.generators.getUpdateUserMultihashRequestData, userId, multihashDigest);

              case 2:
                _yield$this$getUpdate = _context4.sent;
                _yield$this$getUpdate2 = _slicedToArray(_yield$this$getUpdate, 2);
                nonce = _yield$this$getUpdate2[0];
                sig = _yield$this$getUpdate2[1];
                _context4.next = 8;
                return this.getMethod('updateMultihash', userId, multihashDigest, nonce, sig);

              case 8:
                method = _context4.sent;
                _context4.next = 11;
                return this.getAddress();

              case 11:
                contractAddress = _context4.sent;
                _context4.next = 14;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 14:
                tx = _context4.sent;
                return _context4.abrupt("return", {
                  txReceipt: tx,
                  multihashDigest: tx.events.UpdateMultihash.returnValues._multihashDigest
                });

              case 16:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function updateMultihash(_x4, _x5) {
        return _updateMultihash.apply(this, arguments);
      }

      return updateMultihash;
    }()
  }, {
    key: "updateName",
    value: function () {
      var _updateName = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(userId, name) {
        var _yield$this$getUpdate3, _yield$this$getUpdate4, nonce, sig, method, contractAddress, tx;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                Utils$8.checkStrLen(name, 32);
                _context5.next = 3;
                return this.getUpdateNonceAndSig(signatureSchemas$6.generators.getUpdateUserNameRequestData, userId, name);

              case 3:
                _yield$this$getUpdate3 = _context5.sent;
                _yield$this$getUpdate4 = _slicedToArray(_yield$this$getUpdate3, 2);
                nonce = _yield$this$getUpdate4[0];
                sig = _yield$this$getUpdate4[1];
                _context5.next = 9;
                return this.getMethod('updateName', userId, Utils$8.utf8ToHex(name), nonce, sig);

              case 9:
                method = _context5.sent;
                _context5.next = 12;
                return this.getAddress();

              case 12:
                contractAddress = _context5.sent;
                _context5.next = 15;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 15:
                tx = _context5.sent;
                return _context5.abrupt("return", {
                  txReceipt: tx,
                  name: Utils$8.hexToUtf8(tx.events.UpdateName.returnValues._name)
                });

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function updateName(_x6, _x7) {
        return _updateName.apply(this, arguments);
      }

      return updateName;
    }()
  }, {
    key: "updateLocation",
    value: function () {
      var _updateLocation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(userId, location) {
        var maxLength, _yield$this$getUpdate5, _yield$this$getUpdate6, nonce, sig, method, contractAddress, tx;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                maxLength = 32;
                Utils$8.checkStrLen(location, maxLength,
                /* minLen */
                0);
                _context6.next = 4;
                return this.getUpdateNonceAndSig(signatureSchemas$6.generators.getUpdateUserLocationRequestData, userId, location);

              case 4:
                _yield$this$getUpdate5 = _context6.sent;
                _yield$this$getUpdate6 = _slicedToArray(_yield$this$getUpdate5, 2);
                nonce = _yield$this$getUpdate6[0];
                sig = _yield$this$getUpdate6[1];
                _context6.next = 10;
                return this.getMethod('updateLocation', userId, Utils$8.padRight(Utils$8.utf8ToHex(location), maxLength * 2), nonce, sig);

              case 10:
                method = _context6.sent;
                _context6.next = 13;
                return this.getAddress();

              case 13:
                contractAddress = _context6.sent;
                _context6.next = 16;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 16:
                tx = _context6.sent;
                return _context6.abrupt("return", {
                  txReceipt: tx,
                  location: Utils$8.hexToUtf8(tx.events.UpdateLocation.returnValues._location)
                });

              case 18:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function updateLocation(_x8, _x9) {
        return _updateLocation.apply(this, arguments);
      }

      return updateLocation;
    }()
  }, {
    key: "updateBio",
    value: function () {
      var _updateBio = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(userId, bio) {
        var _yield$this$getUpdate7, _yield$this$getUpdate8, nonce, sig, method, contractAddress, tx;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getUpdateNonceAndSig(signatureSchemas$6.generators.getUpdateUserBioRequestData, userId, bio);

              case 2:
                _yield$this$getUpdate7 = _context7.sent;
                _yield$this$getUpdate8 = _slicedToArray(_yield$this$getUpdate7, 2);
                nonce = _yield$this$getUpdate8[0];
                sig = _yield$this$getUpdate8[1];
                _context7.next = 8;
                return this.getMethod('updateBio', userId, bio, nonce, sig);

              case 8:
                method = _context7.sent;
                _context7.next = 11;
                return this.getAddress();

              case 11:
                contractAddress = _context7.sent;
                _context7.next = 14;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 14:
                tx = _context7.sent;
                return _context7.abrupt("return", {
                  txReceipt: tx,
                  bio: tx.events.UpdateBio.returnValues._bio
                });

              case 16:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function updateBio(_x10, _x11) {
        return _updateBio.apply(this, arguments);
      }

      return updateBio;
    }()
  }, {
    key: "updateProfilePhoto",
    value: function () {
      var _updateProfilePhoto = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(userId, profilePhotoMultihashDigest) {
        var _yield$this$getUpdate9, _yield$this$getUpdate10, nonce, sig, method, contractAddress, tx;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getUpdateNonceAndSig(signatureSchemas$6.generators.getUpdateUserProfilePhotoRequestData, userId, profilePhotoMultihashDigest);

              case 2:
                _yield$this$getUpdate9 = _context8.sent;
                _yield$this$getUpdate10 = _slicedToArray(_yield$this$getUpdate9, 2);
                nonce = _yield$this$getUpdate10[0];
                sig = _yield$this$getUpdate10[1];
                _context8.next = 8;
                return this.getMethod('updateProfilePhoto', userId, profilePhotoMultihashDigest, nonce, sig);

              case 8:
                method = _context8.sent;
                _context8.next = 11;
                return this.getAddress();

              case 11:
                contractAddress = _context8.sent;
                _context8.next = 14;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 14:
                tx = _context8.sent;
                return _context8.abrupt("return", {
                  txReceipt: tx,
                  profilePhotoMultihashDigest: tx.events.UpdateProfilePhoto.returnValues._profilePhotoDigest
                });

              case 16:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function updateProfilePhoto(_x12, _x13) {
        return _updateProfilePhoto.apply(this, arguments);
      }

      return updateProfilePhoto;
    }()
  }, {
    key: "updateCoverPhoto",
    value: function () {
      var _updateCoverPhoto = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(userId, coverPhotoMultihashDigest) {
        var _yield$this$getUpdate11, _yield$this$getUpdate12, nonce, sig, method, contractAddress, tx;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getUpdateNonceAndSig(signatureSchemas$6.generators.getUpdateUserCoverPhotoRequestData, userId, coverPhotoMultihashDigest);

              case 2:
                _yield$this$getUpdate11 = _context9.sent;
                _yield$this$getUpdate12 = _slicedToArray(_yield$this$getUpdate11, 2);
                nonce = _yield$this$getUpdate12[0];
                sig = _yield$this$getUpdate12[1];
                _context9.next = 8;
                return this.getMethod('updateCoverPhoto', userId, coverPhotoMultihashDigest, nonce, sig);

              case 8:
                method = _context9.sent;
                _context9.next = 11;
                return this.getAddress();

              case 11:
                contractAddress = _context9.sent;
                _context9.next = 14;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 14:
                tx = _context9.sent;
                return _context9.abrupt("return", {
                  txReceipt: tx,
                  coverPhotoMultihashDigest: tx.events.UpdateCoverPhoto.returnValues._coverPhotoDigest
                });

              case 16:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function updateCoverPhoto(_x14, _x15) {
        return _updateCoverPhoto.apply(this, arguments);
      }

      return updateCoverPhoto;
    }()
  }, {
    key: "updateIsCreator",
    value: function () {
      var _updateIsCreator = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(userId, isCreator) {
        var _yield$this$getUpdate13, _yield$this$getUpdate14, nonce, sig, method, contractAddress, tx;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getUpdateNonceAndSig(signatureSchemas$6.generators.getUpdateUserCreatorRequestData, userId, isCreator);

              case 2:
                _yield$this$getUpdate13 = _context10.sent;
                _yield$this$getUpdate14 = _slicedToArray(_yield$this$getUpdate13, 2);
                nonce = _yield$this$getUpdate14[0];
                sig = _yield$this$getUpdate14[1];
                _context10.next = 8;
                return this.getMethod('updateIsCreator', userId, isCreator, nonce, sig);

              case 8:
                method = _context10.sent;
                _context10.next = 11;
                return this.getAddress();

              case 11:
                contractAddress = _context10.sent;
                _context10.next = 14;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 14:
                tx = _context10.sent;
                return _context10.abrupt("return", {
                  txReceipt: tx,
                  isCreator: tx.events.UpdateIsCreator.returnValues._isCreator
                });

              case 16:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function updateIsCreator(_x16, _x17) {
        return _updateIsCreator.apply(this, arguments);
      }

      return updateIsCreator;
    }()
    /**
     * This function is called from the identity service, not from the client. As a result,
     * the return properties are different. The web3 sendTransaction() function isn't called, rather
     * the encodedABI and contract address are returned, and the identity service can relay it
     * to the chain on behalf of the user
     * @param {number} userId blockchain userId
     * @param {Boolean} isVerified
     * @param {string} privateKey 64 character hex string
     */

  }, {
    key: "updateIsVerified",
    value: function () {
      var _updateIsVerified = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(userId, isVerified, privateKey) {
        var contractAddress, _yield$this$getUpdate15, _yield$this$getUpdate16, nonce, sig, method;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.getAddress();

              case 2:
                contractAddress = _context11.sent;
                _context11.next = 5;
                return this.getUpdateNonceAndSig(signatureSchemas$6.generators.getUpdateUserVerifiedRequestData, userId, isVerified, privateKey);

              case 5:
                _yield$this$getUpdate15 = _context11.sent;
                _yield$this$getUpdate16 = _slicedToArray(_yield$this$getUpdate15, 2);
                nonce = _yield$this$getUpdate16[0];
                sig = _yield$this$getUpdate16[1];
                _context11.next = 11;
                return this.getMethod('updateIsVerified', userId, isVerified, nonce, sig);

              case 11:
                method = _context11.sent;
                return _context11.abrupt("return", [method.encodeABI(), contractAddress]);

              case 13:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function updateIsVerified(_x18, _x19, _x20) {
        return _updateIsVerified.apply(this, arguments);
      }

      return updateIsVerified;
    }()
  }, {
    key: "updateCreatorNodeEndpoint",
    value: function () {
      var _updateCreatorNodeEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(userId, creatorNodeEndpoint) {
        var _yield$this$getUpdate17, _yield$this$getUpdate18, nonce, sig, method, contractAddress, tx;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getUpdateNonceAndSig(signatureSchemas$6.generators.getUpdateUserCreatorNodeRequestData, userId, creatorNodeEndpoint);

              case 2:
                _yield$this$getUpdate17 = _context12.sent;
                _yield$this$getUpdate18 = _slicedToArray(_yield$this$getUpdate17, 2);
                nonce = _yield$this$getUpdate18[0];
                sig = _yield$this$getUpdate18[1];
                _context12.next = 8;
                return this.getMethod('updateCreatorNodeEndpoint', userId, creatorNodeEndpoint, nonce, sig);

              case 8:
                method = _context12.sent;
                _context12.next = 11;
                return this.getAddress();

              case 11:
                contractAddress = _context12.sent;
                _context12.next = 14;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 14:
                tx = _context12.sent;
                return _context12.abrupt("return", {
                  txReceipt: tx,
                  creatorNodeEndpoint: tx.events.UpdateCreatorNodeEndpoint.returnValues._creatorNodeEndpoint
                });

              case 16:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function updateCreatorNodeEndpoint(_x21, _x22) {
        return _updateCreatorNodeEndpoint.apply(this, arguments);
      }

      return updateCreatorNodeEndpoint;
    }()
    /* ------- HELPERS ------- */

    /**
     * Gets a nonce and generates a signature for the given function. Private key is optional and
     * will use that private key to create the signature. Otherwise the web3Manager private key
     * will be used.
     * @param {Object} generatorFn signature scheme object function
     * @param {number} userId blockchain userId
     * @param {Varies} newValue new value to set
     * @param {string} privateKey 64 character hex string
     */

  }, {
    key: "getUpdateNonceAndSig",
    value: function () {
      var _getUpdateNonceAndSig = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(generatorFn, userId, newValue, privateKey) {
        var nonce, chainId, contractAddress, signatureData, sig;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                nonce = signatureSchemas$6.getNonce();
                _context13.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context13.sent;
                _context13.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context13.sent;
                signatureData = generatorFn(chainId, contractAddress, userId, newValue, nonce);

                if (!privateKey) {
                  _context13.next = 12;
                  break;
                }

                sig = sigUtil$1.signTypedData(BufferSafe$1.from(privateKey, 'hex'), {
                  data: signatureData
                });
                _context13.next = 15;
                break;

              case 12:
                _context13.next = 14;
                return this.web3Manager.signTypedData(signatureData);

              case 14:
                sig = _context13.sent;

              case 15:
                return _context13.abrupt("return", [nonce, sig]);

              case 16:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getUpdateNonceAndSig(_x23, _x24, _x25, _x26) {
        return _getUpdateNonceAndSig.apply(this, arguments);
      }

      return getUpdateNonceAndSig;
    }()
  }]);

  return UserFactoryClient;
}(ContractClient$6);

var userFactoryClient = UserFactoryClient$1;

var ContractClient$5 = require$$0.ContractClient;
var signatureSchemas$5 = signatureSchemas$7;

var TrackFactoryClient$1 = /*#__PURE__*/function (_ContractClient) {
  _inherits(TrackFactoryClient, _ContractClient);

  var _super = _createSuper(TrackFactoryClient);

  function TrackFactoryClient() {
    _classCallCheck(this, TrackFactoryClient);

    return _super.apply(this, arguments);
  }

  _createClass(TrackFactoryClient, [{
    key: "getTrack",
    value:
    /* -------  GETTERS ------- */
    function () {
      var _getTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(trackId) {
        var method;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getMethod('getTrack', trackId);

              case 2:
                method = _context.sent;
                return _context.abrupt("return", method.call());

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getTrack(_x) {
        return _getTrack.apply(this, arguments);
      }

      return getTrack;
    }()
    /* -------  SETTERS ------- */

    /** uint _userId, bytes32 _multihashDigest, uint8 _multihashHashFn, uint8 _multihashSize */

  }, {
    key: "addTrack",
    value: function () {
      var _addTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(userId, multihashDigest, multihashHashFn, multihashSize) {
        var nonce, chainId, contractAddress, signatureData, sig, method, tx;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                nonce = signatureSchemas$5.getNonce();
                _context2.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context2.sent;
                _context2.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context2.sent;
                signatureData = signatureSchemas$5.generators.getAddTrackRequestData(chainId, contractAddress, userId, multihashDigest, multihashHashFn, multihashSize, nonce);
                _context2.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context2.sent;
                _context2.next = 13;
                return this.getMethod('addTrack', userId, multihashDigest, multihashHashFn, multihashSize, nonce, sig);

              case 13:
                method = _context2.sent;
                _context2.next = 16;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 16:
                tx = _context2.sent;
                return _context2.abrupt("return", {
                  trackId: parseInt(tx.events.NewTrack.returnValues._id, 10),
                  txReceipt: tx
                });

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function addTrack(_x2, _x3, _x4, _x5) {
        return _addTrack.apply(this, arguments);
      }

      return addTrack;
    }()
    /** uint _trackId, uint _trackOwnerId, bytes32 _multihashDigest, uint8 _multihashHashFn, uint8 _multihashSize */

  }, {
    key: "updateTrack",
    value: function () {
      var _updateTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(trackId, trackOwnerId, multihashDigest, multihashHashFn, multihashSize) {
        var nonce, chainId, contractAddress, signatureData, sig, method, tx;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                nonce = signatureSchemas$5.getNonce();
                _context3.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context3.sent;
                _context3.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context3.sent;
                signatureData = signatureSchemas$5.generators.getUpdateTrackRequestData(chainId, contractAddress, trackId, trackOwnerId, multihashDigest, multihashHashFn, multihashSize, nonce);
                _context3.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context3.sent;
                _context3.next = 13;
                return this.getMethod('updateTrack', trackId, trackOwnerId, multihashDigest, multihashHashFn, multihashSize, nonce, sig);

              case 13:
                method = _context3.sent;
                _context3.next = 16;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 16:
                tx = _context3.sent;
                return _context3.abrupt("return", {
                  trackId: parseInt(tx.events.UpdateTrack.returnValues._trackId, 10),
                  txReceipt: tx
                });

              case 18:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function updateTrack(_x6, _x7, _x8, _x9, _x10) {
        return _updateTrack.apply(this, arguments);
      }

      return updateTrack;
    }()
    /**
     * @param {uint} trackId
     * @return {uint} deleted trackId from on-chain event log
     */

  }, {
    key: "deleteTrack",
    value: function () {
      var _deleteTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(trackId) {
        var nonce, chainId, contractAddress, signatureData, sig, method, tx;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                nonce = signatureSchemas$5.getNonce();
                _context4.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context4.sent;
                _context4.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context4.sent;
                signatureData = signatureSchemas$5.generators.getDeleteTrackRequestData(chainId, contractAddress, trackId, nonce);
                _context4.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context4.sent;
                _context4.next = 13;
                return this.getMethod('deleteTrack', trackId, nonce, sig);

              case 13:
                method = _context4.sent;
                _context4.next = 16;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 16:
                tx = _context4.sent;
                return _context4.abrupt("return", {
                  trackId: parseInt(tx.events.TrackDeleted.returnValues._trackId, 10),
                  txReceipt: tx
                });

              case 18:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function deleteTrack(_x11) {
        return _deleteTrack.apply(this, arguments);
      }

      return deleteTrack;
    }()
  }]);

  return TrackFactoryClient;
}(ContractClient$5);

var trackFactoryClient = TrackFactoryClient$1;

var ContractClient$4 = require$$0.ContractClient;
var signatureSchemas$4 = signatureSchemas$7;

var SocialFeatureFactoryClient$1 = /*#__PURE__*/function (_ContractClient) {
  _inherits(SocialFeatureFactoryClient, _ContractClient);

  var _super = _createSuper(SocialFeatureFactoryClient);

  function SocialFeatureFactoryClient() {
    _classCallCheck(this, SocialFeatureFactoryClient);

    return _super.apply(this, arguments);
  }

  _createClass(SocialFeatureFactoryClient, [{
    key: "addTrackRepost",
    value: function () {
      var _addTrackRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(userId, trackId) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // generate new track repost request
                nonce = signatureSchemas$4.getNonce();
                _context.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context.sent;
                _context.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context.sent;
                signatureData = signatureSchemas$4.generators.getAddTrackRepostRequestData(chainId, contractAddress, userId, trackId, nonce);
                _context.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context.sent;
                _context.next = 13;
                return this.getMethod('addTrackRepost', userId, trackId, nonce, sig);

              case 13:
                method = _context.sent;
                return _context.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function addTrackRepost(_x, _x2) {
        return _addTrackRepost.apply(this, arguments);
      }

      return addTrackRepost;
    }()
  }, {
    key: "deleteTrackRepost",
    value: function () {
      var _deleteTrackRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(userId, trackId) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // generate new delete track repost request
                nonce = signatureSchemas$4.getNonce();
                _context2.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context2.sent;
                _context2.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context2.sent;
                signatureData = signatureSchemas$4.generators.getDeleteTrackRepostRequestData(chainId, contractAddress, userId, trackId, nonce);
                _context2.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context2.sent;
                _context2.next = 13;
                return this.getMethod('deleteTrackRepost', userId, trackId, nonce, sig);

              case 13:
                method = _context2.sent;
                return _context2.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function deleteTrackRepost(_x3, _x4) {
        return _deleteTrackRepost.apply(this, arguments);
      }

      return deleteTrackRepost;
    }()
  }, {
    key: "addPlaylistRepost",
    value: function () {
      var _addPlaylistRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(userId, playlistId) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // generate new playlist repost request
                nonce = signatureSchemas$4.getNonce();
                _context3.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context3.sent;
                _context3.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context3.sent;
                signatureData = signatureSchemas$4.generators.getAddPlaylistRepostRequestData(chainId, contractAddress, userId, playlistId, nonce);
                _context3.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context3.sent;
                _context3.next = 13;
                return this.getMethod('addPlaylistRepost', userId, playlistId, nonce, sig);

              case 13:
                method = _context3.sent;
                return _context3.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function addPlaylistRepost(_x5, _x6) {
        return _addPlaylistRepost.apply(this, arguments);
      }

      return addPlaylistRepost;
    }()
  }, {
    key: "deletePlaylistRepost",
    value: function () {
      var _deletePlaylistRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(userId, playlistId) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // generate new delete playlist repost request
                nonce = signatureSchemas$4.getNonce();
                _context4.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context4.sent;
                _context4.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context4.sent;
                signatureData = signatureSchemas$4.generators.getDeletePlaylistRepostRequestData(chainId, contractAddress, userId, playlistId, nonce);
                _context4.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context4.sent;
                _context4.next = 13;
                return this.getMethod('deletePlaylistRepost', userId, playlistId, nonce, sig);

              case 13:
                method = _context4.sent;
                return _context4.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function deletePlaylistRepost(_x7, _x8) {
        return _deletePlaylistRepost.apply(this, arguments);
      }

      return deletePlaylistRepost;
    }()
  }, {
    key: "addUserFollow",
    value: function () {
      var _addUserFollow = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(followerUserId, followeeUserId) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(followerUserId === followeeUserId)) {
                  _context5.next = 2;
                  break;
                }

                throw new Error("addUserFollow -  identical value provided for follower and followee ".concat(followerUserId));

              case 2:
                // generate new UserFollow request
                nonce = signatureSchemas$4.getNonce();
                _context5.next = 5;
                return this.getEthNetId();

              case 5:
                chainId = _context5.sent;
                _context5.next = 8;
                return this.getAddress();

              case 8:
                contractAddress = _context5.sent;
                signatureData = signatureSchemas$4.generators.getUserFollowRequestData(chainId, contractAddress, followerUserId, followeeUserId, nonce);
                _context5.next = 12;
                return this.web3Manager.signTypedData(signatureData);

              case 12:
                sig = _context5.sent;
                _context5.next = 15;
                return this.getMethod('addUserFollow', followerUserId, followeeUserId, nonce, sig);

              case 15:
                method = _context5.sent;
                return _context5.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function addUserFollow(_x9, _x10) {
        return _addUserFollow.apply(this, arguments);
      }

      return addUserFollow;
    }()
  }, {
    key: "deleteUserFollow",
    value: function () {
      var _deleteUserFollow = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(followerUserId, followeeUserId) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(followerUserId === followeeUserId)) {
                  _context6.next = 2;
                  break;
                }

                throw new Error("deleteUserFollow - Invalid identical value provided for follower and followee ".concat(followerUserId));

              case 2:
                // generate new deleteUserFollow request
                nonce = signatureSchemas$4.getNonce();
                _context6.next = 5;
                return this.getEthNetId();

              case 5:
                chainId = _context6.sent;
                _context6.next = 8;
                return this.getAddress();

              case 8:
                contractAddress = _context6.sent;
                signatureData = signatureSchemas$4.generators.getDeleteUserFollowRequestData(chainId, contractAddress, followerUserId, followeeUserId, nonce);
                _context6.next = 12;
                return this.web3Manager.signTypedData(signatureData);

              case 12:
                sig = _context6.sent;
                _context6.next = 15;
                return this.getMethod('deleteUserFollow', followerUserId, followeeUserId, nonce, sig);

              case 15:
                method = _context6.sent;
                return _context6.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 17:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function deleteUserFollow(_x11, _x12) {
        return _deleteUserFollow.apply(this, arguments);
      }

      return deleteUserFollow;
    }()
  }]);

  return SocialFeatureFactoryClient;
}(ContractClient$4);

var socialFeatureFactoryClient = SocialFeatureFactoryClient$1;

var ContractClient$3 = require$$0.ContractClient;
var signatureSchemas$3 = signatureSchemas$7;
var MAX_PLAYLIST_LENGTH$1 = 199;

var PlaylistFactoryClient$1 = /*#__PURE__*/function (_ContractClient) {
  _inherits(PlaylistFactoryClient, _ContractClient);

  var _super = _createSuper(PlaylistFactoryClient);

  function PlaylistFactoryClient() {
    _classCallCheck(this, PlaylistFactoryClient);

    return _super.apply(this, arguments);
  }

  _createClass(PlaylistFactoryClient, [{
    key: "createPlaylist",
    value:
    /* ------- SETTERS ------- */
    function () {
      var _createPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(userId, playlistName, isPrivate, isAlbum, trackIds) {
        var nonce, chainId, contractAddress, trackIdsHash, signatureData, sig, method, tx;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(!Array.isArray(trackIds) || trackIds.length > MAX_PLAYLIST_LENGTH$1)) {
                  _context.next = 2;
                  break;
                }

                throw new Error("Cannot create playlist - trackIds must be array with length <= ".concat(MAX_PLAYLIST_LENGTH$1));

              case 2:
                nonce = signatureSchemas$3.getNonce();
                _context.next = 5;
                return this.getEthNetId();

              case 5:
                chainId = _context.sent;
                _context.next = 8;
                return this.getAddress();

              case 8:
                contractAddress = _context.sent;
                trackIdsHash = this.web3Manager.getWeb3().utils.soliditySha3(this.web3Manager.getWeb3().eth.abi.encodeParameter('uint[]', trackIds));
                signatureData = signatureSchemas$3.generators.getCreatePlaylistRequestData(chainId, contractAddress, userId, playlistName, isPrivate, isAlbum, trackIdsHash, nonce);
                _context.next = 13;
                return this.web3Manager.signTypedData(signatureData);

              case 13:
                sig = _context.sent;
                _context.next = 16;
                return this.getMethod('createPlaylist', userId, playlistName, isPrivate, isAlbum, trackIds, nonce, sig);

              case 16:
                method = _context.sent;
                _context.next = 19;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 19:
                tx = _context.sent;
                return _context.abrupt("return", {
                  playlistId: parseInt(tx.events.PlaylistCreated.returnValues._playlistId, 10),
                  txReceipt: tx
                });

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createPlaylist(_x, _x2, _x3, _x4, _x5) {
        return _createPlaylist.apply(this, arguments);
      }

      return createPlaylist;
    }()
  }, {
    key: "deletePlaylist",
    value: function () {
      var _deletePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(playlistId) {
        var nonce, chainId, contractAddress, signatureData, sig, method, tx;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                nonce = signatureSchemas$3.getNonce();
                _context2.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context2.sent;
                _context2.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context2.sent;
                signatureData = signatureSchemas$3.generators.getDeletePlaylistRequestData(chainId, contractAddress, playlistId, nonce);
                _context2.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context2.sent;
                _context2.next = 13;
                return this.getMethod('deletePlaylist', playlistId, nonce, sig);

              case 13:
                method = _context2.sent;
                _context2.next = 16;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 16:
                tx = _context2.sent;
                return _context2.abrupt("return", {
                  playlistId: parseInt(tx.events.PlaylistDeleted.returnValues._playlistId, 10),
                  txReceipt: tx
                });

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function deletePlaylist(_x6) {
        return _deletePlaylist.apply(this, arguments);
      }

      return deletePlaylist;
    }()
  }, {
    key: "addPlaylistTrack",
    value: function () {
      var _addPlaylistTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(playlistId, addedTrackId) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                nonce = signatureSchemas$3.getNonce();
                _context3.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context3.sent;
                _context3.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context3.sent;
                signatureData = signatureSchemas$3.generators.getAddPlaylistTrackRequestData(chainId, contractAddress, playlistId, addedTrackId, nonce);
                _context3.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context3.sent;
                _context3.next = 13;
                return this.getMethod('addPlaylistTrack', playlistId, addedTrackId, nonce, sig);

              case 13:
                method = _context3.sent;
                return _context3.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function addPlaylistTrack(_x7, _x8) {
        return _addPlaylistTrack.apply(this, arguments);
      }

      return addPlaylistTrack;
    }()
  }, {
    key: "deletePlaylistTrack",
    value: function () {
      var _deletePlaylistTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(playlistId, deletedTrackId, deletedPlaylistTimestamp, retries) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                nonce = signatureSchemas$3.getNonce();
                _context4.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context4.sent;
                _context4.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context4.sent;
                signatureData = signatureSchemas$3.generators.getDeletePlaylistTrackRequestData(chainId, contractAddress, playlistId, deletedTrackId, deletedPlaylistTimestamp, nonce);
                _context4.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context4.sent;
                _context4.next = 13;
                return this.getMethod('deletePlaylistTrack', playlistId, deletedTrackId, deletedPlaylistTimestamp, nonce, sig);

              case 13:
                method = _context4.sent;
                return _context4.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress, retries));

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function deletePlaylistTrack(_x9, _x10, _x11, _x12) {
        return _deletePlaylistTrack.apply(this, arguments);
      }

      return deletePlaylistTrack;
    }()
  }, {
    key: "orderPlaylistTracks",
    value: function () {
      var _orderPlaylistTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(playlistId, trackIds, retries) {
        var nonce, chainId, contractAddress, trackIdsHash, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                nonce = signatureSchemas$3.getNonce();
                _context5.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context5.sent;
                _context5.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context5.sent;
                trackIdsHash = this.web3Manager.getWeb3().utils.soliditySha3(this.web3Manager.getWeb3().eth.abi.encodeParameter('uint[]', trackIds));
                signatureData = signatureSchemas$3.generators.getOrderPlaylistTracksRequestData(chainId, contractAddress, playlistId, trackIdsHash, nonce);
                _context5.next = 11;
                return this.web3Manager.signTypedData(signatureData);

              case 11:
                sig = _context5.sent;
                _context5.next = 14;
                return this.getMethod('orderPlaylistTracks', playlistId, trackIds, nonce, sig);

              case 14:
                method = _context5.sent;
                return _context5.abrupt("return", this.web3Manager.sendTransaction(method, // contractMethod
                this.contractRegistryKey, contractAddress, retries));

              case 16:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function orderPlaylistTracks(_x13, _x14, _x15) {
        return _orderPlaylistTracks.apply(this, arguments);
      }

      return orderPlaylistTracks;
    }()
  }, {
    key: "updatePlaylistPrivacy",
    value: function () {
      var _updatePlaylistPrivacy = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(playlistId, updatedPlaylistPrivacy) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                nonce = signatureSchemas$3.getNonce();
                _context6.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context6.sent;
                _context6.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context6.sent;
                signatureData = signatureSchemas$3.generators.getUpdatePlaylistPrivacyRequestData(chainId, contractAddress, playlistId, updatedPlaylistPrivacy, nonce);
                _context6.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context6.sent;
                _context6.next = 13;
                return this.getMethod('updatePlaylistPrivacy', playlistId, updatedPlaylistPrivacy, nonce, sig);

              case 13:
                method = _context6.sent;
                return _context6.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function updatePlaylistPrivacy(_x16, _x17) {
        return _updatePlaylistPrivacy.apply(this, arguments);
      }

      return updatePlaylistPrivacy;
    }()
  }, {
    key: "updatePlaylistName",
    value: function () {
      var _updatePlaylistName = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(playlistId, updatedPlaylistName) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                nonce = signatureSchemas$3.getNonce();
                _context7.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context7.sent;
                _context7.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context7.sent;
                signatureData = signatureSchemas$3.generators.getUpdatePlaylistNameRequestData(chainId, contractAddress, playlistId, updatedPlaylistName, nonce);
                _context7.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context7.sent;
                _context7.next = 13;
                return this.getMethod('updatePlaylistName', playlistId, updatedPlaylistName, nonce, sig);

              case 13:
                method = _context7.sent;
                return _context7.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function updatePlaylistName(_x18, _x19) {
        return _updatePlaylistName.apply(this, arguments);
      }

      return updatePlaylistName;
    }()
  }, {
    key: "updatePlaylistCoverPhoto",
    value: function () {
      var _updatePlaylistCoverPhoto = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(playlistId, updatedPlaylistImageMultihashDigest) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                nonce = signatureSchemas$3.getNonce();
                _context8.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context8.sent;
                _context8.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context8.sent;
                signatureData = signatureSchemas$3.generators.getUpdatePlaylistCoverPhotoRequestData(chainId, contractAddress, playlistId, updatedPlaylistImageMultihashDigest, nonce);
                _context8.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context8.sent;
                _context8.next = 13;
                return this.getMethod('updatePlaylistCoverPhoto', playlistId, updatedPlaylistImageMultihashDigest, nonce, sig);

              case 13:
                method = _context8.sent;
                return _context8.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function updatePlaylistCoverPhoto(_x20, _x21) {
        return _updatePlaylistCoverPhoto.apply(this, arguments);
      }

      return updatePlaylistCoverPhoto;
    }()
  }, {
    key: "updatePlaylistDescription",
    value: function () {
      var _updatePlaylistDescription = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(playlistId, updatedPlaylistDescription) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                nonce = signatureSchemas$3.getNonce();
                _context9.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context9.sent;
                _context9.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context9.sent;
                signatureData = signatureSchemas$3.generators.getUpdatePlaylistDescriptionRequestData(chainId, contractAddress, playlistId, updatedPlaylistDescription, nonce);
                _context9.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context9.sent;
                _context9.next = 13;
                return this.getMethod('updatePlaylistDescription', playlistId, updatedPlaylistDescription, nonce, sig);

              case 13:
                method = _context9.sent;
                return _context9.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function updatePlaylistDescription(_x22, _x23) {
        return _updatePlaylistDescription.apply(this, arguments);
      }

      return updatePlaylistDescription;
    }()
  }, {
    key: "updatePlaylistUPC",
    value: function () {
      var _updatePlaylistUPC = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(playlistId, updatedPlaylistUPC) {
        var nonce, chainId, contractAddress, signatureData, sig, method;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                nonce = signatureSchemas$3.getNonce();
                _context10.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context10.sent;
                _context10.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context10.sent;
                signatureData = signatureSchemas$3.generators.getUpdatePlaylistUPCRequestData(chainId, contractAddress, playlistId, this.web3Manager.getWeb3().utils.utf8ToHex(updatedPlaylistUPC), nonce);
                _context10.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context10.sent;
                _context10.next = 13;
                return this.getMethod('updatePlaylistUPC', playlistId, this.web3Manager.getWeb3().utils.utf8ToHex(updatedPlaylistUPC), nonce, sig);

              case 13:
                method = _context10.sent;
                return _context10.abrupt("return", this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function updatePlaylistUPC(_x24, _x25) {
        return _updatePlaylistUPC.apply(this, arguments);
      }

      return updatePlaylistUPC;
    }()
  }, {
    key: "isTrackInPlaylist",
    value: function () {
      var _isTrackInPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(playlistId, trackId) {
        var method, result;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.getMethod('isTrackInPlaylist', playlistId, trackId);

              case 2:
                method = _context11.sent;
                _context11.next = 5;
                return method.call();

              case 5:
                result = _context11.sent;
                return _context11.abrupt("return", result);

              case 7:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function isTrackInPlaylist(_x26, _x27) {
        return _isTrackInPlaylist.apply(this, arguments);
      }

      return isTrackInPlaylist;
    }()
  }]);

  return PlaylistFactoryClient;
}(ContractClient$3);

var playlistFactoryClient = PlaylistFactoryClient$1;

var ContractClient$2 = require$$0.ContractClient;
var signatureSchemas$2 = signatureSchemas$7;

var UserLibraryFactoryClient$1 = /*#__PURE__*/function (_ContractClient) {
  _inherits(UserLibraryFactoryClient, _ContractClient);

  var _super = _createSuper(UserLibraryFactoryClient);

  function UserLibraryFactoryClient() {
    _classCallCheck(this, UserLibraryFactoryClient);

    return _super.apply(this, arguments);
  }

  _createClass(UserLibraryFactoryClient, [{
    key: "addTrackSave",
    value:
    /* ------- SETTERS ------- */
    function () {
      var _addTrackSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(userId, trackId) {
        var nonce, chainId, contractAddress, signatureData, sig, contractMethod;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                nonce = signatureSchemas$2.getNonce();
                _context.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context.sent;
                _context.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context.sent;
                signatureData = signatureSchemas$2.generators.getTrackSaveRequestData(chainId, contractAddress, userId, trackId, nonce);
                _context.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context.sent;
                _context.next = 13;
                return this.getMethod('addTrackSave', userId, trackId, nonce, sig);

              case 13:
                contractMethod = _context.sent;
                return _context.abrupt("return", this.web3Manager.sendTransaction(contractMethod, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function addTrackSave(_x, _x2) {
        return _addTrackSave.apply(this, arguments);
      }

      return addTrackSave;
    }()
  }, {
    key: "deleteTrackSave",
    value: function () {
      var _deleteTrackSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(userId, trackId) {
        var nonce, chainId, contractAddress, signatureData, sig, contractMethod;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                nonce = signatureSchemas$2.getNonce();
                _context2.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context2.sent;
                _context2.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context2.sent;
                signatureData = signatureSchemas$2.generators.getDeleteTrackSaveRequestData(chainId, contractAddress, userId, trackId, nonce);
                _context2.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context2.sent;
                _context2.next = 13;
                return this.getMethod('deleteTrackSave', userId, trackId, nonce, sig);

              case 13:
                contractMethod = _context2.sent;
                return _context2.abrupt("return", this.web3Manager.sendTransaction(contractMethod, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function deleteTrackSave(_x3, _x4) {
        return _deleteTrackSave.apply(this, arguments);
      }

      return deleteTrackSave;
    }()
  }, {
    key: "addPlaylistSave",
    value: function () {
      var _addPlaylistSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(userId, playlistId) {
        var nonce, chainId, contractAddress, signatureData, sig, contractMethod;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                nonce = signatureSchemas$2.getNonce();
                _context3.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context3.sent;
                _context3.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context3.sent;
                signatureData = signatureSchemas$2.generators.getPlaylistSaveRequestData(chainId, contractAddress, userId, playlistId, nonce);
                _context3.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context3.sent;
                _context3.next = 13;
                return this.getMethod('addPlaylistSave', userId, playlistId, nonce, sig);

              case 13:
                contractMethod = _context3.sent;
                return _context3.abrupt("return", this.web3Manager.sendTransaction(contractMethod, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function addPlaylistSave(_x5, _x6) {
        return _addPlaylistSave.apply(this, arguments);
      }

      return addPlaylistSave;
    }()
  }, {
    key: "deletePlaylistSave",
    value: function () {
      var _deletePlaylistSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(userId, playlistId) {
        var nonce, chainId, contractAddress, signatureData, sig, contractMethod;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                nonce = signatureSchemas$2.getNonce();
                _context4.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context4.sent;
                _context4.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context4.sent;
                signatureData = signatureSchemas$2.generators.getDeletePlaylistSaveRequestData(chainId, contractAddress, userId, playlistId, nonce);
                _context4.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context4.sent;
                _context4.next = 13;
                return this.getMethod('deletePlaylistSave', userId, playlistId, nonce, sig);

              case 13:
                contractMethod = _context4.sent;
                return _context4.abrupt("return", this.web3Manager.sendTransaction(contractMethod, this.contractRegistryKey, contractAddress));

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function deletePlaylistSave(_x7, _x8) {
        return _deletePlaylistSave.apply(this, arguments);
      }

      return deletePlaylistSave;
    }()
  }]);

  return UserLibraryFactoryClient;
}(ContractClient$2);

var userLibraryFactoryClient = UserLibraryFactoryClient$1;

var ContractClient$1 = require$$0.ContractClient;
var signatureSchemas$1 = signatureSchemas$7;
var sigUtil = sigUtil__default["default"];
var BufferSafe = safeBuffer.exports.Buffer;

var IPLDBlacklistFactoryClient$1 = /*#__PURE__*/function (_ContractClient) {
  _inherits(IPLDBlacklistFactoryClient, _ContractClient);

  var _super = _createSuper(IPLDBlacklistFactoryClient);

  function IPLDBlacklistFactoryClient() {
    _classCallCheck(this, IPLDBlacklistFactoryClient);

    return _super.apply(this, arguments);
  }

  _createClass(IPLDBlacklistFactoryClient, [{
    key: "addIPLDToBlacklist",
    value: function () {
      var _addIPLDToBlacklist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(multihashDigest) {
        var privateKey,
            _yield$this$getUpdate,
            _yield$this$getUpdate2,
            nonce,
            sig,
            method,
            receipt,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                privateKey = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                _context.next = 3;
                return this.getUpdateNonceAndSig(signatureSchemas$1.generators.addIPLDToBlacklistRequestData, multihashDigest, privateKey);

              case 3:
                _yield$this$getUpdate = _context.sent;
                _yield$this$getUpdate2 = _slicedToArray(_yield$this$getUpdate, 2);
                nonce = _yield$this$getUpdate2[0];
                sig = _yield$this$getUpdate2[1];
                _context.next = 9;
                return this.getMethod('addIPLDToBlacklist', multihashDigest, nonce, sig);

              case 9:
                method = _context.sent;
                _context.next = 12;
                return method.send({
                  from: this.web3Manager.getWalletAddress(),
                  gas: 200000
                });

              case 12:
                receipt = _context.sent;
                return _context.abrupt("return", receipt);

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function addIPLDToBlacklist(_x) {
        return _addIPLDToBlacklist.apply(this, arguments);
      }

      return addIPLDToBlacklist;
    }()
    /* ------- HELPERS ------- */

    /**
     * Gets a nonce and generates a signature for the given function. Private key is optional and
     * will use that private key to create the signature. Otherwise the web3Manager private key
     * will be used.
     * @param {Object} generatorFn signature scheme object function
     * @param {number} userId blockchain userId
     * @param {string} privateKey optional. if this is passed in, the signature will be from
     * this private key. the type is a 64 character hex string
     */

  }, {
    key: "getUpdateNonceAndSig",
    value: function () {
      var _getUpdateNonceAndSig = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(generatorFn, multihashDigest, privateKey) {
        var nonce, chainId, contractAddress, signatureData, sig;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                nonce = signatureSchemas$1.getNonce();
                _context2.next = 3;
                return this.getEthNetId();

              case 3:
                chainId = _context2.sent;
                _context2.next = 6;
                return this.getAddress();

              case 6:
                contractAddress = _context2.sent;
                signatureData = generatorFn(chainId, contractAddress, multihashDigest, nonce);

                if (!privateKey) {
                  _context2.next = 12;
                  break;
                }

                sig = sigUtil.signTypedData(BufferSafe.from(privateKey, 'hex'), {
                  data: signatureData
                });
                _context2.next = 15;
                break;

              case 12:
                _context2.next = 14;
                return this.web3Manager.signTypedData(signatureData);

              case 14:
                sig = _context2.sent;

              case 15:
                return _context2.abrupt("return", [nonce, sig]);

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getUpdateNonceAndSig(_x2, _x3, _x4) {
        return _getUpdateNonceAndSig.apply(this, arguments);
      }

      return getUpdateNonceAndSig;
    }()
  }]);

  return IPLDBlacklistFactoryClient;
}(ContractClient$1);

var IPLDBlacklistFactoryClient_1 = IPLDBlacklistFactoryClient$1;

var ContractClient = require$$0.ContractClient;
var signatureSchemas = signatureSchemas$7;

var UserReplicaSetManagerClient$1 = /*#__PURE__*/function (_ContractClient) {
  _inherits(UserReplicaSetManagerClient, _ContractClient);

  var _super = _createSuper(UserReplicaSetManagerClient);

  function UserReplicaSetManagerClient() {
    _classCallCheck(this, UserReplicaSetManagerClient);

    return _super.apply(this, arguments);
  }

  _createClass(UserReplicaSetManagerClient, [{
    key: "updateReplicaSet",
    value:
    /**
     * Update a user's replica set on the UserReplicaSetManager contract
     * Callable by user wallet, or any node within the user's replica set
     * @param {number} userId
     * @param {number} primary
     * @param {Array<number>} secondaries
     */
    function () {
      var _updateReplicaSet2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(userId, primary, secondaries) {
        var existingReplicaSetInfo;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getUserReplicaSet(userId);

              case 2:
                existingReplicaSetInfo = _context.sent;
                return _context.abrupt("return", this._updateReplicaSet(userId, primary, secondaries, existingReplicaSetInfo.primaryId, existingReplicaSetInfo.secondaryIds));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function updateReplicaSet(_x, _x2, _x3) {
        return _updateReplicaSet2.apply(this, arguments);
      }

      return updateReplicaSet;
    }()
    /**
     * Add a new content node to the L2 layer of the protocol
     * Requires signatures from 3 existing nodes on the UserReplicaSetManager contract
     * @param {number} cnodeId
     * @param {Array<string>} cnodeOwnerWallets - [0] = incoming delegateOwnerWallet, [1] = incoming ownerWallet
     * @param {Array<number>} proposerSpIds
     * @param {Array<string>} proposerNonces
     * @param {string} proposer1Sig
     * @param {string} proposer2Sig
     * @param {string} proposer3Sig
     */

  }, {
    key: "addOrUpdateContentNode",
    value: function () {
      var _addOrUpdateContentNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(cnodeId, cnodeOwnerWallets, proposerSpIds, proposerNonces, proposer1Sig, proposer2Sig, proposer3Sig) {
        var contractAddress, method, tx;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getAddress();

              case 2:
                contractAddress = _context2.sent;
                _context2.next = 5;
                return this.getMethod('addOrUpdateContentNode', cnodeId, cnodeOwnerWallets, proposerSpIds, proposerNonces, proposer1Sig, proposer2Sig, proposer3Sig);

              case 5:
                method = _context2.sent;
                _context2.next = 8;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 8:
                tx = _context2.sent;
                return _context2.abrupt("return", tx);

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function addOrUpdateContentNode(_x4, _x5, _x6, _x7, _x8, _x9, _x10) {
        return _addOrUpdateContentNode.apply(this, arguments);
      }

      return addOrUpdateContentNode;
    }()
    /**
     * Generate the relevant data required to propose a new content node
     * Each incoming node requires 3 distinct signatures in order to be added
     * This function will be used by content nodes
     * @param {number} cnodeId
     * @param {string} cnodeDelegateWallet
     * @param {number} proposerSpId
     */

  }, {
    key: "getProposeAddOrUpdateContentNodeRequestData",
    value: function () {
      var _getProposeAddOrUpdateContentNodeRequestData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(cnodeId, cnodeDelegateWallet, cnodeOwnerWallet, proposerSpId) {
        var chainId, contractAddress, nonce, signatureData, sig;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getEthNetId();

              case 2:
                chainId = _context3.sent;
                _context3.next = 5;
                return this.getAddress();

              case 5:
                contractAddress = _context3.sent;
                nonce = signatureSchemas.getNonce();
                signatureData = signatureSchemas.generators.getProposeAddOrUpdateContentNodeRequestData(chainId, contractAddress, cnodeId, cnodeDelegateWallet, cnodeOwnerWallet, proposerSpId, nonce);
                _context3.next = 10;
                return this.web3Manager.signTypedData(signatureData);

              case 10:
                sig = _context3.sent;
                return _context3.abrupt("return", {
                  nonce: nonce,
                  signatureData: signatureData,
                  sig: sig
                });

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getProposeAddOrUpdateContentNodeRequestData(_x11, _x12, _x13, _x14) {
        return _getProposeAddOrUpdateContentNodeRequestData.apply(this, arguments);
      }

      return getProposeAddOrUpdateContentNodeRequestData;
    }()
    /**
     * Returns replica set for requested user at requested blocknumber
     * @param {number} userId
     * @returns {Object} replica set info with schema { primaryId: int, secondaryIds: number[] }
     */

  }, {
    key: "getUserReplicaSet",
    value: function () {
      var _getUserReplicaSet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(userId) {
        var method, currentWallet, resp;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getMethod('getUserReplicaSet', userId);

              case 2:
                method = _context4.sent;
                currentWallet = this.web3Manager.getWalletAddress();
                _context4.next = 6;
                return method.call({
                  from: currentWallet
                });

              case 6:
                resp = _context4.sent;
                return _context4.abrupt("return", {
                  primaryId: parseInt(resp.primaryId),
                  secondaryIds: resp.secondaryIds.map(function (x) {
                    return parseInt(x);
                  })
                });

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getUserReplicaSet(_x15) {
        return _getUserReplicaSet.apply(this, arguments);
      }

      return getUserReplicaSet;
    }()
    /**
     * Returns replica set for requested user at requested blocknumber
     * @notice will error if web3 cannot find data for requested blocknumber
     * @returns {Object} replica set info with schema { primaryId: int, secondaryIds: int[] }
     */

  }, {
    key: "getUserReplicaSetAtBlockNumber",
    value: function () {
      var _getUserReplicaSetAtBlockNumber = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(userId, blockNumber) {
        var method, currentWallet, resp;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getMethod('getUserReplicaSet', userId);

              case 2:
                method = _context5.sent;
                currentWallet = this.web3Manager.getWalletAddress();
                _context5.next = 6;
                return method.call({
                  from: currentWallet
                }, blockNumber);

              case 6:
                resp = _context5.sent;
                return _context5.abrupt("return", {
                  primaryId: parseInt(resp.primaryId),
                  secondaryIds: resp.secondaryIds.map(function (x) {
                    return parseInt(x);
                  })
                });

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getUserReplicaSetAtBlockNumber(_x16, _x17) {
        return _getUserReplicaSetAtBlockNumber.apply(this, arguments);
      }

      return getUserReplicaSetAtBlockNumber;
    }()
    /**
     * Return the current ownerWallet and delegateOwnerWallet for a given spID
     * @param {number} userId
     */

  }, {
    key: "getContentNodeWallets",
    value: function () {
      var _getContentNodeWallets = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(spId) {
        var method, currentWallet;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getMethod('getContentNodeWallets', spId);

              case 2:
                method = _context6.sent;
                currentWallet = this.web3Manager.getWalletAddress();
                return _context6.abrupt("return", method.call({
                  from: currentWallet
                }));

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getContentNodeWallets(_x18) {
        return _getContentNodeWallets.apply(this, arguments);
      }

      return getContentNodeWallets;
    }()
    /**
     * Return boolean indicating status of URSM seed operation
     * Prior to seed, no replica sets can be written
     */

  }, {
    key: "getSeedComplete",
    value: function () {
      var _getSeedComplete = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var method, currentWallet;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getMethod('getSeedComplete');

              case 2:
                method = _context7.sent;
                currentWallet = this.web3Manager.getWalletAddress();
                return _context7.abrupt("return", method.call({
                  from: currentWallet
                }));

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getSeedComplete() {
        return _getSeedComplete.apply(this, arguments);
      }

      return getSeedComplete;
    }()
    /**
     * Submit update transaction to UserReplicaSetManager to modify a user's replica set
     * Can be sent by user's wallet, or any content node in the replica set
     * @param {number} userId
     * @param {number} primary
     * @param {Array<number>} secondaries
     * @param {number} oldPrimary
     * @param {Array<number>} oldSecondaries
     */

  }, {
    key: "_updateReplicaSet",
    value: function () {
      var _updateReplicaSet3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(userId, primary, secondaries, oldPrimary, oldSecondaries) {
        var contractAddress, nonce, chainId, web3, secondariesHash, oldSecondariesHash, signatureData, sig, method, tx;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getAddress();

              case 2:
                contractAddress = _context8.sent;
                nonce = signatureSchemas.getNonce();
                _context8.next = 6;
                return this.getEthNetId();

              case 6:
                chainId = _context8.sent;
                web3 = this.web3Manager.getWeb3();
                secondariesHash = web3.utils.soliditySha3(web3.eth.abi.encodeParameter('uint[]', secondaries));
                oldSecondariesHash = web3.utils.soliditySha3(web3.eth.abi.encodeParameter('uint[]', oldSecondaries));
                signatureData = signatureSchemas.generators.getUpdateReplicaSetRequestData(chainId, contractAddress, userId, primary, secondariesHash, oldPrimary, oldSecondariesHash, nonce);
                _context8.next = 13;
                return this.web3Manager.signTypedData(signatureData);

              case 13:
                sig = _context8.sent;
                _context8.next = 16;
                return this.getMethod('updateReplicaSet', userId, primary, secondaries, oldPrimary, oldSecondaries, nonce, sig);

              case 16:
                method = _context8.sent;
                _context8.next = 19;
                return this.web3Manager.sendTransaction(method, this.contractRegistryKey, contractAddress);

              case 19:
                tx = _context8.sent;
                return _context8.abrupt("return", tx);

              case 21:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _updateReplicaSet(_x19, _x20, _x21, _x22, _x23) {
        return _updateReplicaSet3.apply(this, arguments);
      }

      return _updateReplicaSet;
    }()
  }]);

  return UserReplicaSetManagerClient;
}(ContractClient);

var userReplicaSetManagerClient = UserReplicaSetManagerClient$1;

var Utils$7 = require$$18.Utils; // load classes wrapping contracts

var RegistryClient = registryClient;
var UserFactoryClient = userFactoryClient;
var TrackFactoryClient = trackFactoryClient;
var SocialFeatureFactoryClient = socialFeatureFactoryClient;
var PlaylistFactoryClient = playlistFactoryClient;
var UserLibraryFactoryClient = userLibraryFactoryClient;
var IPLDBlacklistFactoryClient = IPLDBlacklistFactoryClient_1;
var UserReplicaSetManagerClient = userReplicaSetManagerClient; // Make sure the json file exists before importing because it could silently fail
// import data contract ABI's

var RegistryABI = Utils$7.importDataContractABI('Registry.json').abi;
var UserFactoryABI = Utils$7.importDataContractABI('UserFactory.json').abi;
var TrackFactoryABI = Utils$7.importDataContractABI('TrackFactory.json').abi;
var SocialFeatureFactoryABI = Utils$7.importDataContractABI('SocialFeatureFactory.json').abi;
var PlaylistFactoryABI = Utils$7.importDataContractABI('PlaylistFactory.json').abi;
var UserLibraryFactoryABI = Utils$7.importDataContractABI('UserLibraryFactory.json').abi;
var IPLDBlacklistFactoryABI = Utils$7.importDataContractABI('IPLDBlacklistFactory.json').abi;
var UserReplicaSetManagerABI = Utils$7.importDataContractABI('UserReplicaSetManager.json').abi; // define contract registry keys

var UserFactoryRegistryKey = 'UserFactory';
var TrackFactoryRegistryKey = 'TrackFactory';
var SocialFeatureFactoryRegistryKey = 'SocialFeatureFactory';
var PlaylistFactoryRegistryKey = 'PlaylistFactory';
var UserLibraryFactoryRegistryKey = 'UserLibraryFactory';
var IPLDBlacklistFactoryRegistryKey = 'IPLDBlacklistFactory';
var UserReplicaSetManagerRegistryKey = 'UserReplicaSetManager';

var AudiusContracts = /*#__PURE__*/function () {
  function AudiusContracts(web3Manager, registryAddress, isServer) {
    var logger = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : console;

    _classCallCheck(this, AudiusContracts);

    this.web3Manager = web3Manager;
    this.registryAddress = registryAddress;
    this.isServer = isServer;
    this.logger = logger;
    this.RegistryClient = new RegistryClient(this.web3Manager, RegistryABI, this.registryAddress);
    this.getRegistryAddressForContract = this.getRegistryAddressForContract.bind(this);
    this.UserFactoryClient = new UserFactoryClient(this.web3Manager, UserFactoryABI, UserFactoryRegistryKey, this.getRegistryAddressForContract, this.logger);
    this.TrackFactoryClient = new TrackFactoryClient(this.web3Manager, TrackFactoryABI, TrackFactoryRegistryKey, this.getRegistryAddressForContract, this.logger);
    this.SocialFeatureFactoryClient = new SocialFeatureFactoryClient(this.web3Manager, SocialFeatureFactoryABI, SocialFeatureFactoryRegistryKey, this.getRegistryAddressForContract, this.logger);
    this.PlaylistFactoryClient = new PlaylistFactoryClient(this.web3Manager, PlaylistFactoryABI, PlaylistFactoryRegistryKey, this.getRegistryAddressForContract, this.logger);
    this.UserLibraryFactoryClient = new UserLibraryFactoryClient(this.web3Manager, UserLibraryFactoryABI, UserLibraryFactoryRegistryKey, this.getRegistryAddressForContract, this.logger);
    this.IPLDBlacklistFactoryClient = new IPLDBlacklistFactoryClient(this.web3Manager, IPLDBlacklistFactoryABI, IPLDBlacklistFactoryRegistryKey, this.getRegistryAddressForContract, this.logger);
    this.contractClients = [this.UserFactoryClient, this.TrackFactoryClient, this.SocialFeatureFactoryClient, this.PlaylistFactoryClient, this.UserLibraryFactoryClient, this.IPLDBlacklistFactoryClient];
  }

  _createClass(AudiusContracts, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.isServer) {
                  _context.next = 5;
                  break;
                }

                _context.next = 3;
                return Promise.all(this.contractClients.map(function (client) {
                  return client.init();
                }));

              case 3:
                _context.next = 5;
                return this.initUserReplicaSetManagerClient();

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }() // Special case initialization flow for UserReplicaSetManagerClient backwards compatibility
    // Until the contract is deployed and added to the data contract registry, replica set
    // operations will flow through the existing UserFactory

  }, {
    key: "initUserReplicaSetManagerClient",
    value: function () {
      var _initUserReplicaSetManagerClient = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var selectNewEndpointOnRetry,
            seedComplete,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                selectNewEndpointOnRetry = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : false;
                _context2.prev = 1;

                if (!(this.UserReplicaSetManagerClient && this.UserReplicaSetManagerClient._contractAddress !== '0x0000000000000000000000000000000000000000')) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt("return");

              case 4:
                this.UserReplicaSetManagerClient = new UserReplicaSetManagerClient(this.web3Manager, UserReplicaSetManagerABI, UserReplicaSetManagerRegistryKey, this.getRegistryAddressForContract, this.logger);
                _context2.next = 7;
                return this.UserReplicaSetManagerClient.init(selectNewEndpointOnRetry);

              case 7:
                if (!(this.UserReplicaSetManagerClient._contractAddress === '0x0000000000000000000000000000000000000000')) {
                  _context2.next = 9;
                  break;
                }

                throw new Error("Failed retrieve address for ".concat(this.UserReplicaSetManagerClient.contractRegistryKey));

              case 9:
                _context2.next = 11;
                return this.UserReplicaSetManagerClient.getSeedComplete();

              case 11:
                seedComplete = _context2.sent;

                if (seedComplete) {
                  _context2.next = 14;
                  break;
                }

                throw new Error('UserReplicaSetManager pending seed operation');

              case 14:
                _context2.next = 20;
                break;

              case 16:
                _context2.prev = 16;
                _context2.t0 = _context2["catch"](1);
                // Nullify failed attempt to initialize
                console.log("Failed to initialize UserReplicaSetManagerClient with error ".concat(_context2.t0.message));
                this.UserReplicaSetManagerClient = null;

              case 20:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 16]]);
      }));

      function initUserReplicaSetManagerClient() {
        return _initUserReplicaSetManagerClient.apply(this, arguments);
      }

      return initUserReplicaSetManagerClient;
    }()
    /* ------- CONTRACT META-FUNCTIONS ------- */

    /**
     * Retrieves contract address from Registry by key, caching previously retrieved data.
     * Refreshes cache if cached value is empty or zero address.
     * Value is empty during first time call, and zero if call is made before contract is deployed,
     *    since Registry sets default value of all contract keys to zero address if not registered.
     * @param {string} contractName registry key of contract
     */

  }, {
    key: "getRegistryAddressForContract",
    value: function () {
      var _getRegistryAddressForContract = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(contractName) {
        var address;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names
                this.contracts = this.contracts || _defineProperty({}, this.registryAddress, 'registry');
                this.contractAddresses = this.contractAddresses || {
                  registry: this.registryAddress
                };

                if (!(!this.contractAddresses[contractName] || Utils$7.isZeroAddress(this.contractAddresses[contractName]))) {
                  _context3.next = 8;
                  break;
                }

                _context3.next = 5;
                return this.RegistryClient.getContract(contractName);

              case 5:
                address = _context3.sent;
                this.contracts[address] = contractName;
                this.contractAddresses[contractName] = address;

              case 8:
                return _context3.abrupt("return", this.contractAddresses[contractName]);

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getRegistryAddressForContract(_x) {
        return _getRegistryAddressForContract.apply(this, arguments);
      }

      return getRegistryAddressForContract;
    }()
  }, {
    key: "getRegistryContractForAddress",
    value: function () {
      var _getRegistryContractForAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(address) {
        var contractRegistryKey;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this.contracts) {
                  _context4.next = 2;
                  break;
                }

                throw new Error('No contracts found. Have you called init() yet?');

              case 2:
                contractRegistryKey = this.contracts[address];

                if (contractRegistryKey) {
                  _context4.next = 5;
                  break;
                }

                throw new Error("No registry contract found for contract address ".concat(address));

              case 5:
                return _context4.abrupt("return", contractRegistryKey);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getRegistryContractForAddress(_x2) {
        return _getRegistryContractForAddress.apply(this, arguments);
      }

      return getRegistryContractForAddress;
    }()
  }]);

  return AudiusContracts;
}();

var dataContracts = AudiusContracts;

var getTrackListens = function getTrackListens() {
  var timeFrame = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var idsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var startTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var endTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var limit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var offset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
  var queryUrl = 'tracks/listens/';

  if (timeFrame != null) {
    switch (timeFrame) {
      case 'day':
      case 'week':
      case 'month':
      case 'year':
      case 'millennium':
        break;

      default:
        throw new Error('Invalid timeFrame value provided');
    }

    queryUrl += timeFrame;
  }

  var queryParams = {};

  if (idsArray !== null) {
    queryParams.id = idsArray;
  }

  if (limit !== null) {
    queryParams.limit = limit;
  }

  if (offset !== null) {
    queryParams.offset = offset;
  }

  if (startTime != null) {
    queryParams.start = startTime;
  }

  if (endTime != null) {
    queryParams.end = endTime;
  }

  var req = {
    url: queryUrl,
    method: 'get',
    params: queryParams
  };
  return req;
};

var RELAY_CAPTCHA_SAMPLE_RATE = 0.5;
var IdentityService = /*#__PURE__*/function () {
  function IdentityService(identityServiceEndpoint, captcha) {
    _classCallCheck(this, IdentityService);

    this.identityServiceEndpoint = identityServiceEndpoint;
    this.captcha = captcha;
    this.web3Manager = null;
  }

  _createClass(IdentityService, [{
    key: "setWeb3Manager",
    value: function setWeb3Manager(web3Manager) {
      this.web3Manager = web3Manager;
    }
    /* ------- HEDGEHOG AUTH ------- */

  }, {
    key: "getFn",
    value: function () {
      var _getFn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(params) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._makeRequest({
                  url: '/authentication',
                  method: 'get',
                  params: params
                });

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getFn(_x) {
        return _getFn.apply(this, arguments);
      }

      return getFn;
    }()
  }, {
    key: "setAuthFn",
    value: function () {
      var _setAuthFn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(obj) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._makeRequest({
                  url: '/authentication',
                  method: 'post',
                  data: obj
                });

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setAuthFn(_x2) {
        return _setAuthFn.apply(this, arguments);
      }

      return setAuthFn;
    }()
  }, {
    key: "setUserFn",
    value: function () {
      var _setUserFn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(obj) {
        var token;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.captcha) {
                  _context3.next = 11;
                  break;
                }

                _context3.prev = 1;
                _context3.next = 4;
                return this.captcha.generate('identity/user');

              case 4:
                token = _context3.sent;
                obj.token = token;
                _context3.next = 11;
                break;

              case 8:
                _context3.prev = 8;
                _context3.t0 = _context3["catch"](1);
                console.warn('CAPTCHA (user) - Recaptcha failed to generate token in :', _context3.t0);

              case 11:
                _context3.next = 13;
                return this._makeRequest({
                  url: '/user',
                  method: 'post',
                  data: obj
                });

              case 13:
                return _context3.abrupt("return", _context3.sent);

              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[1, 8]]);
      }));

      function setUserFn(_x3) {
        return _setUserFn.apply(this, arguments);
      }

      return setUserFn;
    }()
  }, {
    key: "getUserEvents",
    value: function () {
      var _getUserEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(walletAddress) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._makeRequest({
                  url: '/userEvents',
                  method: 'get',
                  params: {
                    walletAddress: walletAddress
                  }
                });

              case 2:
                return _context4.abrupt("return", _context4.sent);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getUserEvents(_x4) {
        return _getUserEvents.apply(this, arguments);
      }

      return getUserEvents;
    }()
  }, {
    key: "sendRecoveryInfo",
    value: function () {
      var _sendRecoveryInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(obj) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._makeRequest({
                  url: '/recovery',
                  method: 'post',
                  data: obj
                });

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function sendRecoveryInfo(_x5) {
        return _sendRecoveryInfo.apply(this, arguments);
      }

      return sendRecoveryInfo;
    }()
    /**
     * Check if an email address has been previously registered.
     */

  }, {
    key: "checkIfEmailRegistered",
    value: function () {
      var _checkIfEmailRegistered = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(email) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._makeRequest({
                  url: '/users/check',
                  method: 'get',
                  params: {
                    email: email
                  }
                });

              case 2:
                return _context6.abrupt("return", _context6.sent);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function checkIfEmailRegistered(_x6) {
        return _checkIfEmailRegistered.apply(this, arguments);
      }

      return checkIfEmailRegistered;
    }()
  }, {
    key: "getUserEmail",
    value: function () {
      var _getUserEmail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var headers;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._signData();

              case 2:
                headers = _context7.sent;

                if (!(headers[AuthHeaders$1.MESSAGE] && headers[AuthHeaders$1.SIGNATURE])) {
                  _context7.next = 9;
                  break;
                }

                _context7.next = 6;
                return this._makeRequest({
                  url: '/user/email',
                  method: 'get',
                  headers: headers
                });

              case 6:
                return _context7.abrupt("return", _context7.sent);

              case 9:
                throw new Error('Cannot get user email - user is not authenticated');

              case 10:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getUserEmail() {
        return _getUserEmail.apply(this, arguments);
      }

      return getUserEmail;
    }()
    /**
     * Associates a user with a twitter uuid.
     * @param uuid from the Twitter API
     * @param userId
     * @param handle User handle
     */

  }, {
    key: "associateTwitterUser",
    value: function () {
      var _associateTwitterUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(uuid, userId, handle) {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._makeRequest({
                  url: '/twitter/associate',
                  method: 'post',
                  data: {
                    uuid: uuid,
                    userId: userId,
                    handle: handle
                  }
                });

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function associateTwitterUser(_x7, _x8, _x9) {
        return _associateTwitterUser.apply(this, arguments);
      }

      return associateTwitterUser;
    }()
    /**
     * Associates a user with an instagram uuid.
     * @param uuid from the Instagram API
     * @param userId
     * @param handle
     */

  }, {
    key: "associateInstagramUser",
    value: function () {
      var _associateInstagramUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(uuid, userId, handle) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._makeRequest({
                  url: '/instagram/associate',
                  method: 'post',
                  data: {
                    uuid: uuid,
                    userId: userId,
                    handle: handle
                  }
                });

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function associateInstagramUser(_x10, _x11, _x12) {
        return _associateInstagramUser.apply(this, arguments);
      }

      return associateInstagramUser;
    }()
    /**
     * Logs a track listen for a given user id.
     * @param trackId
     * @param userId
     * @param listenerAddress if logging this listen on behalf of another IP address, pass through here
     * @param signatureData if logging this listen via a 3p service, a signed piece of data proving authenticity
     */

  }, {
    key: "logTrackListen",
    value: function () {
      var _logTrackListen = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(trackId, userId, listenerAddress, signatureData) {
        var solanaListen,
            data,
            request,
            _args10 = arguments;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                solanaListen = _args10.length > 4 && _args10[4] !== undefined ? _args10[4] : false;
                data = {
                  userId: userId,
                  solanaListen: solanaListen
                };

                if (signatureData) {
                  data.signature = signatureData.signature;
                  data.timestamp = signatureData.timestamp;
                }

                request = {
                  url: "/tracks/".concat(trackId, "/listen"),
                  method: 'post',
                  data: data
                };

                if (listenerAddress) {
                  request.headers = {
                    'x-forwarded-for': listenerAddress
                  };
                }

                _context10.next = 7;
                return this._makeRequest(request);

              case 7:
                return _context10.abrupt("return", _context10.sent);

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function logTrackListen(_x13, _x14, _x15, _x16) {
        return _logTrackListen.apply(this, arguments);
      }

      return logTrackListen;
    }()
    /**
     * Return listen history tracks for a given user id.
     * @param userId - User ID
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getListenHistoryTracks",
    value: function () {
      var _getListenHistoryTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(userId) {
        var limit,
            offset,
            req,
            _args11 = arguments;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                limit = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : 100;
                offset = _args11.length > 2 && _args11[2] !== undefined ? _args11[2] : 0;
                req = {
                  method: 'get',
                  url: '/tracks/history',
                  params: {
                    userId: userId,
                    limit: limit,
                    offset: offset
                  }
                };
                _context11.next = 5;
                return this._makeRequest(req);

              case 5:
                return _context11.abrupt("return", _context11.sent);

              case 6:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getListenHistoryTracks(_x17) {
        return _getListenHistoryTracks.apply(this, arguments);
      }

      return getListenHistoryTracks;
    }()
    /**
     * Looks up a Twitter account by handle.
     * @returns twitter API response.
     */

  }, {
    key: "lookupTwitterHandle",
    value: function () {
      var _lookupTwitterHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(handle) {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (!handle) {
                  _context12.next = 6;
                  break;
                }

                _context12.next = 3;
                return this._makeRequest({
                  url: '/twitter/handle_lookup',
                  method: 'get',
                  params: {
                    handle: handle
                  }
                });

              case 3:
                return _context12.abrupt("return", _context12.sent);

              case 6:
                throw new Error('No handle passed into function lookupTwitterHandle');

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function lookupTwitterHandle(_x18) {
        return _lookupTwitterHandle.apply(this, arguments);
      }

      return lookupTwitterHandle;
    }()
    /**
     * Gets tracks trending on Audius.
     * @param timeFrame one of day, week, month, or year
     * @param idsArray track ids
     * @param limit
     * @param offset
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var timeFrame,
            idsArray,
            limit,
            offset,
            queryUrl,
            queryParams,
            _args13 = arguments;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                timeFrame = _args13.length > 0 && _args13[0] !== undefined ? _args13[0] : null;
                idsArray = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : null;
                limit = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : null;
                offset = _args13.length > 3 && _args13[3] !== undefined ? _args13[3] : null;
                queryUrl = '/tracks/trending/';

                if (!(timeFrame != null)) {
                  _context13.next = 12;
                  break;
                }

                _context13.t0 = timeFrame;
                _context13.next = _context13.t0 === 'day' ? 9 : _context13.t0 === 'week' ? 9 : _context13.t0 === 'month' ? 9 : _context13.t0 === 'year' ? 9 : 10;
                break;

              case 9:
                return _context13.abrupt("break", 11);

              case 10:
                throw new Error('Invalid timeFrame value provided');

              case 11:
                queryUrl += timeFrame;

              case 12:
                queryParams = {};

                if (idsArray !== null) {
                  queryParams.id = idsArray;
                }

                if (limit !== null) {
                  queryParams.limit = limit;
                }

                if (offset !== null) {
                  queryParams.offset = offset;
                }

                _context13.next = 18;
                return this._makeRequest({
                  url: queryUrl,
                  method: 'get',
                  params: queryParams
                });

              case 18:
                return _context13.abrupt("return", _context13.sent);

              case 19:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getTrendingTracks() {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks;
    }()
    /**
     * Gets listens for tracks bucketted by timeFrame.
     * @param timeFrame one of day, week, month, or year
     * @param idsArray track ids
     * @param startTime parseable by Date.parse
     * @param endTime parseable by Date.parse
     * @param limit
     * @param offset
     */

  }, {
    key: "getTrackListens",
    value: function () {
      var _getTrackListens2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var timeFrame,
            idsArray,
            startTime,
            endTime,
            limit,
            offset,
            req,
            _args14 = arguments;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                timeFrame = _args14.length > 0 && _args14[0] !== undefined ? _args14[0] : null;
                idsArray = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : null;
                startTime = _args14.length > 2 && _args14[2] !== undefined ? _args14[2] : null;
                endTime = _args14.length > 3 && _args14[3] !== undefined ? _args14[3] : null;
                limit = _args14.length > 4 && _args14[4] !== undefined ? _args14[4] : null;
                offset = _args14.length > 5 && _args14[5] !== undefined ? _args14[5] : null;
                req = getTrackListens(timeFrame, idsArray, startTime, endTime, limit, offset);
                _context14.next = 9;
                return this._makeRequest(req);

              case 9:
                return _context14.abrupt("return", _context14.sent);

              case 10:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getTrackListens$1() {
        return _getTrackListens2.apply(this, arguments);
      }

      return getTrackListens$1;
    }()
  }, {
    key: "createUserRecord",
    value: function () {
      var _createUserRecord = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(email, walletAddress) {
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this._makeRequest({
                  url: '/user',
                  method: 'post',
                  data: {
                    username: email,
                    walletAddress: walletAddress
                  }
                });

              case 2:
                return _context15.abrupt("return", _context15.sent);

              case 3:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function createUserRecord(_x19, _x20) {
        return _createUserRecord.apply(this, arguments);
      }

      return createUserRecord;
    }()
  }, {
    key: "relay",
    value: function () {
      var _relay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(contractRegistryKey, contractAddress, senderAddress, encodedABI, gasLimit) {
        var shouldCaptcha, token;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                shouldCaptcha = Math.random() < RELAY_CAPTCHA_SAMPLE_RATE;

                if (!(this.captcha && shouldCaptcha)) {
                  _context16.next = 11;
                  break;
                }

                _context16.prev = 2;
                _context16.next = 5;
                return this.captcha.generate('identity/relay');

              case 5:
                token = _context16.sent;
                _context16.next = 11;
                break;

              case 8:
                _context16.prev = 8;
                _context16.t0 = _context16["catch"](2);
                console.warn('CAPTCHA (relay) - Recaptcha failed to generate token:', _context16.t0);

              case 11:
                _context16.next = 13;
                return this._makeRequest({
                  url: '/relay',
                  method: 'post',
                  data: {
                    contractRegistryKey: contractRegistryKey,
                    contractAddress: contractAddress,
                    senderAddress: senderAddress,
                    encodedABI: encodedABI,
                    gasLimit: gasLimit,
                    token: token
                  }
                });

              case 13:
                return _context16.abrupt("return", _context16.sent);

              case 14:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this, [[2, 8]]);
      }));

      function relay(_x21, _x22, _x23, _x24, _x25) {
        return _relay.apply(this, arguments);
      }

      return relay;
    }()
  }, {
    key: "ethRelay",
    value: function () {
      var _ethRelay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(contractAddress, senderAddress, encodedABI, gasLimit) {
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this._makeRequest({
                  url: '/eth_relay',
                  method: 'post',
                  data: {
                    contractAddress: contractAddress,
                    senderAddress: senderAddress,
                    encodedABI: encodedABI,
                    gasLimit: gasLimit
                  }
                });

              case 2:
                return _context17.abrupt("return", _context17.sent);

              case 3:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function ethRelay(_x26, _x27, _x28, _x29) {
        return _ethRelay.apply(this, arguments);
      }

      return ethRelay;
    }()
  }, {
    key: "wormholeRelay",
    value: function () {
      var _wormholeRelay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(_ref) {
        var senderAddress, permit, transferTokens;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                senderAddress = _ref.senderAddress, permit = _ref.permit, transferTokens = _ref.transferTokens;
                _context18.next = 3;
                return this._makeRequest({
                  url: '/wormhole_relay',
                  method: 'post',
                  data: {
                    senderAddress: senderAddress,
                    permit: permit,
                    transferTokens: transferTokens
                  }
                });

              case 3:
                return _context18.abrupt("return", _context18.sent);

              case 4:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function wormholeRelay(_x30) {
        return _wormholeRelay.apply(this, arguments);
      }

      return wormholeRelay;
    }()
    /**
     * Gets the correct wallet that will relay a txn for `senderAddress`
     * @param senderAddress wallet
     */

  }, {
    key: "getEthRelayer",
    value: function () {
      var _getEthRelayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(senderAddress) {
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this._makeRequest({
                  url: '/eth_relayer',
                  method: 'get',
                  params: {
                    wallet: senderAddress
                  }
                });

              case 2:
                return _context19.abrupt("return", _context19.sent);

              case 3:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getEthRelayer(_x31) {
        return _getEthRelayer.apply(this, arguments);
      }

      return getEthRelayer;
    }()
  }, {
    key: "getRandomFeePayer",
    value: function () {
      var _getRandomFeePayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this._makeRequest({
                  url: '/solana/random_fee_payer',
                  method: 'get',
                  headers: {
                    'Content-Type': 'application/json'
                  }
                });

              case 2:
                return _context20.abrupt("return", _context20.sent);

              case 3:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getRandomFeePayer() {
        return _getRandomFeePayer.apply(this, arguments);
      }

      return getRandomFeePayer;
    }() // Relays tx data through the solana relay endpoint

  }, {
    key: "solanaRelay",
    value: function () {
      var _solanaRelay = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(transactionData) {
        var headers;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this._signData();

              case 2:
                headers = _context21.sent;
                _context21.next = 5;
                return this._makeRequest({
                  url: '/solana/relay',
                  method: 'post',
                  data: transactionData,
                  headers: headers
                });

              case 5:
                return _context21.abrupt("return", _context21.sent);

              case 6:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function solanaRelay(_x32) {
        return _solanaRelay.apply(this, arguments);
      }

      return solanaRelay;
    }()
  }, {
    key: "solanaRelayRaw",
    value: function () {
      var _solanaRelayRaw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(transactionData) {
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this._makeRequest({
                  url: '/solana/relay/raw',
                  method: 'post',
                  data: transactionData
                });

              case 2:
                return _context22.abrupt("return", _context22.sent);

              case 3:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function solanaRelayRaw(_x33) {
        return _solanaRelayRaw.apply(this, arguments);
      }

      return solanaRelayRaw;
    }()
  }, {
    key: "getMinimumDelegationAmount",
    value: function () {
      var _getMinimumDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(wallet) {
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this._makeRequest({
                  url: "/protocol/".concat(wallet, "/delegation/minimum"),
                  method: 'get'
                });

              case 2:
                return _context23.abrupt("return", _context23.sent);

              case 3:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getMinimumDelegationAmount(_x34) {
        return _getMinimumDelegationAmount.apply(this, arguments);
      }

      return getMinimumDelegationAmount;
    }()
  }, {
    key: "updateMinimumDelegationAmount",
    value: function () {
      var _updateMinimumDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(wallet, minimumDelegationAmount, signedData) {
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this._makeRequest({
                  url: "/protocol/".concat(wallet, "/delegation/minimum"),
                  method: 'post',
                  headers: signedData,
                  data: {
                    minimumDelegationAmount: minimumDelegationAmount
                  }
                });

              case 2:
                return _context24.abrupt("return", _context24.sent);

              case 3:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function updateMinimumDelegationAmount(_x35, _x36, _x37) {
        return _updateMinimumDelegationAmount.apply(this, arguments);
      }

      return updateMinimumDelegationAmount;
    }()
    /**
     * Sends an attestation result to identity.
     *
     */

  }, {
    key: "sendAttestationResult",
    value: function () {
      var _sendAttestationResult = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(data) {
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this._makeRequest({
                  url: '/rewards/attestation_result',
                  method: 'post',
                  data: data
                });

              case 2:
                return _context25.abrupt("return", _context25.sent);

              case 3:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function sendAttestationResult(_x38) {
        return _sendAttestationResult.apply(this, arguments);
      }

      return sendAttestationResult;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

  }, {
    key: "_makeRequest",
    value: function () {
      var _makeRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(axiosRequestObj) {
        var requestId, resp, _error$response, _error$response$data, error;

        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                axiosRequestObj.baseURL = this.identityServiceEndpoint;
                requestId = uuid();
                axiosRequestObj.headers = _objectSpread2(_objectSpread2({}, axiosRequestObj.headers || {}), {}, {
                  'X-Request-ID': requestId
                }); // Axios throws for non-200 responses

                _context26.prev = 3;
                _context26.next = 6;
                return axios__default["default"](axiosRequestObj);

              case 6:
                resp = _context26.sent;

                if (resp.data) {
                  _context26.next = 9;
                  break;
                }

                throw new Error("Identity response missing data field for url: ".concat(axiosRequestObj.url, ", req-id: ").concat(requestId));

              case 9:
                return _context26.abrupt("return", resp.data);

              case 12:
                _context26.prev = 12;
                _context26.t0 = _context26["catch"](3);
                error = _context26.t0;

                if ((_error$response = error.response) !== null && _error$response !== void 0 && (_error$response$data = _error$response.data) !== null && _error$response$data !== void 0 && _error$response$data.error) {
                  console.error("Server returned error for requestId ".concat(requestId, ": [").concat(error.response.status.toString(), "] ").concat(error.response.data.error));
                }

                throw error;

              case 17:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this, [[3, 12]]);
      }));

      function _makeRequest(_x39) {
        return _makeRequest2.apply(this, arguments);
      }

      return _makeRequest;
    }()
  }, {
    key: "_signData",
    value: function () {
      var _signData2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27() {
        var _this$web3Manager, _ref2, unixTs, message, signature;

        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (!this.web3Manager) {
                  _context27.next = 9;
                  break;
                }

                unixTs = Math.round(new Date().getTime() / 1000); // current unix timestamp (sec)

                message = "Click sign to authenticate with identity service: ".concat(unixTs);
                _context27.next = 5;
                return (_this$web3Manager = this.web3Manager) === null || _this$web3Manager === void 0 ? void 0 : _this$web3Manager.sign(message);

              case 5:
                signature = _context27.sent;
                return _context27.abrupt("return", (_ref2 = {}, _defineProperty(_ref2, AuthHeaders$1.MESSAGE, message), _defineProperty(_ref2, AuthHeaders$1.SIGNATURE, signature), _ref2));

              case 9:
                return _context27.abrupt("return", {});

              case 10:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function _signData() {
        return _signData2.apply(this, arguments);
      }

      return _signData;
    }()
  }]);

  return IdentityService;
}();

var identity = /*#__PURE__*/Object.freeze({
  __proto__: null,
  IdentityService: IdentityService
});

var require$$7 = /*@__PURE__*/getAugmentedNamespace(identity);

var Comstock = /*#__PURE__*/function () {
  function Comstock(comstockEndpoint) {
    _classCallCheck(this, Comstock);

    this.comstockEndpoint = comstockEndpoint;
  }

  _createClass(Comstock, [{
    key: "getComstock",
    value: function () {
      var _getComstock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(obj) {
        var result;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._makeRequest({
                  url: '/wallet_lookup',
                  method: 'get',
                  params: obj
                });

              case 2:
                result = _context.sent;
                return _context.abrupt("return", result);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getComstock(_x) {
        return _getComstock.apply(this, arguments);
      }

      return getComstock;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

  }, {
    key: "_makeRequest",
    value: function () {
      var _makeRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(axiosRequestObj) {
        var resp, _error$response, _error$response$data, error;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                axiosRequestObj.baseURL = this.comstockEndpoint; // Axios throws for non-200 responses

                _context2.prev = 1;
                _context2.next = 4;
                return axios__default["default"](axiosRequestObj);

              case 4:
                resp = _context2.sent;
                return _context2.abrupt("return", resp.data);

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](1);
                error = _context2.t0;

                if (!((_error$response = error.response) !== null && _error$response !== void 0 && (_error$response$data = _error$response.data) !== null && _error$response$data !== void 0 && _error$response$data.error)) {
                  _context2.next = 13;
                  break;
                }

                throw new Error("Server returned error: [".concat(error.response.status.toString(), "] ").concat(error.response.data.error));

              case 13:
                throw error;

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 8]]);
      }));

      function _makeRequest(_x2) {
        return _makeRequest2.apply(this, arguments);
      }

      return _makeRequest;
    }()
  }]);

  return Comstock;
}();

var comstock = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Comstock: Comstock
});

var require$$8 = /*@__PURE__*/getAugmentedNamespace(comstock);

var Hedgehog = /*#__PURE__*/_createClass( // TODO - update this comment
// This is some black magic going on here. The audiusServiceEndpoint is passed in along with the
// requestToAudiusService function reference. When setFn and getFn call self.requestToAudiusService,
// the context of `this` that's used is the HedgehogWrapper class, not the AudiusWeb3 class.
// Therefore, we need to define this.audiusServiceEndpoint, to satisfy all the deps of the
// requestToAudiusService and make it execute correctly
function Hedgehog(identityService) {
  var _this = this;

  var useLocalStorage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  _classCallCheck(this, Hedgehog);

  this.identityService = identityService;

  this.getFn = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(obj) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.identityService.getFn(obj);

            case 2:
              return _context.abrupt("return", _context.sent);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();

  this.setAuthFn = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(obj) {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _this.identityService.setAuthFn(obj);

            case 2:
              return _context2.abrupt("return", _context2.sent);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }();

  this.setUserFn = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(obj) {
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return _this.identityService.setUserFn(obj);

            case 2:
              return _context3.abrupt("return", _context3.sent);

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x3) {
      return _ref3.apply(this, arguments);
    };
  }();

  var hedgehog = new hedgehog$1.Hedgehog(this.getFn, this.setAuthFn, this.setUserFn, useLocalStorage); // we override the login function here because getFn needs both lookupKey and email
  // in identity service, but hedgehog only sends lookupKey

  hedgehog.login = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(email, password) {
      var lookupKey, data, _yield$WalletManager$, walletObj, entropy;

      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return hedgehog$1.WalletManager.createAuthLookupKey(email, password);

            case 2:
              lookupKey = _context4.sent;
              _context4.next = 5;
              return _this.getFn({
                lookupKey: lookupKey,
                username: email
              });

            case 5:
              data = _context4.sent;

              if (!(data !== null && data !== void 0 && data.iv && data.cipherText)) {
                _context4.next = 17;
                break;
              }

              _context4.next = 9;
              return hedgehog$1.WalletManager.decryptCipherTextAndRetrieveWallet(password, data.iv, data.cipherText);

            case 9:
              _yield$WalletManager$ = _context4.sent;
              walletObj = _yield$WalletManager$.walletObj;
              entropy = _yield$WalletManager$.entropy;
              // set wallet property on the class
              hedgehog.wallet = walletObj; // set entropy in localStorage

              hedgehog$1.WalletManager.setEntropyInLocalStorage(entropy);
              return _context4.abrupt("return", walletObj);

            case 17:
              throw new Error('No account record for user');

            case 18:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function (_x4, _x5) {
      return _ref4.apply(this, arguments);
    };
  }();
  /**
   * Generate secure credentials to allow login
   * @param username username
   */


  hedgehog.generateRecoveryInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
    var entropy, btoa, currentHost, recoveryInfo;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return hedgehog$1.WalletManager.getEntropyFromLocalStorage();

          case 2:
            entropy = _context5.sent;

            if (!(entropy === null)) {
              _context5.next = 5;
              break;
            }

            throw new Error('generateRecoveryLink - missing entropy');

          case 5:
            if (typeof window !== 'undefined' && window && window.btoa) {
              btoa = window.btoa;
              currentHost = window.location.origin;
            } else {
              btoa = function btoa(str) {
                return Buffer.from(str, 'binary').toString('base64');
              };

              currentHost = 'localhost';
            }

            recoveryInfo = {
              login: btoa(entropy),
              host: currentHost
            };
            return _context5.abrupt("return", recoveryInfo);

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return hedgehog;
});

var hedgehog = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Hedgehog: Hedgehog
});

var require$$9 = /*@__PURE__*/getAugmentedNamespace(hedgehog);

var $schema$1 = "http://json-schema.org/draft-07/schema#";
var $ref$1 = "#/definitions/Track";
var definitions$1 = {
	Track: {
		type: "object",
		additionalProperties: true,
		$comment: "Additional properties enabled because the data return by discovery providers may contain other properties like blockhash, is_current, which are not strictly part of the metadata.",
		properties: {
			title: {
				type: "string",
				"default": null
			},
			length: {
				type: [
					"integer",
					"null"
				],
				"default": null
			},
			cover_art: {
				type: [
					"string",
					"null"
				],
				"default": null,
				$ref: "#/definitions/CID"
			},
			cover_art_sizes: {
				$comment: "type can be null if attached as a stem",
				type: [
					"string",
					"null"
				],
				"default": null,
				$ref: "#/definitions/CID"
			},
			tags: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			genre: {
				$comment: "genre can be null if attached as a stem",
				type: [
					"string",
					"null"
				],
				"default": null
			},
			mood: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			credits_splits: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			create_date: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			release_date: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			file_type: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			description: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			license: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			isrc: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			iswc: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			track_segments: {
				type: "array",
				minItems: 1,
				items: {
					$ref: "#/definitions/TrackSegment"
				},
				"default": [
				],
				$comment: "default set to empty array to unblock stalling indexing. if set to null, discprov db will reject because of not-NULL constraint"
			},
			is_unlisted: {
				type: "boolean",
				"default": false
			},
			field_visibility: {
				type: "object",
				$ref: "#/definitions/FieldVisibility",
				"default": {
					mood: true,
					tags: true,
					genre: true,
					share: true,
					play_count: true,
					remixes: true
				}
			},
			download: {
				type: [
					"object",
					"null"
				],
				$ref: "#/definitions/Download",
				"default": {
					cid: null,
					is_downloadable: false,
					requires_follow: false
				}
			},
			stem_of: {
				type: [
					"object",
					"null"
				],
				$ref: "#/definitions/StemOf",
				"default": null
			},
			remix_of: {
				type: [
					"object",
					"null"
				],
				$ref: "#/definitions/RemixOf",
				"default": null
			}
		},
		required: [
			"cover_art",
			"cover_art_sizes",
			"create_date",
			"credits_splits",
			"description",
			"download",
			"field_visibility",
			"file_type",
			"genre",
			"is_unlisted",
			"isrc",
			"iswc",
			"length",
			"license",
			"mood",
			"release_date",
			"remix_of",
			"stem_of",
			"tags",
			"title",
			"track_segments"
		],
		title: "Track"
	},
	RemixOf: {
		type: [
			"object",
			"null"
		],
		additionalProperties: false,
		properties: {
			tracks: {
				type: "array",
				minItems: 1,
				items: {
					$ref: "#/definitions/TrackElement"
				}
			}
		},
		required: [
			"tracks"
		],
		title: "RemixOf"
	},
	TrackElement: {
		type: "object",
		additionalProperties: false,
		properties: {
			parent_track_id: {
				type: "integer"
			}
		},
		required: [
			"parent_track_id"
		],
		title: "TrackElement"
	},
	Download: {
		type: [
			"object",
			"null"
		],
		additionalProperties: false,
		properties: {
			cid: {
				type: [
					"string",
					"null"
				],
				$ref: "#/definitions/CID"
			},
			is_downloadable: {
				type: "boolean"
			},
			requires_follow: {
				type: "boolean"
			}
		},
		required: [
			"cid",
			"is_downloadable",
			"requires_follow"
		],
		title: "Download"
	},
	FieldVisibility: {
		type: "object",
		additionalProperties: false,
		properties: {
			mood: {
				type: "boolean"
			},
			tags: {
				type: "boolean"
			},
			genre: {
				type: "boolean"
			},
			share: {
				type: "boolean"
			},
			play_count: {
				type: "boolean"
			},
			remixes: {
				type: "boolean"
			}
		},
		required: [
		],
		$comment: "No required fields for FieldVisibility because it causes backwards compatibility issues. If we added a new property, we don't want old records to fail if all properties are not specified(and overwrite the values with the defaults), but we also don't want to set new properties especially on the discovery provider because then we'd be writing properties not present in the metadata written on chain.",
		title: "FieldVisibility"
	},
	StemOf: {
		type: [
			"object",
			"null"
		],
		additionalProperties: false,
		properties: {
			category: {
				type: "string"
			},
			parent_track_id: {
				type: "integer"
			}
		},
		required: [
			"category",
			"parent_track_id"
		],
		title: "StemOf"
	},
	TrackSegment: {
		type: "object",
		additionalProperties: false,
		properties: {
			duration: {
				type: "number"
			},
			multihash: {
				type: "string",
				$ref: "#/definitions/CID"
			}
		},
		required: [
			"duration",
			"multihash"
		],
		title: "TrackSegment"
	},
	CID: {
		type: [
			"string",
			"null"
		],
		minLength: 46,
		maxLength: 46,
		pattern: "^Qm[a-zA-Z0-9]{44}$",
		title: "CID"
	}
};
var TrackSchema = {
	$schema: $schema$1,
	$ref: $ref$1,
	definitions: definitions$1
};

var $schema = "http://json-schema.org/draft-07/schema#";
var $ref = "#/definitions/User";
var definitions = {
	User: {
		type: "object",
		additionalProperties: true,
		properties: {
			name: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			profile_picture: {
				type: [
					"string",
					"null"
				],
				"default": null,
				$ref: "#/definitions/CID"
			},
			profile_picture_sizes: {
				type: [
					"string",
					"null"
				],
				"default": null,
				$ref: "#/definitions/CID"
			},
			cover_photo: {
				type: [
					"string",
					"null"
				],
				"default": null,
				$ref: "#/definitions/CID"
			},
			cover_photo_sizes: {
				type: [
					"string",
					"null"
				],
				"default": null,
				$ref: "#/definitions/CID"
			},
			bio: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			location: {
				type: [
					"string",
					"null"
				],
				"default": null
			},
			associated_wallets: {
				$ref: "#/definitions/AssociatedWallets"
			},
			associated_sol_wallets: {
				$ref: "#/definitions/AssociatedSOLWallets"
			},
			collectibles: {
				$ref: "#/definitions/Collectibles"
			},
			playlist_library: {
				$ref: "#/definitions/PlaylistLibrary"
			},
			events: {
				$ref: "#/definitions/Events"
			},
			is_deactivated: {
				type: "boolean",
				"default": false
			}
		},
		required: [
			"bio",
			"cover_photo",
			"cover_photo_sizes",
			"location",
			"name",
			"profile_picture",
			"profile_picture_sizes"
		],
		title: "User"
	},
	CID: {
		type: [
			"string",
			"null"
		],
		minLength: 46,
		maxLength: 46,
		pattern: "^Qm[a-zA-Z0-9]{44}$",
		title: "CID"
	},
	AssociatedWallets: {
		type: [
			"object",
			"null"
		],
		"default": null,
		patternProperties: {
			"^0x[a-fA-F0-9]{40}$": {
				$ref: "#/definitions/WalletMetadata"
			}
		},
		additionalProperties: false,
		properties: {
		},
		required: [
		],
		$comment: "",
		title: "AssociatedWallets"
	},
	AssociatedSOLWallets: {
		type: [
			"object",
			"null"
		],
		"default": null,
		patternProperties: {
			"^[a-zA-Z0-9]{44}$": {
				$ref: "#/definitions/WalletMetadata"
			}
		},
		additionalProperties: false,
		properties: {
		},
		required: [
		],
		$comment: "",
		title: "AssociatedSOLWallets"
	},
	WalletMetadata: {
		type: [
			"object"
		],
		additionalProperties: true,
		properties: {
			signature: {
				type: "string"
			}
		},
		required: [
			"signature"
		],
		$comment: "",
		title: "WalletMetadata"
	},
	Collectible: {
		type: "object",
		additionalProperties: false
	},
	Collectibles: {
		type: [
			"object",
			"null"
		],
		"default": null,
		additionalProperties: {
			$ref: "#/definitions/Collectible"
		},
		properties: {
			order: {
				type: "array",
				items: {
					type: "string"
				}
			}
		},
		required: [
			"order"
		]
	},
	PlaylistIdentifier: {
		properties: {
			type: {
				type: "string",
				"const": "playlist"
			},
			playlist_id: {
				type: "integer"
			}
		}
	},
	ExplorePlaylistIdentifier: {
		properties: {
			type: {
				type: "string",
				"const": "explore_playlist"
			},
			playlist_id: {
				type: "string",
				pattern: "^[a-zA-Z /-?]+$"
			}
		}
	},
	PlaylistLibraryIdentifier: {
		oneOf: [
			{
				$ref: "#/definitions/PlaylistIdentifier"
			},
			{
				$ref: "#/definitions/ExplorePlaylistIdentifier"
			}
		]
	},
	PlaylistLibraryFolder: {
		properties: {
			type: {
				type: "string",
				"const": "folder"
			},
			id: {
				type: "string"
			},
			name: {
				type: "string"
			},
			contents: {
				type: "array",
				items: {
					oneOf: [
						{
							$ref: "#/definitions/PlaylistLibraryFolder"
						},
						{
							$ref: "#/definitions/PlaylistLibraryIdentifier"
						}
					]
				}
			}
		}
	},
	PlaylistLibrary: {
		type: [
			"object",
			"null"
		],
		"default": null,
		properties: {
			contents: {
				type: "array",
				items: {
					oneOf: [
						{
							$ref: "#/definitions/PlaylistLibraryFolder"
						},
						{
							$ref: "#/definitions/PlaylistLibraryIdentifier"
						}
					]
				}
			}
		}
	},
	Events: {
		type: [
			"object",
			"null"
		],
		"default": null,
		properties: {
			referrer: {
				type: "integer"
			},
			is_mobile_user: {
				type: "boolean"
			}
		}
	}
};
var UserSchema = {
	$schema: $schema,
	$ref: $ref,
	definitions: definitions
};

var trackSchemaType = 'TrackSchema';
var userSchemaType = 'UserSchema';
var SchemaValidator = /*#__PURE__*/function () {
  function SchemaValidator() {
    _classCallCheck(this, SchemaValidator);
  }

  _createClass(SchemaValidator, [{
    key: "init",
    value: function init() {
      var _this$schemas,
          _this = this;

      /**
       * Fully formed schemas object looks like the below
       * {
       *   'TrackSchema': {
       *     schema: <schemaJSON>,
       *     baseDefinition: 'String', //name of base definition property in schema
       *     validate: function // returns error if not validated correctly, otherwise null
       *   },
       *   'UserSchema': ...
       * }
       *
       * validate works like this `this.UserSchema.validate(userObj)`
       */
      this.schemas = (_this$schemas = {}, _defineProperty(_this$schemas, trackSchemaType, {
        schema: TrackSchema,
        baseDefinition: 'Track'
      }), _defineProperty(_this$schemas, userSchemaType, {
        schema: UserSchema,
        baseDefinition: 'User'
      }), _this$schemas);

      var _loop = function _loop(schemaType) {
        var typedSchemaType = schemaType;

        _this.schemas[typedSchemaType].validate = function (obj) {
          var _this$schemas2;

          _this.addMissingFields(obj, typedSchemaType);

          var result = jsonschema.validate(obj, (_this$schemas2 = _this.schemas) === null || _this$schemas2 === void 0 ? void 0 : _this$schemas2[typedSchemaType].schema);
          if (result.errors.length > 0) throw new Error("".concat(schemaType, " validation failed with errors: ").concat(JSON.stringify(result.errors)));
        };
      };

      for (var schemaType in this.schemas) {
        _loop(schemaType);
      }
    }
  }, {
    key: "getSchemas",
    value: function getSchemas() {
      return this.schemas;
    }
  }, {
    key: "addMissingFields",
    value: function addMissingFields(obj, schemaType) {
      if (!this.schemas) {
        return;
      } // schema is the entire imporoted schema, including all the definitions for JSON fields


      var _this$schemas$schemaT = this.schemas[schemaType],
          schema = _this$schemas$schemaT.schema,
          baseDefinition = _this$schemas$schemaT.baseDefinition; // schemaTypeObj is only the subset of the schema with only one definition for main schema type

      var schemaTypeObj = schema.definitions[baseDefinition]; // iterate through every required property, ensuring it exists or setting a default value

      if (schemaTypeObj && 'required' in schemaTypeObj) {
        schemaTypeObj.required.forEach(function (req) {
          if (!Object.prototype.hasOwnProperty.call(obj, req)) {
            if (Object.prototype.hasOwnProperty.call(schemaTypeObj.properties[req], 'default')) {
              var _schemaTypeObj$proper;

              obj[req] = (_schemaTypeObj$proper = schemaTypeObj.properties[req]) === null || _schemaTypeObj$proper === void 0 ? void 0 : _schemaTypeObj$proper["default"];
            } else throw new Error("Could not set default value for missing field ".concat(req));
          }
        });
      }
    }
  }]);

  return SchemaValidator;
}();

var wait = Utils$b.wait;
var MAX_TRACK_TRANSCODE_TIMEOUT = 3600000; // 1 hour

var POLL_STATUS_INTERVAL = 3000; // 3s

var BROWSER_SESSION_REFRESH_TIMEOUT = 604800000; // 1 week
// Currently only supports a single logged-in audius user

var CreatorNode$6 = /*#__PURE__*/function () {
  /**
   * Constructs a service class for a creator node
   * @param web3Manager
   * @param creatorNodeEndpoint fallback creator node endpoint (to be deprecated)
   * @param isServer
   * @param userStateManager  singleton UserStateManager instance
   * @param lazyConnect whether or not to lazy connect (sign in) on load
   * @param schemas
   * @param passList whether or not to include only specified nodes (default null)
   * @param blockList whether or not to exclude any nodes (default null)
   * @param monitoringCallbacks callbacks to be invoked with metrics from requests sent to a service
   */
  function CreatorNode(web3Manager, creatorNodeEndpoint, isServer, userStateManager, lazyConnect, schemas) {
    var passList = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var blockList = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
    var monitoringCallbacks = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {};

    _classCallCheck(this, CreatorNode);

    this.web3Manager = web3Manager; // This is just 1 endpoint (primary), unlike the creator_node_endpoint field in user metadata

    this.creatorNodeEndpoint = creatorNodeEndpoint;
    this.isServer = isServer;
    this.userStateManager = userStateManager;
    this.schemas = schemas;
    this.lazyConnect = lazyConnect;
    this.connected = false;
    this.connecting = false; // a lock so multiple content node requests in parallel won't each try to auth

    this.authToken = null;
    this.maxBlockNumber = 0;
    this.passList = passList;
    this.blockList = blockList;
    this.monitoringCallbacks = monitoringCallbacks;
  }
  /* Static Utils */

  /**
   * Pulls off the primary creator node from a creator node endpoint string.
   * @param endpoints user.creator_node_endpoint
   */


  _createClass(CreatorNode, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.web3Manager) {
                  _context.next = 2;
                  break;
                }

                throw new Error('Failed to initialize CreatorNode');

              case 2:
                if (this.lazyConnect) {
                  _context.next = 5;
                  break;
                }

                _context.next = 5;
                return this.connect();

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
    /** Establishes a connection to a content node endpoint */

  }, {
    key: "connect",
    value: function () {
      var _connect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.connecting = true;
                _context2.next = 3;
                return this._signupNodeUser(this.web3Manager.getWalletAddress());

              case 3:
                _context2.next = 5;
                return this._loginNodeUser();

              case 5:
                this.connected = true;
                this.connecting = false;

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function connect() {
        return _connect.apply(this, arguments);
      }

      return connect;
    }()
    /** Checks if connected, otherwise establishing a connection */

  }, {
    key: "ensureConnected",
    value: function () {
      var _ensureConnected = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this = this;

        var interval;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(!this.connected && !this.connecting)) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 3;
                return this.connect();

              case 3:
                _context3.next = 9;
                break;

              case 5:
                if (!this.connecting) {
                  _context3.next = 9;
                  break;
                }

                _context3.next = 8;
                return new Promise(function (resolve) {
                  interval = setInterval(function () {
                    if (_this.connected) resolve();
                  }, 100);
                });

              case 8:
                clearInterval(interval);

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function ensureConnected() {
        return _ensureConnected.apply(this, arguments);
      }

      return ensureConnected;
    }()
  }, {
    key: "getEndpoint",
    value: function getEndpoint() {
      return this.creatorNodeEndpoint;
    }
    /**
     * Switch from one creatorNodeEndpoint to another including logging out from the old node, updating the endpoint and logging into new node */

  }, {
    key: "setEndpoint",
    value: function () {
      var _setEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(creatorNodeEndpoint) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(this.creatorNodeEndpoint === creatorNodeEndpoint)) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return");

              case 2:
                if (!this.connected) {
                  _context4.next = 11;
                  break;
                }

                _context4.prev = 3;
                _context4.next = 6;
                return this._logoutNodeUser();

              case 6:
                _context4.next = 11;
                break;

              case 8:
                _context4.prev = 8;
                _context4.t0 = _context4["catch"](3);
                console.error(_context4.t0.message);

              case 11:
                this.connected = false;
                this.creatorNodeEndpoint = creatorNodeEndpoint;

                if (this.lazyConnect) {
                  _context4.next = 16;
                  break;
                }

                _context4.next = 16;
                return this.connect();

              case 16:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[3, 8]]);
      }));

      function setEndpoint(_x) {
        return _setEndpoint.apply(this, arguments);
      }

      return setEndpoint;
    }()
    /** Clear all connection state in this class by deleting authToken and setting 'connected' = false */

  }, {
    key: "clearConnection",
    value: function clearConnection() {
      this.connected = false;
      this.authToken = null;
    }
    /**
     * Uploads creator content to a creator node
     * @param metadata the creator metadata
     */

  }, {
    key: "uploadCreatorContent",
    value: function () {
      var _uploadCreatorContent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(metadata) {
        var blockNumber,
            _this$schemas$userSch,
            _this$schemas$userSch2,
            requestObj,
            _yield$this$_makeRequ,
            body,
            _args5 = arguments;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                blockNumber = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : null;
                _context5.prev = 1;
                (_this$schemas$userSch = (_this$schemas$userSch2 = this.schemas[userSchemaType]).validate) === null || _this$schemas$userSch === void 0 ? void 0 : _this$schemas$userSch.call(_this$schemas$userSch2, metadata);
                requestObj = {
                  url: '/audius_users/metadata',
                  method: 'post',
                  data: {
                    metadata: metadata,
                    blockNumber: blockNumber
                  }
                };
                _context5.next = 6;
                return this._makeRequest(requestObj);

              case 6:
                _yield$this$_makeRequ = _context5.sent;
                body = _yield$this$_makeRequ.data;
                return _context5.abrupt("return", body);

              case 11:
                _context5.prev = 11;
                _context5.t0 = _context5["catch"](1);
                console.error('Error validating creator metadata', _context5.t0);

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[1, 11]]);
      }));

      function uploadCreatorContent(_x2) {
        return _uploadCreatorContent.apply(this, arguments);
      }

      return uploadCreatorContent;
    }()
    /**
     * Creates a creator on the creator node, associating user id with file content
     * @param audiusUserId returned by user creation on-blockchain
     * @param metadataFileUUID unique ID for metadata file
     * @param blockNumber
     */

  }, {
    key: "associateCreator",
    value: function () {
      var _associateCreator = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(audiusUserId, metadataFileUUID, blockNumber) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this.maxBlockNumber = Math.max(this.maxBlockNumber, blockNumber);
                _context6.next = 3;
                return this._makeRequest({
                  url: '/audius_users',
                  method: 'post',
                  data: {
                    blockchainUserId: audiusUserId,
                    metadataFileUUID: metadataFileUUID,
                    blockNumber: this.maxBlockNumber
                  }
                });

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function associateCreator(_x3, _x4, _x5) {
        return _associateCreator.apply(this, arguments);
      }

      return associateCreator;
    }()
    /**
     * Uploads a track (including audio and image content) to a creator node
     * @param trackFile the audio content
     * @param coverArtFile the image content
     * @param metadata the metadata for the track
     * @param onProgress an optional on progress callback
     */

  }, {
    key: "uploadTrackContent",
    value: function () {
      var _uploadTrackContent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(trackFile, coverArtFile, metadata) {
        var _metadata$download;

        var onProgress,
            loadedImageBytes,
            loadedTrackBytes,
            totalImageBytes,
            totalTrackBytes,
            onImageProgress,
            onTrackProgress,
            uploadPromises,
            _yield$Promise$all,
            _yield$Promise$all2,
            trackContentResp,
            coverArtResp,
            sourceFile,
            metadataResp,
            _args7 = arguments;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                onProgress = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : function () {};
                loadedImageBytes = 0;
                loadedTrackBytes = 0;
                totalImageBytes = 0;
                totalTrackBytes = 0;

                onImageProgress = function onImageProgress(loaded, total) {
                  loadedImageBytes = loaded;
                  if (!totalImageBytes) totalImageBytes += total;

                  if (totalImageBytes && totalTrackBytes) {
                    onProgress(loadedImageBytes + loadedTrackBytes, totalImageBytes + totalTrackBytes);
                  }
                };

                onTrackProgress = function onTrackProgress(loaded, total) {
                  loadedTrackBytes = loaded;
                  if (!totalTrackBytes) totalTrackBytes += total;

                  if ((!coverArtFile || totalImageBytes) && totalTrackBytes) {
                    onProgress(loadedImageBytes + loadedTrackBytes, totalImageBytes + totalTrackBytes);
                  }
                };

                uploadPromises = [];
                uploadPromises.push(this.uploadTrackAudio(trackFile, onTrackProgress));
                if (coverArtFile) uploadPromises.push(this.uploadImage(coverArtFile, true, onImageProgress));
                _context7.next = 12;
                return Promise.all(uploadPromises);

              case 12:
                _yield$Promise$all = _context7.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                trackContentResp = _yield$Promise$all2[0];
                coverArtResp = _yield$Promise$all2[1];
                metadata.track_segments = trackContentResp.track_segments;

                if ((_metadata$download = metadata.download) !== null && _metadata$download !== void 0 && _metadata$download.is_downloadable) {
                  metadata.download.cid = trackContentResp.transcodedTrackCID;
                }

                sourceFile = trackContentResp.source_file;

                if (sourceFile) {
                  _context7.next = 21;
                  break;
                }

                throw new Error("Invalid or missing sourceFile in response: ".concat(JSON.stringify(trackContentResp)));

              case 21:
                if (coverArtResp) {
                  metadata.cover_art_sizes = coverArtResp.dirCID;
                } // Creates new track entity on creator node, making track's metadata available
                // @returns {Object} {cid: CID of track metadata, id: id of track to be used with associate function}


                _context7.next = 24;
                return this.uploadTrackMetadata(metadata, sourceFile);

              case 24:
                metadataResp = _context7.sent;
                return _context7.abrupt("return", _objectSpread2(_objectSpread2({}, metadataResp), trackContentResp));

              case 26:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function uploadTrackContent(_x6, _x7, _x8) {
        return _uploadTrackContent.apply(this, arguments);
      }

      return uploadTrackContent;
    }()
    /**
     * Uploads track metadata to a creator node
     * The metadata object must include a `track_id` field or a
     * source file must be provided (returned from uploading track content).
     * @param metadata
     * @param sourceFile
     */

  }, {
    key: "uploadTrackMetadata",
    value: function () {
      var _uploadTrackMetadata = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(metadata, sourceFile) {
        var _this$schemas$trackSc, _this$schemas$trackSc2, _yield$this$_makeRequ2, body;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                // this does the actual validation before sending to the creator node
                // if validation fails, validate() will throw an error
                try {
                  (_this$schemas$trackSc = (_this$schemas$trackSc2 = this.schemas[trackSchemaType]).validate) === null || _this$schemas$trackSc === void 0 ? void 0 : _this$schemas$trackSc.call(_this$schemas$trackSc2, metadata);
                } catch (e) {
                  console.error('Error validating track metadata', e);
                }

                _context8.next = 3;
                return this._makeRequest({
                  url: '/tracks/metadata',
                  method: 'post',
                  data: {
                    metadata: metadata,
                    sourceFile: sourceFile
                  }
                }, true);

              case 3:
                _yield$this$_makeRequ2 = _context8.sent;
                body = _yield$this$_makeRequ2.data;
                return _context8.abrupt("return", body);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function uploadTrackMetadata(_x9, _x10) {
        return _uploadTrackMetadata.apply(this, arguments);
      }

      return uploadTrackMetadata;
    }()
    /**
     * Creates a track on the content node, associating track id with file content
     * @param audiusTrackId returned by track creation on-blockchain
     * @param metadataFileUUID unique ID for metadata file
     * @param blockNumber
     * @param transcodedTrackUUID the CID for the transcoded master if this is a first-time upload
     */

  }, {
    key: "associateTrack",
    value: function () {
      var _associateTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(audiusTrackId, metadataFileUUID, blockNumber, transcodedTrackUUID) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this.maxBlockNumber = Math.max(this.maxBlockNumber, blockNumber);
                _context9.next = 3;
                return this._makeRequest({
                  url: '/tracks',
                  method: 'post',
                  data: {
                    blockchainTrackId: audiusTrackId,
                    metadataFileUUID: metadataFileUUID,
                    blockNumber: this.maxBlockNumber,
                    transcodedTrackUUID: transcodedTrackUUID
                  }
                });

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function associateTrack(_x11, _x12, _x13, _x14) {
        return _associateTrack.apply(this, arguments);
      }

      return associateTrack;
    }()
    /**
     * Uploads an image to the connected content node
     * @param file image to upload
     * @param onProgress called with loaded bytes and total bytes
     * @param timeoutMs timeout in ms axios request to upload file to CN will wait
     * @return response body
     */

  }, {
    key: "uploadImage",
    value: function () {
      var _uploadImage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(file) {
        var square,
            onProgress,
            timeoutMs,
            _yield$this$_uploadFi,
            body,
            _args10 = arguments;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                square = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : true;
                onProgress = _args10.length > 2 ? _args10[2] : undefined;
                timeoutMs = _args10.length > 3 && _args10[3] !== undefined ? _args10[3] : null;
                _context10.next = 5;
                return this._uploadFile(file, '/image_upload', onProgress, {
                  square: square
                },
                /* retries */
                undefined, timeoutMs);

              case 5:
                _yield$this$_uploadFi = _context10.sent;
                body = _yield$this$_uploadFi.data;
                return _context10.abrupt("return", body);

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function uploadImage(_x15) {
        return _uploadImage.apply(this, arguments);
      }

      return uploadImage;
    }()
    /**
     * @param file track to upload
     * @param onProgress called with loaded bytes and total bytes
     * @return response body
     */

  }, {
    key: "uploadTrackAudio",
    value: function () {
      var _uploadTrackAudio = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(file, onProgress) {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.handleAsyncTrackUpload(file, onProgress);

              case 2:
                return _context11.abrupt("return", _context11.sent);

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function uploadTrackAudio(_x16, _x17) {
        return _uploadTrackAudio.apply(this, arguments);
      }

      return uploadTrackAudio;
    }()
  }, {
    key: "handleAsyncTrackUpload",
    value: function () {
      var _handleAsyncTrackUpload = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(file, onProgress) {
        var _yield$this$_uploadFi2, uuid;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this._uploadFile(file, '/track_content_async', onProgress);

              case 2:
                _yield$this$_uploadFi2 = _context12.sent;
                uuid = _yield$this$_uploadFi2.data.uuid;
                _context12.next = 6;
                return this.pollProcessingStatus(uuid);

              case 6:
                return _context12.abrupt("return", _context12.sent);

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function handleAsyncTrackUpload(_x18, _x19) {
        return _handleAsyncTrackUpload.apply(this, arguments);
      }

      return handleAsyncTrackUpload;
    }()
  }, {
    key: "pollProcessingStatus",
    value: function () {
      var _pollProcessingStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(uuid) {
        var route, start, _yield$this$getTrackC, status, resp;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                route = this.creatorNodeEndpoint + '/async_processing_status';
                start = Date.now();

              case 2:
                if (!(Date.now() - start < MAX_TRACK_TRANSCODE_TIMEOUT)) {
                  _context13.next = 23;
                  break;
                }

                _context13.prev = 3;
                _context13.next = 6;
                return this.getTrackContentProcessingStatus(uuid);

              case 6:
                _yield$this$getTrackC = _context13.sent;
                status = _yield$this$getTrackC.status;
                resp = _yield$this$getTrackC.resp;

                if (!(status && status === 'DONE')) {
                  _context13.next = 11;
                  break;
                }

                return _context13.abrupt("return", resp);

              case 11:
                if (!(status && status === 'FAILED')) {
                  _context13.next = 14;
                  break;
                }

                _context13.next = 14;
                return this._handleErrorHelper(new Error("Track content async upload failed: uuid=".concat(uuid, ", error=").concat(resp)), route, uuid);

              case 14:
                _context13.next = 19;
                break;

              case 16:
                _context13.prev = 16;
                _context13.t0 = _context13["catch"](3);
                // Catch errors here and swallow them. Errors don't signify that the track
                // upload has failed, just that we were unable to establish a connection to the node.
                // This allows polling to retry
                console.error("Failed to poll for processing status, ".concat(_context13.t0));

              case 19:
                _context13.next = 21;
                return wait(POLL_STATUS_INTERVAL);

              case 21:
                _context13.next = 2;
                break;

              case 23:
                _context13.next = 25;
                return this._handleErrorHelper(new Error("Track content async upload took over ".concat(MAX_TRACK_TRANSCODE_TIMEOUT, "ms. uuid=").concat(uuid)), route, uuid);

              case 25:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this, [[3, 16]]);
      }));

      function pollProcessingStatus(_x20) {
        return _pollProcessingStatus.apply(this, arguments);
      }

      return pollProcessingStatus;
    }()
    /**
     * Gets the task progress given the task type and uuid associated with the task
     * @param uuid the uuid of the track transcoding task
     * @returns the status, and the success or failed response if the task is complete
     */

  }, {
    key: "getTrackContentProcessingStatus",
    value: function () {
      var _getTrackContentProcessingStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(uuid) {
        var _yield$this$_makeRequ3, body;

        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this._makeRequest({
                  url: '/async_processing_status',
                  params: {
                    uuid: uuid
                  },
                  method: 'get'
                });

              case 2:
                _yield$this$_makeRequ3 = _context14.sent;
                body = _yield$this$_makeRequ3.data;
                return _context14.abrupt("return", body);

              case 5:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getTrackContentProcessingStatus(_x21) {
        return _getTrackContentProcessingStatus.apply(this, arguments);
      }

      return getTrackContentProcessingStatus;
    }()
    /**
     * Given a particular endpoint to a creator node, check whether
     * this user has a sync in progress on that node.
     * @param endpoint
     * @param timeout ms
     */

  }, {
    key: "getSyncStatus",
    value: function () {
      var _getSyncStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(endpoint) {
        var timeout,
            user,
            req,
            _yield$axios,
            body,
            status,
            _args15 = arguments;

        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                timeout = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : null;
                user = this.userStateManager.getCurrentUser();

                if (!user) {
                  _context15.next = 11;
                  break;
                }

                req = {
                  baseURL: endpoint,
                  url: "/sync_status/".concat(user.wallet),
                  method: 'get'
                };
                if (timeout) req.timeout = timeout;
                _context15.next = 7;
                return axios__default["default"](req);

              case 7:
                _yield$axios = _context15.sent;
                body = _yield$axios.data;
                status = body.data;
                return _context15.abrupt("return", {
                  status: status,
                  userBlockNumber: user.blocknumber,
                  trackBlockNumber: user.track_blocknumber,
                  // Whether or not the endpoint is behind in syncing
                  isBehind: status.latestBlockNumber < Math.max(user.blocknumber, user.track_blocknumber),
                  isConfigured: status.latestBlockNumber !== -1
                });

              case 11:
                throw new Error('No current user');

              case 12:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getSyncStatus(_x22) {
        return _getSyncStatus.apply(this, arguments);
      }

      return getSyncStatus;
    }()
    /**
     * Syncs a secondary creator node for a given user
     * @param secondary
     * @param primary specific primary to use
     * @param immediate whether or not this is a blocking request and handled right away
     * @param validate whether or not to validate the provided secondary is valid
     */

  }, {
    key: "syncSecondary",
    value: function () {
      var _syncSecondary = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(secondary, primary) {
        var immediate,
            validate,
            user,
            secondaries,
            req,
            _args16 = arguments;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                immediate = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : false;
                validate = _args16.length > 3 && _args16[3] !== undefined ? _args16[3] : true;
                user = this.userStateManager.getCurrentUser();

                if (user) {
                  _context16.next = 5;
                  break;
                }

                return _context16.abrupt("return");

              case 5:
                if (!primary) {
                  primary = CreatorNode.getPrimary(user.creator_node_endpoint);
                }

                secondaries = new Set(CreatorNode.getSecondaries(user.creator_node_endpoint));

                if (!(primary && secondary && (!validate || secondaries.has(secondary)))) {
                  _context16.next = 12;
                  break;
                }

                req = {
                  baseURL: secondary,
                  url: '/sync',
                  method: 'post',
                  data: {
                    wallet: [user.wallet],
                    creator_node_endpoint: primary,
                    immediate: immediate
                  }
                };
                _context16.next = 11;
                return axios__default["default"](req);

              case 11:
                return _context16.abrupt("return", _context16.sent);

              case 12:
                return _context16.abrupt("return", undefined);

              case 13:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function syncSecondary(_x23, _x24) {
        return _syncSecondary.apply(this, arguments);
      }

      return syncSecondary;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

    /**
     * Signs up a creator node user with a wallet address
     * @param walletAddress
     */

  }, {
    key: "_signupNodeUser",
    value: function () {
      var _signupNodeUser2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(walletAddress) {
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this._makeRequest({
                  url: '/users',
                  method: 'post',
                  data: {
                    walletAddress: walletAddress
                  }
                }, false);

              case 2:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _signupNodeUser(_x25) {
        return _signupNodeUser2.apply(this, arguments);
      }

      return _signupNodeUser;
    }()
    /**
     * Logs user into cnode, if not already logged in.
     * Requests a challenge from cnode, sends signed challenge response to cn.
     * If successful, receive and set authToken locally.
     */

  }, {
    key: "_loginNodeUser",
    value: function () {
      var _loginNodeUser2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
        var _this2 = this;

        var walletPublicKey, clientChallengeKey, url, challengeResp, requestUrl, signature, resp;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                if (!this.authToken) {
                  _context18.next = 2;
                  break;
                }

                return _context18.abrupt("return");

              case 2:
                walletPublicKey = this.web3Manager.getWalletAddress();
                _context18.prev = 3;
                _context18.next = 6;
                return this._makeRequest({
                  url: '/users/login/challenge',
                  method: 'get',
                  params: {
                    walletPublicKey: walletPublicKey
                  }
                }, false);

              case 6:
                challengeResp = _context18.sent;
                clientChallengeKey = challengeResp.data.challenge;
                url = '/users/login/challenge';
                _context18.next = 16;
                break;

              case 11:
                _context18.prev = 11;
                _context18.t0 = _context18["catch"](3);
                requestUrl = this.creatorNodeEndpoint + '/users/login/challenge';
                _context18.next = 16;
                return this._handleErrorHelper(_context18.t0, requestUrl);

              case 16:
                _context18.next = 18;
                return this.web3Manager.sign(clientChallengeKey);

              case 18:
                signature = _context18.sent;

                if (!url) {
                  _context18.next = 24;
                  break;
                }

                _context18.next = 22;
                return this._makeRequest({
                  url: url,
                  method: 'post',
                  data: {
                    data: clientChallengeKey,
                    signature: signature
                  }
                }, false);

              case 22:
                resp = _context18.sent;
                this.authToken = resp.data.sessionToken;

              case 24:
                setTimeout(function () {
                  _this2.clearConnection();
                }, BROWSER_SESSION_REFRESH_TIMEOUT);

              case 25:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this, [[3, 11]]);
      }));

      function _loginNodeUser() {
        return _loginNodeUser2.apply(this, arguments);
      }

      return _loginNodeUser;
    }()
    /** Calls logout on the content node. Needs an authToken for this since logout is an authenticated endpoint */

  }, {
    key: "_logoutNodeUser",
    value: function () {
      var _logoutNodeUser2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (this.authToken) {
                  _context19.next = 2;
                  break;
                }

                return _context19.abrupt("return");

              case 2:
                _context19.next = 4;
                return this._makeRequest({
                  url: '/users/logout',
                  method: 'post'
                }, false);

              case 4:
                this.authToken = null;

              case 5:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _logoutNodeUser() {
        return _logoutNodeUser2.apply(this, arguments);
      }

      return _logoutNodeUser;
    }()
    /**
     * Gets and returns the clock values across the replica set for the wallet in userStateManager.
     * @returns Array of objects with the structure:
     *
     * {
     *  type: 'primary' or 'secondary',
     *  endpoint: <Content Node endpoint>,
     *  clockValue: clock value (should be an integer) or null
     * }
     *
     * 'clockValue' may be null if the request to fetch the clock value fails
     */

  }, {
    key: "getClockValuesFromReplicaSet",
    value: function () {
      var _getClockValuesFromReplicaSet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
        var _this3 = this;

        var user, replicaSet, clockValueResponses;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                user = this.userStateManager.getCurrentUser();

                if (!(!user || !user.creator_node_endpoint)) {
                  _context21.next = 4;
                  break;
                }

                console.error('No user or Content Node endpoint found');
                return _context21.abrupt("return");

              case 4:
                replicaSet = CreatorNode.getEndpoints(user.creator_node_endpoint);
                _context21.next = 7;
                return Promise.all(replicaSet.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(endpoint) {
                    return regeneratorRuntime.wrap(function _callee20$(_context20) {
                      while (1) {
                        switch (_context20.prev = _context20.next) {
                          case 0:
                            _context20.next = 2;
                            return _this3._clockValueRequest({
                              user: user,
                              endpoint: endpoint
                            });

                          case 2:
                            return _context20.abrupt("return", _context20.sent);

                          case 3:
                          case "end":
                            return _context20.stop();
                        }
                      }
                    }, _callee20);
                  }));

                  return function (_x26) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 7:
                clockValueResponses = _context21.sent;
                return _context21.abrupt("return", clockValueResponses);

              case 9:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getClockValuesFromReplicaSet() {
        return _getClockValuesFromReplicaSet.apply(this, arguments);
      }

      return getClockValuesFromReplicaSet;
    }()
    /**
     * Wrapper around getClockValue() to return either a proper or null clock value
     * @param {Object} param
     * @param {Object} param.user user metadata object from userStateManager
     * @param {string} param.endpoint the Content Node endpoint to check the clock value for
     * @param {number?} [param.timeout=1000] the max time allotted for a clock request; defaulted to 1000ms
     */

  }, {
    key: "_clockValueRequest",
    value: function () {
      var _clockValueRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(_ref2) {
        var user, endpoint, _ref2$timeout, timeout, primary, type, clockValue;

        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                user = _ref2.user, endpoint = _ref2.endpoint, _ref2$timeout = _ref2.timeout, timeout = _ref2$timeout === void 0 ? 1000 : _ref2$timeout;
                primary = CreatorNode.getPrimary(user.creator_node_endpoint);
                type = primary === endpoint ? 'primary' : 'secondary';
                _context22.prev = 3;
                _context22.next = 6;
                return CreatorNode.getClockValue(endpoint, user.wallet, timeout);

              case 6:
                clockValue = _context22.sent;
                return _context22.abrupt("return", {
                  type: type,
                  endpoint: endpoint,
                  clockValue: clockValue
                });

              case 10:
                _context22.prev = 10;
                _context22.t0 = _context22["catch"](3);
                console.error("Error in getting clock status for ".concat(user.wallet, " at ").concat(endpoint, ": ").concat(_context22.t0));
                return _context22.abrupt("return", {
                  type: type,
                  endpoint: endpoint,
                  clockValue: null
                });

              case 14:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, null, [[3, 10]]);
      }));

      function _clockValueRequest(_x27) {
        return _clockValueRequest2.apply(this, arguments);
      }

      return _clockValueRequest;
    }()
    /**
     * Makes an axios request to the connected creator node.
     * @param requiresConnection if set, the currently configured creator node
     * is connected to before the request is made.
     * @return response body
     */

  }, {
    key: "_makeRequest",
    value: function () {
      var _makeRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(axiosRequestObj) {
        var _this4 = this;

        var requiresConnection,
            work,
            _args25 = arguments;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                requiresConnection = _args25.length > 1 && _args25[1] !== undefined ? _args25[1] : true;

                work = /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {
                    var user, requestId, url, start, resp, duration, _resp$data, _resp$data$error, error, _resp, _duration;

                    return regeneratorRuntime.wrap(function _callee23$(_context23) {
                      while (1) {
                        switch (_context23.prev = _context23.next) {
                          case 0:
                            if (!requiresConnection) {
                              _context23.next = 3;
                              break;
                            }

                            _context23.next = 3;
                            return _this4.ensureConnected();

                          case 3:
                            axiosRequestObj.headers = axiosRequestObj.headers || {};

                            if (_this4.authToken) {
                              axiosRequestObj.headers['X-Session-ID'] = _this4.authToken;
                            }

                            user = _this4.userStateManager.getCurrentUser();

                            if (user !== null && user !== void 0 && user.wallet && user.user_id) {
                              axiosRequestObj.headers['User-Wallet-Addr'] = user.wallet;
                              axiosRequestObj.headers['User-Id'] = user.user_id;
                            }

                            requestId = uuid();
                            axiosRequestObj.headers['X-Request-ID'] = requestId;
                            axiosRequestObj.baseURL = _this4.creatorNodeEndpoint; // Axios throws for non-200 responses

                            url = new URL("".concat(axiosRequestObj.baseURL).concat(axiosRequestObj.url));
                            start = Date.now();
                            _context23.prev = 12;
                            _context23.next = 15;
                            return axios__default["default"](axiosRequestObj);

                          case 15:
                            resp = _context23.sent;
                            duration = Date.now() - start;

                            if (_this4.monitoringCallbacks.request) {
                              try {
                                _this4.monitoringCallbacks.request({
                                  endpoint: url.origin,
                                  pathname: url.pathname,
                                  queryString: url.search,
                                  signer: resp.data.signer,
                                  signature: resp.data.signature,
                                  requestMethod: axiosRequestObj.method,
                                  status: resp.status,
                                  responseTimeMillis: duration
                                });
                              } catch (e) {
                                // Swallow errors -- this method should not throw generally
                                console.error(e);
                              }
                            } // Axios `data` field gets the response body


                            return _context23.abrupt("return", resp.data);

                          case 21:
                            _context23.prev = 21;
                            _context23.t0 = _context23["catch"](12);
                            error = _context23.t0;
                            _resp = error.response;
                            _duration = Date.now() - start;

                            if (_this4.monitoringCallbacks.request) {
                              try {
                                _this4.monitoringCallbacks.request({
                                  endpoint: url.origin,
                                  pathname: url.pathname,
                                  queryString: url.search,
                                  requestMethod: axiosRequestObj.method,
                                  status: _resp === null || _resp === void 0 ? void 0 : _resp.status,
                                  responseTimeMillis: _duration
                                });
                              } catch (e) {
                                // Swallow errors -- this method should not throw generally
                                console.error(e);
                              }
                            } // if the content node returns an invalid auth token error, clear connection and reconnect


                            if (!(_resp !== null && _resp !== void 0 && (_resp$data = _resp.data) !== null && _resp$data !== void 0 && (_resp$data$error = _resp$data.error) !== null && _resp$data$error !== void 0 && _resp$data$error.includes('Invalid authentication token'))) {
                              _context23.next = 37;
                              break;
                            }

                            _this4.clearConnection();

                            _context23.prev = 29;
                            _context23.next = 32;
                            return _this4.ensureConnected();

                          case 32:
                            _context23.next = 37;
                            break;

                          case 34:
                            _context23.prev = 34;
                            _context23.t1 = _context23["catch"](29);
                            console.error(_context23.t1.message);

                          case 37:
                            _context23.next = 39;
                            return _this4._handleErrorHelper(error, axiosRequestObj.url, requestId);

                          case 39:
                          case "end":
                            return _context23.stop();
                        }
                      }
                    }, _callee23, null, [[12, 21], [29, 34]]);
                  }));

                  return function work() {
                    return _ref3.apply(this, arguments);
                  };
                }();

                _context25.next = 4;
                return retry__default["default"]( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24() {
                  return regeneratorRuntime.wrap(function _callee24$(_context24) {
                    while (1) {
                      switch (_context24.prev = _context24.next) {
                        case 0:
                          _context24.next = 2;
                          return work();

                        case 2:
                          return _context24.abrupt("return", _context24.sent);

                        case 3:
                        case "end":
                          return _context24.stop();
                      }
                    }
                  }, _callee24);
                })), {
                  // Retry function 3x
                  // 1st retry delay = 500ms, 2nd = 1500ms, 3rd...nth retry = 4000 ms (capped)
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: 3,
                  onRetry: function onRetry(err) {
                    if (err) {
                      console.log('makeRequest retry error: ', err);
                    }
                  }
                });

              case 4:
                return _context25.abrupt("return", _context25.sent);

              case 5:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25);
      }));

      function _makeRequest(_x28) {
        return _makeRequest2.apply(this, arguments);
      }

      return _makeRequest;
    }()
    /**
     * Create headers and formData for file upload
     * @param file the file to upload
     * @returns headers and formData in an object
     */

  }, {
    key: "createFormDataAndUploadHeaders",
    value: function createFormDataAndUploadHeaders(file) {
      var extraFormDataOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // form data is from browser, not imported npm module
      var formData = new FormData__default["default"]();
      formData.append('file', file);
      Object.keys(extraFormDataOptions).forEach(function (key) {
        formData.append(key, "".concat(extraFormDataOptions[key]));
      });
      var headers = {};

      if (this.isServer) {
        headers = formData.getHeaders();
      }

      headers['X-Session-ID'] = this.authToken;
      var requestId = uuid();
      headers['X-Request-ID'] = requestId;
      var user = this.userStateManager.getCurrentUser();

      if (user !== null && user !== void 0 && user.wallet && user.user_id) {
        // TODO change to X-User-Wallet-Address and X-User-Id per convention
        headers['User-Wallet-Addr'] = user.wallet;
        headers['User-Id'] = user.user_id;
      }

      return {
        headers: headers,
        formData: formData
      };
    }
    /**
     * Uploads a file to the connected creator node.
     * @param file
     * @param route route to handle upload (image_upload, track_upload, etc.)
     * @param onProgress called with loaded bytes and total bytes
     * @param extraFormDataOptions extra FormData fields passed to the upload
     * @param retries max number of attempts made for axios request to upload file to CN before erroring
     * @param timeoutMs timeout in ms axios request to upload file to CN will wait
     */

  }, {
    key: "_uploadFile",
    value: function () {
      var _uploadFile2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(file, route) {
        var onProgress,
            extraFormDataOptions,
            retries,
            timeoutMs,
            _this$createFormDataA,
            headers,
            formData,
            requestId,
            total,
            url,
            _resp$data2,
            isBrowser,
            reqParams,
            resp,
            _error$response,
            _error$response$data,
            _error$response$data$,
            error,
            _args26 = arguments;

        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                onProgress = _args26.length > 2 && _args26[2] !== undefined ? _args26[2] : function () {};
                extraFormDataOptions = _args26.length > 3 && _args26[3] !== undefined ? _args26[3] : {};
                retries = _args26.length > 4 && _args26[4] !== undefined ? _args26[4] : 2;
                timeoutMs = _args26.length > 5 && _args26[5] !== undefined ? _args26[5] : null;
                _context26.next = 6;
                return this.ensureConnected();

              case 6:
                _this$createFormDataA = this.createFormDataAndUploadHeaders(file, extraFormDataOptions), headers = _this$createFormDataA.headers, formData = _this$createFormDataA.formData;
                requestId = headers['X-Request-ID'];
                url = this.creatorNodeEndpoint + route;
                _context26.prev = 9;
                // Hack alert!
                //
                // Axios auto-detects browser vs node based on
                // the existance of XMLHttpRequest at the global namespace, which
                // is imported by a web3 module, causing Axios to incorrectly
                // presume we're in a browser env when we're in a node env.
                // For uploads to work in a node env,
                // axios needs to correctly detect we're in node and use the `http` module
                // rather than XMLHttpRequest. We force that here.
                // https://github.com/axios/axios/issues/1180
                isBrowser = typeof window !== 'undefined';
                console.debug("Uploading file to ".concat(url));
                reqParams = {
                  headers: headers,
                  adapter: isBrowser ? require('axios/lib/adapters/xhr') : require('axios/lib/adapters/http'),
                  // Add a 10% inherit processing time for the file upload.
                  onUploadProgress: function onUploadProgress(progressEvent) {
                    if (!total) total = progressEvent.total;
                    console.info("Upload in progress: ".concat(progressEvent.loaded, " / ").concat(total));
                    onProgress(progressEvent.loaded, total);
                  },
                  // Set content length headers (only applicable in server/node environments).
                  // See: https://github.com/axios/axios/issues/1362
                  maxContentLength: Infinity,
                  // @ts-expect-error TODO: including even though it's not an axios config. should double check
                  maxBodyLength: Infinity
                };

                if (timeoutMs) {
                  reqParams.timeout = timeoutMs;
                }

                _context26.next = 16;
                return axios__default["default"].post(url, formData, reqParams);

              case 16:
                resp = _context26.sent;

                if (!((_resp$data2 = resp.data) !== null && _resp$data2 !== void 0 && _resp$data2.error)) {
                  _context26.next = 19;
                  break;
                }

                throw new Error(JSON.stringify(resp.data.error));

              case 19:
                // @ts-expect-error total should be set in `onUploadProgress` which runs before `onProgress` is called
                onProgress(total, total);
                return _context26.abrupt("return", resp.data);

              case 23:
                _context26.prev = 23;
                _context26.t0 = _context26["catch"](9);
                error = _context26.t0;

                if (!(!error.response && retries > 0)) {
                  _context26.next = 32;
                  break;
                }

                console.warn("Network Error in request ".concat(requestId, " with ").concat(retries, " retries... retrying"));
                console.warn(error); // eslint-disable-next-line @typescript-eslint/return-await -- possible issue with return await

                return _context26.abrupt("return", this._uploadFile(file, route, onProgress, extraFormDataOptions, retries - 1));

              case 32:
                if (!((_error$response = error.response) !== null && _error$response !== void 0 && (_error$response$data = _error$response.data) !== null && _error$response$data !== void 0 && (_error$response$data$ = _error$response$data.error) !== null && _error$response$data$ !== void 0 && _error$response$data$.includes('Invalid authentication token'))) {
                  _context26.next = 42;
                  break;
                }

                // if the content node returns an invalid auth token error, clear connection and reconnect
                this.clearConnection();
                _context26.prev = 34;
                _context26.next = 37;
                return this.ensureConnected();

              case 37:
                _context26.next = 42;
                break;

              case 39:
                _context26.prev = 39;
                _context26.t1 = _context26["catch"](34);
                console.error(_context26.t1.message);

              case 42:
                _context26.next = 44;
                return this._handleErrorHelper(error, url, requestId);

              case 44:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this, [[9, 23], [34, 39]]);
      }));

      function _uploadFile(_x29, _x30) {
        return _uploadFile2.apply(this, arguments);
      }

      return _uploadFile;
    }()
  }, {
    key: "_handleErrorHelper",
    value: function () {
      var _handleErrorHelper2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(e, requestUrl) {
        var _e$response, _e$response$data;

        var requestId,
            cnRequestID,
            errMessage,
            errorMsg,
            newRequestId,
            endpoint,
            res,
            _errorMsg,
            _args27 = arguments;

        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                requestId = _args27.length > 2 && _args27[2] !== undefined ? _args27[2] : null;

                if (!('response' in e && (_e$response = e.response) !== null && _e$response !== void 0 && (_e$response$data = _e$response.data) !== null && _e$response$data !== void 0 && _e$response$data.error)) {
                  _context27.next = 8;
                  break;
                }

                cnRequestID = e.response.headers['cn-request-id']; // cnRequestID will be the same as requestId if it receives the X-Request-ID header

                errMessage = "Server returned error: [".concat(e.response.status.toString(), "] [").concat(e.response.data.error, "] for request: [").concat(cnRequestID, ", ").concat(requestId, "]");
                console.error(errMessage);
                throw new Error(errMessage);

              case 8:
                if ('response' in e) {
                  _context27.next = 27;
                  break;
                }

                // delete headers, may contain tokens
                if ('config' in e && e.config.headers) delete e.config.headers;
                errorMsg = "Network error while making request ".concat(requestId, " to ").concat(requestUrl, ":\nStringified Error:").concat(JSON.stringify(e), "\n");
                console.error(errorMsg, e);
                _context27.prev = 12;
                newRequestId = uuid();
                endpoint = "".concat(this.creatorNodeEndpoint, "/health_check");
                _context27.next = 17;
                return axios__default["default"](endpoint, {
                  headers: {
                    'X-Request-ID': newRequestId
                  }
                });

              case 17:
                res = _context27.sent;
                console.log("Successful health check for ".concat(requestId, ": ").concat(JSON.stringify(res.data)));
                _context27.next = 24;
                break;

              case 21:
                _context27.prev = 21;
                _context27.t0 = _context27["catch"](12);
                console.error("Failed health check immediately after network error ".concat(requestId), _context27.t0);

              case 24:
                throw new Error("".concat(errorMsg).concat(e));

              case 27:
                _errorMsg = "Unknown error while making request ".concat(requestId, " to ").concat(requestUrl, ":\nStringified Error:").concat(JSON.stringify(e), "\n");
                console.error(_errorMsg, e);
                throw e;

              case 30:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this, [[12, 21]]);
      }));

      function _handleErrorHelper(_x31, _x32) {
        return _handleErrorHelper2.apply(this, arguments);
      }

      return _handleErrorHelper;
    }()
  }], [{
    key: "getPrimary",
    value: function getPrimary(endpoints) {
      return endpoints ? endpoints.split(',')[0] : '';
    }
    /**
     * Pulls off the secondary creator nodes from a creator node endpoint string.
     * @param endpoints user.creator_node_endpoint
     */

  }, {
    key: "getSecondaries",
    value: function getSecondaries(endpoints) {
      return endpoints ? endpoints.split(',').slice(1) : [];
    }
    /**
     * Pulls the user's creator nodes out of the list
     * @param endpoints user.creator_node_endpoint
     */

  }, {
    key: "getEndpoints",
    value: function getEndpoints(endpoints) {
      return endpoints ? endpoints.split(',') : [];
    }
    /**
     * Builds the creator_node_endpoint value off of a primary and secondaries list
     * @param primary the primary endpoint
     * @param secondaries a list of secondary endpoints
     */

  }, {
    key: "buildEndpoint",
    value: function buildEndpoint(primary, secondaries) {
      return [primary].concat(_toConsumableArray(secondaries)).join();
    }
    /**
     * Pulls off the user's clock value from a creator node endpoint and the user's wallet address.
     * @param endpoint content node endpoint
     * @param wallet user wallet address
     * @param timeout max time alloted for clock request
     * @param params optional query string params
     */

  }, {
    key: "getClockValue",
    value: function () {
      var _getClockValue = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(endpoint, wallet, timeout) {
        var params,
            baseReq,
            _yield$axios2,
            body,
            _args28 = arguments;

        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                params = _args28.length > 3 && _args28[3] !== undefined ? _args28[3] : {};
                baseReq = {
                  url: "/users/clock_status/".concat(wallet),
                  method: 'get',
                  baseURL: endpoint
                };

                if (Object.keys(params).length > 0) {
                  baseReq.params = params;
                }

                if (timeout) {
                  baseReq.timeout = timeout;
                }

                _context28.prev = 4;
                _context28.next = 7;
                return axios__default["default"](baseReq);

              case 7:
                _yield$axios2 = _context28.sent;
                body = _yield$axios2.data;
                return _context28.abrupt("return", body.data.clockValue);

              case 12:
                _context28.prev = 12;
                _context28.t0 = _context28["catch"](4);
                throw new Error("Failed to get clock value for endpoint: ".concat(endpoint, " and wallet: ").concat(wallet, " with ").concat(_context28.t0));

              case 15:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, null, [[4, 12]]);
      }));

      function getClockValue(_x33, _x34, _x35) {
        return _getClockValue.apply(this, arguments);
      }

      return getClockValue;
    }()
    /**
     * Checks if a download is available from provided creator node endpoints
     * @param endpoints creator node endpoints
     * @param trackId
     */

  }, {
    key: "checkIfDownloadAvailable",
    value: function () {
      var _checkIfDownloadAvailable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(endpoints, trackId) {
        var primary, req, _yield$axios3, body;

        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                primary = CreatorNode.getPrimary(endpoints);

                if (!primary) {
                  _context29.next = 9;
                  break;
                }

                req = {
                  baseURL: primary,
                  url: "/tracks/download_status/".concat(trackId),
                  method: 'get'
                };
                _context29.next = 5;
                return axios__default["default"](req);

              case 5:
                _yield$axios3 = _context29.sent;
                body = _yield$axios3.data;

                if (!body.data.cid) {
                  _context29.next = 9;
                  break;
                }

                return _context29.abrupt("return", body.data.cid);

              case 9:
                return _context29.abrupt("return", null);

              case 10:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29);
      }));

      function checkIfDownloadAvailable(_x36, _x37) {
        return _checkIfDownloadAvailable.apply(this, arguments);
      }

      return checkIfDownloadAvailable;
    }()
  }]);

  return CreatorNode;
}();

var CREATOR_NODE_SERVICE_NAME = 'content-node';
var DECISION_TREE_STATE;

(function (DECISION_TREE_STATE) {
  DECISION_TREE_STATE["GET_ALL_SERVICES"] = "Get All Services";
  DECISION_TREE_STATE["FILTER_TO_WHITELIST"] = "Filter To Whitelist";
  DECISION_TREE_STATE["FILTER_FROM_BLACKLIST"] = "Filter From Blacklist";
  DECISION_TREE_STATE["FILTER_OUT_UNHEALTHY_OUTDATED_AND_NO_STORAGE_SPACE"] = "Filter Out Unhealthy, Outdated, And No Storage Space";
  DECISION_TREE_STATE["FILTER_OUT_SYNC_IN_PROGRESS"] = "Filter Out Sync In Progress";
  DECISION_TREE_STATE["SELECT_PRIMARY_AND_SECONDARIES"] = "Select Primary And Secondaries";
})(DECISION_TREE_STATE || (DECISION_TREE_STATE = {}));

/**
 * In memory dictionary used to query spID from endpoint
 * Eliminates duplicate web3 calls within same session
 */

var contentNodeEndpointToSpID = {};
function getSpIDForEndpoint$1(endpoint) {
  return contentNodeEndpointToSpID[endpoint];
}
function setSpIDForEndpoint$1(endpoint, spID) {
  contentNodeEndpointToSpID[endpoint] = spID;
}
var CreatorNodeSelection$1 = /*#__PURE__*/function (_ServiceSelection) {
  _inherits(CreatorNodeSelection, _ServiceSelection);

  var _super = _createSuper(CreatorNodeSelection);

  function CreatorNodeSelection(_ref) {
    var _this;

    var creatorNode = _ref.creatorNode,
        numberOfNodes = _ref.numberOfNodes,
        ethContracts = _ref.ethContracts,
        whitelist = _ref.whitelist,
        blacklist = _ref.blacklist,
        _ref$logger = _ref.logger,
        logger = _ref$logger === void 0 ? console : _ref$logger,
        _ref$maxStorageUsedPe = _ref.maxStorageUsedPercent,
        maxStorageUsedPercent = _ref$maxStorageUsedPe === void 0 ? 95 : _ref$maxStorageUsedPe,
        _ref$timeout = _ref.timeout,
        timeout = _ref$timeout === void 0 ? null : _ref$timeout,
        _ref$equivalencyDelta = _ref.equivalencyDelta,
        equivalencyDelta = _ref$equivalencyDelta === void 0 ? null : _ref$equivalencyDelta,
        _ref$preferHigherPatc = _ref.preferHigherPatchForPrimary,
        preferHigherPatchForPrimary = _ref$preferHigherPatc === void 0 ? true : _ref$preferHigherPatc,
        _ref$preferHigherPatc2 = _ref.preferHigherPatchForSecondaries,
        preferHigherPatchForSecondaries = _ref$preferHigherPatc2 === void 0 ? true : _ref$preferHigherPatc2;

    _classCallCheck(this, CreatorNodeSelection);

    _this = _super.call(this, {
      getServices: function () {
        var _getServices = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var services;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return ethContracts.getCurrentVersion(CREATOR_NODE_SERVICE_NAME);

                case 2:
                  _this.currentVersion = _context.sent;
                  _context.next = 5;
                  return _this.ethContracts.getServiceProviderList(CREATOR_NODE_SERVICE_NAME);

                case 5:
                  services = _context.sent;
                  return _context.abrupt("return", services.map(function (e) {
                    setSpIDForEndpoint$1(e.endpoint, e.spID);
                    return e.endpoint;
                  }));

                case 7:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function getServices() {
          return _getServices.apply(this, arguments);
        }

        return getServices;
      }(),
      // Use the content node's configured whitelist if not provided
      whitelist: whitelist !== null && whitelist !== void 0 ? whitelist : creatorNode === null || creatorNode === void 0 ? void 0 : creatorNode.passList,
      blacklist: blacklist !== null && blacklist !== void 0 ? blacklist : creatorNode === null || creatorNode === void 0 ? void 0 : creatorNode.blockList
    });
    _this.currentVersion = '';
    _this.creatorNode = creatorNode;
    _this.numberOfNodes = numberOfNodes;
    _this.ethContracts = ethContracts;
    _this.timeout = timeout;
    _this.equivalencyDelta = equivalencyDelta;
    _this.preferHigherPatchForPrimary = preferHigherPatchForPrimary;
    _this.preferHigherPatchForSecondaries = preferHigherPatchForSecondaries;
    _this.logger = logger;
    _this.healthCheckPath = 'health_check/verbose'; // String array of healthy Content Node endpoints

    _this.backupsList = [];
    _this.backupTimings = []; // Max percentage (represented out of 100) allowed before determining CN is unsuitable for selection

    _this.maxStorageUsedPercent = maxStorageUsedPercent; // The decision tree path that was taken. Reset on each new selection.

    _this.decisionTree = [];
    return _this;
  }
  /**
   * Selects a primary and secondary Content Nodes. Order of preference is highest version, then response time.
   *
   * 1. Retrieve all the Content Node services
   * 2. Filter from/out Content Nodes based off of the whitelist and blacklist
   * 3. Filter out unhealthy, outdated, and still syncing nodes via health and sync check
   * 4. Sort by healthiest (highest version -> lowest version); secondary check if equal version based off of responseTime
   * 5. Select a primary and numberOfNodes-1 number of secondaries (most likely 2) from backups
   * @param performSyncCheck whether or not to check whether the nodes need syncs before selection
   */


  _createClass(CreatorNodeSelection, [{
    key: "select",
    value: function () {
      var _select = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var performSyncCheck,
            log,
            services,
            _yield$this$_performH,
            healthyServicesList,
            servicesMap,
            healthyServiceTimings,
            primary,
            serviceTimingsSortedByVersion,
            servicesSortedByVersion,
            backupsList,
            backupTimings,
            secondaries,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                performSyncCheck = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : true;
                log = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : true;
                // Reset decision tree and backups
                this.decisionTree = [];
                this.clearBackups();
                this.clearUnhealthy(); // Get all the Content Node endpoints on chain and filter

                _context2.next = 7;
                return this.getServices();

              case 7:
                services = _context2.sent;
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.GET_ALL_SERVICES,
                  val: services
                });

                if (this.whitelist) {
                  services = this.filterToWhitelist(services);
                }

                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.FILTER_TO_WHITELIST,
                  val: services
                });

                if (this.blacklist) {
                  services = this.filterFromBlacklist(services);
                }

                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.FILTER_FROM_BLACKLIST,
                  val: services
                }); // TODO: add a sample size selection round to not send requests to all available nodes

                if (!performSyncCheck) {
                  _context2.next = 18;
                  break;
                }

                _context2.next = 16;
                return this._performSyncChecks(services, this.timeout);

              case 16:
                services = _context2.sent;
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.FILTER_OUT_SYNC_IN_PROGRESS,
                  val: services
                });

              case 18:
                _context2.next = 20;
                return this._performHealthChecks(services);

              case 20:
                _yield$this$_performH = _context2.sent;
                healthyServicesList = _yield$this$_performH.healthyServicesList;
                servicesMap = _yield$this$_performH.healthyServicesMap;
                healthyServiceTimings = _yield$this$_performH.healthyServiceTimings;
                services = healthyServicesList;

                if (this.preferHigherPatchForPrimary) {
                  serviceTimingsSortedByVersion = sortServiceTimings({
                    serviceTimings: healthyServiceTimings,
                    currentVersion: this.currentVersion,
                    sortByVersion: true,
                    equivalencyDelta: this.equivalencyDelta
                  });
                  servicesSortedByVersion = serviceTimingsSortedByVersion.map(function (service) {
                    return service.request.id;
                  });
                  primary = this.getPrimary(servicesSortedByVersion);
                } else {
                  primary = this.getPrimary(services);
                } // `this.backupsList` & this.backupTimings are used in selecting secondaries


                backupsList = require$$0__default$3["default"].without(services, primary);
                backupTimings = healthyServiceTimings.filter(function (timing) {
                  return timing.request.id !== primary;
                });
                this.setBackupsList(backupsList, backupTimings);
                secondaries = this.getSecondaries();
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.SELECT_PRIMARY_AND_SECONDARIES,
                  val: {
                    primary: primary,
                    secondaries: secondaries.toString(),
                    services: Object.keys(servicesMap).toString()
                  }
                });

                if (log) {
                  this.logger.info('CreatorNodeSelection - final decision tree state', this.decisionTree);
                }

                return _context2.abrupt("return", {
                  primary: primary,
                  secondaries: secondaries,
                  services: servicesMap
                });

              case 33:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function select() {
        return _select.apply(this, arguments);
      }

      return select;
    }()
    /**
     * Checks the sync progress of a Content Node
     * @param service Content Node endopint
     * @param timeout ms
     */

  }, {
    key: "getSyncStatus",
    value: function () {
      var _getSyncStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(service) {
        var timeout,
            syncStatus,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                timeout = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;
                _context3.prev = 1;
                _context3.next = 4;
                return this.creatorNode.getSyncStatus(service, timeout);

              case 4:
                syncStatus = _context3.sent;
                return _context3.abrupt("return", {
                  service: service,
                  syncStatus: syncStatus,
                  error: null
                });

              case 8:
                _context3.prev = 8;
                _context3.t0 = _context3["catch"](1);
                return _context3.abrupt("return", {
                  service: service,
                  syncStatus: null,
                  error: _context3.t0
                });

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[1, 8]]);
      }));

      function getSyncStatus(_x) {
        return _getSyncStatus.apply(this, arguments);
      }

      return getSyncStatus;
    }()
    /**
     * Sets backupsList to input
     * @param backupsList string array of Content Node endpoints
     */

  }, {
    key: "setBackupsList",
    value: function setBackupsList(backupsList, backupTimings) {
      // Rest of services that are not selected as the primary are valid backups. Add as backup
      // This backups list will also be in order of descending highest version/fastest
      this.backupsList = backupsList;
      this.backupTimings = backupTimings;
    }
    /**
     * Get backups in the form of an array
     */

  }, {
    key: "getBackupsList",
    value: function getBackupsList() {
      return this.backupsList;
    }
    /**
     * Get backup timings in the form of an array
     */

  }, {
    key: "getBackupTimings",
    value: function getBackupTimings() {
      return this.backupTimings;
    }
    /**
     * Select a primary Content Node
     * @param {string[]} services all healthy Content Node endpoints
     */

  }, {
    key: "getPrimary",
    value: function getPrimary(services) {
      // Index 0 of services will be the most optimal Content Node candidate
      // TODO: fix `as` cast
      return services[0];
    }
    /**
     * Selects secondary Content Nodes
     * Returns first nodes from `services`, optionally sorted by version
     */

  }, {
    key: "getSecondaries",
    value: function getSecondaries() {
      var numberOfSecondaries = this.numberOfNodes - 1;
      var backupsList = this.getBackupsList();
      var backupTimings = this.getBackupTimings();
      var secondaries;

      if (this.preferHigherPatchForSecondaries) {
        var backupTimingsSortedByVersion = sortServiceTimings({
          serviceTimings: backupTimings,
          currentVersion: this.currentVersion,
          sortByVersion: true,
          equivalencyDelta: this.equivalencyDelta
        });
        var secondaryTimings = backupTimingsSortedByVersion.slice(0, numberOfSecondaries);
        secondaries = secondaryTimings.map(function (timing) {
          return timing.request.id;
        });
      } else {
        secondaries = backupsList.slice(0, numberOfSecondaries);
      }

      return secondaries;
    }
    /**
     * Performs a sync check for every endpoint in services. Returns an array of successful sync checked endpoints and
     * adds the err'd sync checked endpoints to this.unhealthy
     * @param services content node endpoints
     * @param timeout ms applied to each request
     */

  }, {
    key: "_performSyncChecks",
    value: function () {
      var _performSyncChecks2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(services) {
        var _this2 = this;

        var timeout,
            successfulSyncCheckServices,
            syncResponses,
            _iterator,
            _step,
            response,
            syncStatus,
            isBehind,
            isConfigured,
            firstTimeCreator,
            existingCreator,
            _args5 = arguments;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                timeout = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : null;
                successfulSyncCheckServices = [];
                _context5.next = 4;
                return Promise.all(services.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(service) {
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return _this2.getSyncStatus(service, timeout);

                          case 2:
                            return _context4.abrupt("return", _context4.sent);

                          case 3:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x3) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 4:
                syncResponses = _context5.sent;
                // Perform sync checks on all services
                _iterator = _createForOfIteratorHelper(syncResponses);
                _context5.prev = 6;

                _iterator.s();

              case 8:
                if ((_step = _iterator.n()).done) {
                  _context5.next = 23;
                  break;
                }

                response = _step.value;

                if (!response.error) {
                  _context5.next = 14;
                  break;
                }

                this.logger.warn("CreatorNodeSelection - Failed sync status check for ".concat(response.service, ": ").concat(response.error));
                this.addUnhealthy(response.service);
                return _context5.abrupt("continue", 21);

              case 14:
                syncStatus = response.syncStatus;

                if (syncStatus) {
                  _context5.next = 17;
                  break;
                }

                return _context5.abrupt("continue", 21);

              case 17:
                isBehind = syncStatus.isBehind, isConfigured = syncStatus.isConfigured; // a first time creator will have a sync status as isBehind = true and isConfigured = false. this is ok

                firstTimeCreator = isBehind && !isConfigured; // an existing creator will have a sync status (assuming healthy) as isBehind = false and isConfigured = true. this is also ok

                existingCreator = !isBehind && isConfigured; // if either of these two are true, the cnode is suited to be selected

                if (firstTimeCreator || existingCreator) {
                  successfulSyncCheckServices.push(response.service);
                } else {
                  // else, add to unhealthy
                  this.addUnhealthy(response.service);
                }

              case 21:
                _context5.next = 8;
                break;

              case 23:
                _context5.next = 28;
                break;

              case 25:
                _context5.prev = 25;
                _context5.t0 = _context5["catch"](6);

                _iterator.e(_context5.t0);

              case 28:
                _context5.prev = 28;

                _iterator.f();

                return _context5.finish(28);

              case 31:
                return _context5.abrupt("return", successfulSyncCheckServices);

              case 32:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[6, 25, 28, 31]]);
      }));

      function _performSyncChecks(_x2) {
        return _performSyncChecks2.apply(this, arguments);
      }

      return _performSyncChecks;
    }()
    /**
     * Performs a health check for every endpoint in services. Returns an array of successful health checked endpoints and
     * adds the err'd health checked endpoints to this.unhealthy, and a mapping of successful endpoint to its health check response.
     * @param services content node endpoints
     */

  }, {
    key: "_performHealthChecks",
    value: function () {
      var _performHealthChecks2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(services) {
        var _this3 = this,
            _this$creatorNode;

        var healthCheckedServices, healthyServices, servicesMap, healthyServicesList;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return timeRequests$1({
                  requests: services.map(function (node) {
                    return {
                      id: node,
                      url: "".concat(node, "/").concat(_this3.healthCheckPath)
                    };
                  }),
                  sortByVersion: false,
                  currentVersion: this.currentVersion,
                  timeout: this.timeout,
                  equivalencyDelta: this.equivalencyDelta
                });

              case 2:
                healthCheckedServices = _context6.sent;
                healthyServices = healthCheckedServices.filter(function (resp) {
                  var endpoint = resp.request.id;
                  var isHealthy = false; // Check that the health check:
                  // 1. Responded with status code 200
                  // 2. Version is up to date on major and minor
                  // 3. Has enough storage space
                  //    - Max capacity percent is defined from CN health check response. If not present,
                  //      use existing value from `this.maxStorageUsedPercent`

                  if (resp.response) {
                    var isUp = resp.response.status === 200;

                    var versionIsUpToDate = _this3.ethContracts.hasSameMajorAndMinorVersion(_this3.currentVersion, resp.response.data.data.version);

                    var _resp$response$data$d = resp.response.data.data,
                        storagePathSize = _resp$response$data$d.storagePathSize,
                        storagePathUsed = _resp$response$data$d.storagePathUsed,
                        maxStorageUsedPercent = _resp$response$data$d.maxStorageUsedPercent;

                    if (maxStorageUsedPercent) {
                      _this3.maxStorageUsedPercent = maxStorageUsedPercent;
                    } else {
                      _this3.logger.warn("maxStorageUsedPercent not found in health check response. Using constructor value of ".concat(_this3.maxStorageUsedPercent, "% as maxStorageUsedPercent."));
                    }

                    var hasEnoughStorage = _this3._hasEnoughStorageSpace(storagePathSize, storagePathUsed);

                    isHealthy = isUp && versionIsUpToDate && hasEnoughStorage;
                  }

                  if (!isHealthy) {
                    _this3.addUnhealthy(endpoint);
                  }

                  return isHealthy;
                }); // Create a mapping of healthy services and their responses. Used on dapp to display the healthy services for selection
                // Also update services to be healthy services

                servicesMap = {};
                healthyServicesList = healthyServices.map(function (service) {
                  var _service$response;

                  var requestId = service.request.id;
                  servicesMap[requestId] = (_service$response = service.response) === null || _service$response === void 0 ? void 0 : _service$response.data;
                  return service.request.id;
                });
                this.decisionTree.push({
                  stage: DECISION_TREE_STATE.FILTER_OUT_UNHEALTHY_OUTDATED_AND_NO_STORAGE_SPACE,
                  val: healthyServicesList
                }); // Record metrics

                if ((_this$creatorNode = this.creatorNode) !== null && _this$creatorNode !== void 0 && _this$creatorNode.monitoringCallbacks.healthCheck) {
                  healthCheckedServices.forEach(function (check) {
                    var _check$response;

                    if ((_check$response = check.response) !== null && _check$response !== void 0 && _check$response.data) {
                      var url = new URL(check.request.url);
                      var data = check.response.data.data;

                      try {
                        // @ts-expect-error we make a check that it exists above, not sure why this isn't caught
                        _this3.creatorNode.monitoringCallbacks.healthCheck({
                          endpoint: url.origin,
                          pathname: url.pathname,
                          searchParams: url.searchParams,
                          version: data.version,
                          git: data.git,
                          selectedDiscoveryNode: data.selectedDiscoveryProvider,
                          databaseSize: data.databaseSize,
                          databaseConnections: data.databaseConnections,
                          totalMemory: data.totalMemory,
                          usedMemory: data.usedMemory,
                          totalStorage: data.storagePathSize,
                          usedStorage: data.storagePathUsed,
                          maxFileDescriptors: data.maxFileDescriptors,
                          allocatedFileDescriptors: data.allocatedFileDescriptors,
                          receivedBytesPerSec: data.receivedBytesPerSec,
                          transferredBytesPerSec: data.transferredBytesPerSec,
                          transcodeWaiting: data.transcodeWaiting,
                          transcodeActive: data.transcodeActive,
                          fileProcessingWaiting: data.fileProcessingWaiting,
                          fileProcessingActive: data.fileProcessingActive
                        });
                      } catch (e) {
                        // Swallow errors -- this method should not throw generally
                        _this3.logger.error(e);
                      }
                    }
                  });
                }

                return _context6.abrupt("return", {
                  healthyServicesList: healthyServicesList,
                  healthyServicesMap: servicesMap,
                  healthyServiceTimings: healthyServices
                });

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _performHealthChecks(_x4) {
        return _performHealthChecks2.apply(this, arguments);
      }

      return _performHealthChecks;
    }()
  }, {
    key: "_hasEnoughStorageSpace",
    value: function _hasEnoughStorageSpace(storagePathSize, storagePathUsed) {
      // If for any reason these values off the response is falsy value, default to enough storage
      if (storagePathSize === null || storagePathSize === undefined || storagePathUsed === null || storagePathUsed === undefined) {
        return true;
      }

      return 100 * storagePathUsed / storagePathSize < this.maxStorageUsedPercent;
    }
  }]);

  return CreatorNodeSelection;
}(ServiceSelection);

var creatorNode = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CreatorNode: CreatorNode$6,
  getSpIDForEndpoint: getSpIDForEndpoint$1,
  setSpIDForEndpoint: setSpIDForEndpoint$1,
  CreatorNodeSelection: CreatorNodeSelection$1
});

var require$$10 = /*@__PURE__*/getAugmentedNamespace(creatorNode);

var DISCOVERY_PROVIDER_TIMESTAMP = '@audius/libs:discovery-node-timestamp';
var DISCOVERY_SERVICE_NAME = 'discovery-node';
var DEFAULT_UNHEALTHY_BLOCK_DIFF = 15;
var REGRESSED_MODE_TIMEOUT = 2 * 60 * 1000; // two minutes
// When to time out the cached discovery provider

var DISCOVERY_PROVIDER_RESELECT_TIMEOUT = 10
/* min */
* 60
/* seconds */
* 1000;
var REQUEST_TIMEOUT_MS = 30
/* seconds */
* 1000;
/* millisec */

/* eslint-disable @typescript-eslint/restrict-plus-operands */
var getUsers = function getUsers() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var idsArray = arguments.length > 2 ? arguments[2] : undefined;
  var walletAddress = arguments.length > 3 ? arguments[3] : undefined;
  var handle = arguments.length > 4 ? arguments[4] : undefined;
  var isCreator = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
  var minBlockNumber = arguments.length > 6 ? arguments[6] : undefined;
  var queryParams = {
    limit: limit,
    offset: offset
  };

  if (isCreator !== null) {
    queryParams.is_creator = isCreator;
  }

  if (handle) {
    queryParams.handle = handle;
  }

  if (walletAddress) {
    queryParams.wallet = walletAddress;
  }

  if (minBlockNumber) {
    queryParams.min_block_number = minBlockNumber;
  }

  if (idsArray != null) {
    if (!Array.isArray(idsArray)) {
      throw new Error('Expected integer array of user ids');
    }

    queryParams.id = idsArray;
  }

  var req = {
    endpoint: 'users',
    queryParams: queryParams
  };
  return req;
};
var getTracks = function getTracks() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var idsArray = arguments.length > 2 ? arguments[2] : undefined;
  var targetUserId = arguments.length > 3 ? arguments[3] : undefined;
  var sort = arguments.length > 4 ? arguments[4] : undefined;
  var minBlockNumber = arguments.length > 5 ? arguments[5] : undefined;
  var filterDeleted = arguments.length > 6 ? arguments[6] : undefined;
  var withUsers = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var queryParams = {
    limit: limit,
    offset: offset
  };

  if (idsArray) {
    if (!Array.isArray(idsArray)) {
      throw new Error('Expected array of track ids');
    }

    queryParams.id = idsArray;
  }

  if (minBlockNumber) {
    queryParams.min_block_number = minBlockNumber;
  }

  if (targetUserId) {
    queryParams.user_id = targetUserId;
  }

  if (sort) {
    queryParams.sort = sort;
  }

  if (typeof filterDeleted === 'boolean') {
    queryParams.filter_deleted = filterDeleted;
  }

  if (withUsers) {
    queryParams.with_users = true;
  }

  var req = {
    endpoint: 'tracks',
    queryParams: queryParams
  };
  return req;
};
var getTracksByHandleAndSlug = function getTracksByHandleAndSlug(handle, slug) {
  return {
    endpoint: 'v1/tracks',
    method: 'get',
    queryParams: {
      handle: handle,
      slug: slug
    }
  };
};
var getTracksIncludingUnlisted = function getTracksIncludingUnlisted(identifiers) {
  var withUsers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var queryParams = {};

  if (withUsers) {
    queryParams.with_users = true;
  }

  var req = {
    endpoint: 'tracks_including_unlisted',
    method: 'post',
    data: {
      tracks: identifiers
    },
    queryParams: queryParams
  };
  return req;
};
var getRandomTracks = function getRandomTracks(genre, limit, exclusionList, time) {
  var req = {
    endpoint: 'tracks/random',
    queryParams: {
      genre: genre,
      limit: limit,
      exclusionList: exclusionList,
      time: time
    }
  };
  return req;
};
var getStemsForTrack = function getStemsForTrack(trackId) {
  var req = {
    endpoint: "stems/".concat(trackId),
    queryParams: {
      with_users: true
    }
  };
  return req;
};
var getRemixesOfTrack = function getRemixesOfTrack(trackId) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var req = {
    endpoint: "remixes/".concat(trackId, "/children"),
    queryParams: {
      with_users: true,
      limit: limit,
      offset: offset
    }
  };
  return req;
};
var getRemixTrackParents = function getRemixTrackParents(trackId) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var req = {
    endpoint: "remixes/".concat(trackId, "/parents"),
    queryParams: {
      with_users: true,
      limit: limit,
      offset: offset
    }
  };
  return req;
};
var getTrendingTracks = function getTrendingTracks() {
  var genre = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var timeFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var idsArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var withUsers = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var endpoint = '/trending/';

  if (timeFrame != null) {
    switch (timeFrame) {
      case 'day':
      case 'week':
      case 'month':
      case 'year':
        break;

      default:
        throw new Error('Invalid timeFrame value provided');
    }

    endpoint += "".concat(endpoint).concat(timeFrame);
  }

  var req = {
    endpoint: endpoint,
    method: 'get',
    queryParams: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, idsArray !== null ? {
      id: idsArray
    } : {}), limit !== null ? {
      limit: limit
    } : {}), offset !== null ? {
      offset: offset
    } : {}), genre !== null ? {
      genre: genre
    } : {}), withUsers ? {
      with_users: withUsers
    } : {})
  };
  return req;
};
var getPlaylists = function getPlaylists() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var idsArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var targetUserId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var withUsers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  if (idsArray != null) {
    if (!Array.isArray(idsArray)) {
      throw new Error('Expected integer array of user ids');
    }
  }

  return {
    endpoint: 'playlists',
    queryParams: _objectSpread2(_objectSpread2(_objectSpread2({
      limit: limit,
      offset: offset
    }, idsArray != null ? {
      playlist_id: idsArray
    } : {}), targetUserId ? {
      user_id: targetUserId
    } : {}), withUsers ? {
      with_users: true
    } : {})
  };
};
var getSocialFeed = function getSocialFeed(filter) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var withUsers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var tracksOnly = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  return {
    endpoint: 'feed',
    queryParams: {
      filter: filter,
      limit: limit,
      offset: offset,
      with_users: withUsers,
      tracks_only: tracksOnly
    }
  };
};
var getUserRepostFeed = function getUserRepostFeed(userId) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var withUsers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return {
    endpoint: 'feed',
    urlParams: '/reposts/' + userId,
    queryParams: {
      limit: limit,
      offset: offset,
      with_users: withUsers
    }
  };
};
var getFollowIntersectionUsers = function getFollowIntersectionUsers() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var followeeUserId = arguments.length > 2 ? arguments[2] : undefined;
  var followerUserId = arguments.length > 3 ? arguments[3] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/intersection/follow/' + followeeUserId + '/' + followerUserId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getTrackRepostIntersectionUsers = function getTrackRepostIntersectionUsers() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var repostTrackId = arguments.length > 2 ? arguments[2] : undefined;
  var followerUserId = arguments.length > 3 ? arguments[3] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/intersection/repost/track/' + repostTrackId + '/' + followerUserId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getPlaylistRepostIntersectionUsers = function getPlaylistRepostIntersectionUsers() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var repostPlaylistId = arguments.length > 2 ? arguments[2] : undefined;
  var followerUserId = arguments.length > 3 ? arguments[3] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/intersection/repost/playlist/' + repostPlaylistId + '/' + followerUserId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getFollowersForUser = function getFollowersForUser() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var followeeUserId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/followers/' + followeeUserId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getFolloweesForUser = function getFolloweesForUser() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var followerUserId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/followees/' + followerUserId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getRepostersForTrack = function getRepostersForTrack() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var repostTrackId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/reposts/track/' + repostTrackId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getRepostersForPlaylist = function getRepostersForPlaylist() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var repostPlaylistId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/reposts/playlist/' + repostPlaylistId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getSaversForTrack = function getSaversForTrack() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var saveTrackId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/saves/track/' + saveTrackId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var getSaversForPlaylist = function getSaversForPlaylist() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var savePlaylistId = arguments.length > 2 ? arguments[2] : undefined;
  return {
    endpoint: 'users',
    urlParams: '/saves/playlist/' + savePlaylistId,
    queryParams: {
      limit: limit,
      offset: offset
    }
  };
};
var searchFull = function searchFull(text, kind) {
  var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return {
    endpoint: 'search/full',
    queryParams: {
      query: text,
      kind: kind,
      limit: limit,
      offset: offset
    }
  };
};
var searchAutocomplete = function searchAutocomplete(text) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return {
    endpoint: 'search/autocomplete',
    queryParams: {
      query: text,
      limit: limit,
      offset: offset
    }
  };
};
var searchTags = function searchTags(text) {
  var userTagCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'all';
  var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
  var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  return {
    endpoint: 'search/tags',
    queryParams: {
      query: text,
      user_tag_count: userTagCount,
      kind: kind,
      limit: limit,
      offset: offset
    }
  };
};
var getSavedPlaylists = function getSavedPlaylists() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var withUsers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    endpoint: 'saves/playlists',
    queryParams: {
      limit: limit,
      offset: offset,
      with_users: withUsers
    }
  };
};
var getSavedAlbums = function getSavedAlbums() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var withUsers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    endpoint: 'saves/albums',
    queryParams: {
      limit: limit,
      offset: offset,
      with_users: withUsers
    }
  };
};
var getSavedTracks = function getSavedTracks() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var withUsers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    endpoint: 'saves/tracks',
    queryParams: {
      limit: limit,
      offset: offset,
      with_users: withUsers
    }
  };
};
/**
 * Return user collections (saved & uploaded) along w/ users for those collections
 */

var getUserAccount = function getUserAccount(wallet) {
  if (wallet === undefined) {
    throw new Error('Expected wallet to get user account');
  }

  return {
    endpoint: 'users/account',
    queryParams: {
      wallet: wallet
    }
  };
};
var getTopPlaylists = function getTopPlaylists(type, limit, mood, filter) {
  var withUsers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  return {
    endpoint: "/top/".concat(type),
    queryParams: {
      limit: limit,
      mood: mood,
      filter: filter,
      with_users: withUsers
    }
  };
};
var getTopFolloweeWindowed = function getTopFolloweeWindowed(type, window, limit) {
  var withUsers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return {
    endpoint: "/top_followee_windowed/".concat(type, "/").concat(window),
    queryParams: {
      limit: limit,
      with_users: withUsers
    }
  };
};
var getTopFolloweeSaves = function getTopFolloweeSaves(type, limit) {
  var withUsers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    endpoint: "/top_followee_saves/".concat(type),
    queryParams: {
      limit: limit,
      with_users: withUsers
    }
  };
};
var getLatest = function getLatest(type) {
  return {
    endpoint: "/latest/".concat(type)
  };
};
var getTopCreatorsByGenres = function getTopCreatorsByGenres(genres) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var withUsers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return {
    endpoint: 'users/genre/top',
    queryParams: {
      genre: genres,
      limit: limit,
      offset: offset,
      with_users: withUsers
    }
  };
};
var getURSMContentNodes = function getURSMContentNodes(ownerWallet) {
  return {
    endpoint: 'ursm_content_nodes',
    queryParams: {
      owner_wallet: ownerWallet
    }
  };
};
var getNotifications = function getNotifications(minBlockNumber, trackIds, timeout) {
  return {
    endpoint: 'notifications',
    queryParams: {
      min_block_number: minBlockNumber,
      track_id: trackIds
    },
    timeout: timeout
  };
};
var getSolanaNotifications = function getSolanaNotifications(minSlotNumber, timeout) {
  return {
    endpoint: 'solana_notifications',
    queryParams: {
      min_slot_number: minSlotNumber
    },
    timeout: timeout
  };
};
var getTrackListenMilestones = function getTrackListenMilestones(timeout) {
  return {
    endpoint: 'track_listen_milestones',
    timeout: timeout
  };
};
var getChallengeAttestation = function getChallengeAttestation(challengeId, encodedUserId, specifier, oracleAddress) {
  return {
    endpoint: "/v1/challenges/".concat(challengeId, "/attest"),
    queryParams: {
      user_id: encodedUserId,
      specifier: specifier,
      oracle: oracleAddress
    }
  };
};
var getCreateSenderAttestation = function getCreateSenderAttestation(senderEthAddress) {
  return {
    endpoint: '/v1/challenges/attest_sender',
    queryParams: {
      sender_eth_address: senderEthAddress
    }
  };
};
var getUndisbursedChallenges = function getUndisbursedChallenges(limit, offset, completedBlockNumber, encodedUserId) {
  return {
    endpoint: '/v1/challenges/undisbursed',
    queryParams: {
      limit: limit,
      offset: offset,
      completed_blocknumber: completedBlockNumber,
      user_id: encodedUserId
    }
  };
};
var verifyToken = function verifyToken(token) {
  return {
    endpoint: '/v1/users/verify_token',
    queryParams: {
      token: token
    }
  };
};

var PREVIOUS_VERSIONS_TO_CHECK = 5;
var localStorage;

if (typeof window === 'undefined' || window === null) {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  var LocalStorage = require('node-localstorage').LocalStorage;

  localStorage = new LocalStorage('./local-storage');
} else {
  localStorage = window.localStorage;
}

var DiscoveryProviderSelection = /*#__PURE__*/function (_ServiceSelection) {
  _inherits(DiscoveryProviderSelection, _ServiceSelection);

  var _super = _createSuper(DiscoveryProviderSelection);

  function DiscoveryProviderSelection(config, ethContracts) {
    var _config$monitoringCal, _config$unhealthySlot, _config$unhealthyBloc;

    var _this;

    _classCallCheck(this, DiscoveryProviderSelection);

    _this = _super.call(this, _objectSpread2({
      /**
       * Gets the "current" expected service version as well as
       * the list of registered providers from chain
       */
      getServices: function () {
        var _getServices = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var _ref,
              _ref$verbose,
              verbose,
              services,
              _args = arguments;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref$verbose = _ref.verbose, verbose = _ref$verbose === void 0 ? false : _ref$verbose;
                  _context.next = 3;
                  return ethContracts.getCurrentVersion(DISCOVERY_SERVICE_NAME);

                case 3:
                  _this.currentVersion = _context.sent;
                  _context.next = 6;
                  return _this.ethContracts.getServiceProviderList(DISCOVERY_SERVICE_NAME);

                case 6:
                  services = _context.sent;
                  return _context.abrupt("return", verbose ? services : services.map(function (e) {
                    return e.endpoint;
                  }));

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function getServices() {
          return _getServices.apply(this, arguments);
        }

        return getServices;
      }()
    }, config));
    _this.ethContracts = ethContracts;
    _this.currentVersion = '';
    _this.reselectTimeout = config.reselectTimeout;
    _this.selectionCallback = config.selectionCallback;
    _this.monitoringCallbacks = (_config$monitoringCal = config.monitoringCallbacks) !== null && _config$monitoringCal !== void 0 ? _config$monitoringCal : {};
    _this.unhealthySlotDiffPlays = (_config$unhealthySlot = config.unhealthySlotDiffPlays) !== null && _config$unhealthySlot !== void 0 ? _config$unhealthySlot : null;
    _this.unhealthyBlockDiff = (_config$unhealthyBloc = config.unhealthyBlockDiff) !== null && _config$unhealthyBloc !== void 0 ? _config$unhealthyBloc : DEFAULT_UNHEALTHY_BLOCK_DIFF; // Whether or not we are running in `regressed` mode, meaning we were
    // unable to select a discovery provider that was up-to-date. Clients may
    // want to consider blocking writes.

    _this._regressedMode = false; // List of valid past discovery provider versions registered on chain

    _this.validVersions = null;
    return _this;
  }
  /** Retrieves a cached discovery provider from localstorage */


  _createClass(DiscoveryProviderSelection, [{
    key: "getCached",
    value: function getCached() {
      if (localStorage) {
        try {
          var discProvTimestamp = localStorage.getItem(DISCOVERY_PROVIDER_TIMESTAMP);

          if (discProvTimestamp) {
            var _JSON$parse = JSON.parse(discProvTimestamp),
                latestEndpoint = _JSON$parse.endpoint,
                timestamp = _JSON$parse.timestamp;

            var inWhitelist = !this.whitelist || this.whitelist.has(latestEndpoint);
            var timeout = this.reselectTimeout ? this.reselectTimeout : DISCOVERY_PROVIDER_RESELECT_TIMEOUT;
            var isExpired = Date.now() - timestamp > timeout;

            if (!inWhitelist || isExpired) {
              this.clearCached();
            } else {
              return latestEndpoint;
            }
          }
        } catch (e) {
          console.error('Could not retrieve cached discovery endpoint from localStorage', e);
        }
      }

      return null;
    }
    /** Clears any cached discovery provider from localstorage */

  }, {
    key: "clearCached",
    value: function clearCached() {
      if (localStorage) {
        localStorage.removeItem(DISCOVERY_PROVIDER_TIMESTAMP);
      }
    }
    /** Sets a cached discovery provider in localstorage */

  }, {
    key: "setCached",
    value: function setCached(endpoint) {
      localStorage.setItem(DISCOVERY_PROVIDER_TIMESTAMP, JSON.stringify({
        endpoint: endpoint,
        timestamp: Date.now()
      }));
    }
    /** Allows the selection take a shortcut if there's a cached provider */

  }, {
    key: "shortcircuit",
    value: function shortcircuit() {
      return this.getCached();
    }
  }, {
    key: "select",
    value: function () {
      var _select = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var endpoint;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _get(_getPrototypeOf(DiscoveryProviderSelection.prototype), "select", this).call(this);

              case 2:
                endpoint = _context2.sent;

                if (endpoint) {
                  this.setCached(endpoint);
                }

                console.info("Selected discprov ".concat(endpoint), this.decisionTree);

                if (this.selectionCallback) {
                  this.selectionCallback(endpoint, this.decisionTree);
                }

                return _context2.abrupt("return", endpoint);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function select() {
        return _select.apply(this, arguments);
      }

      return select;
    }()
    /**
     * Checks whether a given response is healthy:
     * - Not behind in blocks
     * - 200 response
     * - Current version
     *
     * Other responses are collected in `this.backups` if
     * - Behind by only a patch version
     *
     * @param response axios response
     * @param urlMap health check urls mapped to their cannonical url
     * e.g. https://discoveryprovider.audius.co/health_check => https://discoveryprovider.audius.co
     */

  }, {
    key: "isHealthy",
    value: function isHealthy(response, urlMap) {
      var status = response.status,
          data = response.data;
      var _data$data = data.data,
          blockDiff = _data$data.block_difference,
          service = _data$data.service,
          version = _data$data.version,
          plays = _data$data.plays;
      var slotDiffPlays = null;

      if (plays !== null && plays !== void 0 && plays.tx_info) {
        slotDiffPlays = plays.tx_info.slot_diff;
      }

      if ('healthCheck' in this.monitoringCallbacks) {
        var url = new URL(response.config.url);

        try {
          this.monitoringCallbacks.healthCheck({
            endpoint: url.origin,
            pathname: url.pathname,
            queryString: url.search,
            version: version,
            git: data.data.git,
            blockDifference: blockDiff,
            slotDifferencePlays: slotDiffPlays,
            databaseBlockNumber: data.data.db.number,
            webBlockNumber: data.data.web.blocknumber,
            databaseSize: data.data.database_size,
            databaseConnections: data.data.database_connections,
            totalMemory: data.data.total_memory,
            usedMemory: data.data.used_memory,
            totalStorage: data.data.filesystem_size,
            usedStorage: data.data.filesystem_used,
            receivedBytesPerSec: data.received_bytes_per_sec,
            transferredBytesPerSec: data.transferred_bytes_per_sec,
            challengeLastEventAgeSec: data.challenge_last_event_age_sec
          });
        } catch (e) {
          // Swallow errors -- this method should not throw generally
          console.error(e);
        }
      }

      if (status !== 200) return false;
      if (service !== DISCOVERY_SERVICE_NAME) return false;
      if (!semver__default["default"].valid(version)) return false; // If this service is not the same major/minor as what's on chain, reject

      if (!this.ethContracts.hasSameMajorAndMinorVersion(this.currentVersion, version)) {
        return false;
      } // If this service is behind by patches, add it as a backup and reject


      if (semver__default["default"].patch(version) < semver__default["default"].patch(this.currentVersion)) {
        this.addBackup(urlMap[response.config.url], data.data);
        return false;
      } // If this service is an unhealthy block diff behind, add it as a backup and reject


      if (blockDiff > this.unhealthyBlockDiff) {
        this.addBackup(urlMap[response.config.url], data.data);
        return false;
      } // If this service is an unhealthy slot diff behind on the plays table, add it
      // as a backup and reject


      if (slotDiffPlays !== null && this.unhealthySlotDiffPlays !== null && slotDiffPlays > this.unhealthySlotDiffPlays) {
        this.addBackup(urlMap[response.config.url], data.data);
        return false;
      }

      return true;
    }
    /**
     * Estabilishes that connection to discovery providers has regressed
     */

  }, {
    key: "enterRegressedMode",
    value: function enterRegressedMode() {
      var _this2 = this;

      console.info('Entering regressed mode');
      this._regressedMode = true;
      setTimeout(function () {
        console.info('Leaving regressed mode');
        _this2._regressedMode = false;
      }, REGRESSED_MODE_TIMEOUT);
    }
  }, {
    key: "setUnhealthyBlockDiff",
    value: function setUnhealthyBlockDiff() {
      var updatedDiff = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_UNHEALTHY_BLOCK_DIFF;
      this.unhealthyBlockDiff = updatedDiff;
    }
  }, {
    key: "setUnhealthySlotDiffPlays",
    value: function setUnhealthySlotDiffPlays(updatedDiff) {
      this.unhealthySlotDiffPlays = updatedDiff;
    }
  }, {
    key: "isInRegressedMode",
    value: function isInRegressedMode() {
      return this._regressedMode;
    }
    /**
     * In the case of no "healthy" services, we resort to backups in the following order:
     * 1. Pick the most recent (patch) version that's not behind
     * 2. Pick the least behind provider that is a valid patch version and enter "regressed mode"
     * 3. Pick `null`
     */

  }, {
    key: "selectFromBackups",
    value: function () {
      var _selectFromBackups = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this3 = this,
            _blockDiffMap$bestBlo;

        var versions, blockDiffs, versionMap, blockDiffMap, numberOfVersions, i, pastServiceVersion, sortedVersions, selected, _iterator, _step, version, endpoints, _i2, _this$backups$endpoin, bestBlockDiff;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                versions = [];
                blockDiffs = [];
                versionMap = {};
                blockDiffMap = {}; // Go backwards in time on chain and get the registered versions up to PREVIOUS_VERSIONS_TO_CHECK.
                // Record those versions in a set and validate any backups against that set.
                // TODO: Clean up this logic when we can validate a specific version rather
                // than traversing backwards through all the versions

                if (this.validVersions) {
                  _context3.next = 18;
                  break;
                }

                this.validVersions = [this.currentVersion];
                _context3.next = 8;
                return this.ethContracts.getNumberOfVersions(DISCOVERY_SERVICE_NAME);

              case 8:
                numberOfVersions = _context3.sent;
                i = 0;

              case 10:
                if (!(i < Math.min(PREVIOUS_VERSIONS_TO_CHECK, numberOfVersions - 1))) {
                  _context3.next = 18;
                  break;
                }

                _context3.next = 13;
                return this.ethContracts.getVersion(DISCOVERY_SERVICE_NAME, // Exclude the latest version when querying older versions
                // Latest index is numberOfVersions - 1, so 2nd oldest version starts at numberOfVersions - 2
                numberOfVersions - 2 - i);

              case 13:
                pastServiceVersion = _context3.sent;
                this.validVersions.push(pastServiceVersion);

              case 15:
                ++i;
                _context3.next = 10;
                break;

              case 18:
                // Go through each backup and create two keyed maps:
                // { semver => [provider] }
                // { blockdiff => [provider] }
                Object.keys(this.backups).forEach(function (backup) {
                  var _this3$backups$backup = _this3.backups[backup],
                      blockDiff = _this3$backups$backup.block_difference,
                      version = _this3$backups$backup.version;
                  var isVersionOk = false;

                  for (var _i = 0; _i < _this3.validVersions.length; ++_i) {
                    var _this3$validVersions;

                    if (_this3.ethContracts.hasSameMajorAndMinorVersion((_this3$validVersions = _this3.validVersions) === null || _this3$validVersions === void 0 ? void 0 : _this3$validVersions[_i], version)) {
                      isVersionOk = true;
                      break;
                    }
                  } // Filter out any version that wasn't valid given what's registered on chain


                  if (!isVersionOk) return;
                  versions.push(version);
                  blockDiffs.push(blockDiff);

                  if (version in versionMap) {
                    var _versionMap$version;

                    (_versionMap$version = versionMap[version]) === null || _versionMap$version === void 0 ? void 0 : _versionMap$version.push(backup);
                  } else {
                    versionMap[version] = [backup];
                  }

                  if (blockDiff in blockDiffMap) {
                    var _blockDiffMap$blockDi;

                    (_blockDiffMap$blockDi = blockDiffMap[blockDiff]) === null || _blockDiffMap$blockDi === void 0 ? void 0 : _blockDiffMap$blockDi.push(backup);
                  } else {
                    blockDiffMap[blockDiff] = [backup];
                  }
                }); // Sort the versions by desc semver

                sortedVersions = versions.sort(semver__default["default"].rcompare); // Select the closest version that's a healthy # of blocks behind

                selected = '';
                _iterator = _createForOfIteratorHelper(sortedVersions);
                _context3.prev = 22;

                _iterator.s();

              case 24:
                if ((_step = _iterator.n()).done) {
                  _context3.next = 39;
                  break;
                }

                version = _step.value;
                endpoints = versionMap[version];
                _i2 = 0;

              case 28:
                if (!(_i2 < endpoints.length)) {
                  _context3.next = 35;
                  break;
                }

                if (!(((_this$backups$endpoin = this.backups[endpoints[_i2]]) === null || _this$backups$endpoin === void 0 ? void 0 : _this$backups$endpoin.block_difference) < this.unhealthyBlockDiff)) {
                  _context3.next = 32;
                  break;
                }

                selected = endpoints[_i2];
                return _context3.abrupt("break", 35);

              case 32:
                ++_i2;
                _context3.next = 28;
                break;

              case 35:
                if (!selected) {
                  _context3.next = 37;
                  break;
                }

                return _context3.abrupt("return", selected);

              case 37:
                _context3.next = 24;
                break;

              case 39:
                _context3.next = 44;
                break;

              case 41:
                _context3.prev = 41;
                _context3.t0 = _context3["catch"](22);

                _iterator.e(_context3.t0);

              case 44:
                _context3.prev = 44;

                _iterator.f();

                return _context3.finish(44);

              case 47:
                // Select the best block diff provider
                // eslint-disable-next-line @typescript-eslint/require-array-sort-compare
                bestBlockDiff = blockDiffs.sort()[0];
                selected = (_blockDiffMap$bestBlo = blockDiffMap[bestBlockDiff]) === null || _blockDiffMap$bestBlo === void 0 ? void 0 : _blockDiffMap$bestBlo[0];
                this.enterRegressedMode();
                return _context3.abrupt("return", selected);

              case 51:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[22, 41, 44, 47]]);
      }));

      function selectFromBackups() {
        return _selectFromBackups.apply(this, arguments);
      }

      return selectFromBackups;
    }()
  }]);

  return DiscoveryProviderSelection;
}(ServiceSelection);

var MAX_MAKE_REQUEST_RETRY_COUNT = 5;
var MAX_MAKE_REQUEST_RETRIES_WITH_404 = 2;
/**
 * Constructs a service class for a discovery node
 * @param whitelist whether or not to only include specified nodes in selection
 * @param userStateManager singleton UserStateManager instance
 * @param ethContracts singleton EthContracts instance
 * @param web3Manager
 * @param reselectTimeout timeout to clear locally cached discovery providers
 * @param selectionCallback invoked when a discovery node is selected
 * @param monitoringCallbacks callbacks to be invoked with metrics from requests sent to a service
 *  @param monitoringCallbacks.request
 *  @param monitoringCallbacks.healthCheck
 * @param selectionRequestTimeout the amount of time (ms) an individual request should take before reselecting
 * @param selectionRequestRetries the number of retries to a given discovery node we make before reselecting
 * @param unhealthySlotDiffPlays the number of slots we would consider a discovery node unhealthy
 * @param unhealthyBlockDiff the number of missed blocks after which we would consider a discovery node unhealthy
 */

var DiscoveryProvider = /*#__PURE__*/function () {
  function DiscoveryProvider(whitelist, blacklist, userStateManager, ethContracts, web3Manager, reselectTimeout, selectionCallback, monitoringCallbacks, selectionRequestTimeout, selectionRequestRetries, unhealthySlotDiffPlays, unhealthyBlockDiff) {
    _classCallCheck(this, DiscoveryProvider);

    this.whitelist = whitelist;
    this.blacklist = blacklist;
    this.userStateManager = userStateManager;
    this.ethContracts = ethContracts;
    this.web3Manager = web3Manager;
    this.unhealthyBlockDiff = unhealthyBlockDiff !== null && unhealthyBlockDiff !== void 0 ? unhealthyBlockDiff : DEFAULT_UNHEALTHY_BLOCK_DIFF;
    this.serviceSelector = new DiscoveryProviderSelection({
      whitelist: this.whitelist,
      blacklist: this.blacklist,
      reselectTimeout: reselectTimeout,
      selectionCallback: selectionCallback,
      monitoringCallbacks: monitoringCallbacks,
      requestTimeout: selectionRequestTimeout,
      unhealthySlotDiffPlays: unhealthySlotDiffPlays,
      unhealthyBlockDiff: this.unhealthyBlockDiff
    }, this.ethContracts);
    this.selectionRequestTimeout = selectionRequestTimeout !== null && selectionRequestTimeout !== void 0 ? selectionRequestTimeout : REQUEST_TIMEOUT_MS;
    this.selectionRequestRetries = selectionRequestRetries !== null && selectionRequestRetries !== void 0 ? selectionRequestRetries : MAX_MAKE_REQUEST_RETRY_COUNT;
    this.unhealthySlotDiffPlays = unhealthySlotDiffPlays; // Keep track of the number of times a request 404s so we know when a true 404 occurs
    // Due to incident where some discovery nodes may erroneously be missing content #flare-51,
    // we treat 404s differently than generic 4xx's or other 5xx errors.
    // In the case of a 404, try a few other nodes

    this.request404Count = 0;
    this.maxRequestsForTrue404 = MAX_MAKE_REQUEST_RETRIES_WITH_404;
    this.monitoringCallbacks = monitoringCallbacks !== null && monitoringCallbacks !== void 0 ? monitoringCallbacks : {};
  }

  _createClass(DiscoveryProvider, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var endpoint, userAccount;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.serviceSelector.select();

              case 2:
                endpoint = _context.sent;
                this.setEndpoint(endpoint);

                if (!(endpoint && this.web3Manager && this.web3Manager.web3)) {
                  _context.next = 9;
                  break;
                }

                _context.next = 7;
                return this.getUserAccount(this.web3Manager.getWalletAddress());

              case 7:
                userAccount = _context.sent;
                if (userAccount) this.userStateManager.setCurrentUser(userAccount);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "setEndpoint",
    value: function setEndpoint(endpoint) {
      this.discoveryProviderEndpoint = endpoint;
    }
  }, {
    key: "setUnhealthyBlockDiff",
    value: function setUnhealthyBlockDiff() {
      var updatedBlockDiff = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_UNHEALTHY_BLOCK_DIFF;
      this.unhealthyBlockDiff = updatedBlockDiff;
      this.serviceSelector.setUnhealthyBlockDiff(updatedBlockDiff);
    }
  }, {
    key: "setUnhealthySlotDiffPlays",
    value: function setUnhealthySlotDiffPlays(updatedDiff) {
      this.unhealthySlotDiffPlays = updatedDiff;
      this.serviceSelector.setUnhealthySlotDiffPlays(updatedDiff);
    }
    /**
     * Get users with all relevant user data
     * can be filtered by providing an integer array of ids
     * @param limit
     * @param offset
     * @param idsArray
     * @param walletAddress
     * @param handle
     * @param isCreator null returns all users, true returns creators only, false returns users only
     * @returns {Object} {Array of User metadata Objects}
     * additional metadata fields on user objects:
     *  {Integer} track_count - track count for given user
     *  {Integer} playlist_count - playlist count for given user
     *  {Integer} album_count - album count for given user
     *  {Integer} follower_count - follower count for given user
     *  {Integer} followee_count - followee count for given user
     *  {Integer} repost_count - repost count for given user
     *  {Integer} track_blocknumber - blocknumber of latest track for user
     *  {Boolean} does_current_user_follow - does current user follow given user
     *  {Array} followee_follows - followees of current user that follow given user
     * @example
     * await getUsers()
     * await getUsers(100, 0, [3,2,6]) - Invalid user ids will not be accepted
     */

  }, {
    key: "getUsers",
    value: function () {
      var _getUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var limit,
            offset,
            idsArray,
            walletAddress,
            handle,
            isCreator,
            minBlockNumber,
            req,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                limit = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 100;
                offset = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;
                idsArray = _args2.length > 2 ? _args2[2] : undefined;
                walletAddress = _args2.length > 3 ? _args2[3] : undefined;
                handle = _args2.length > 4 ? _args2[4] : undefined;
                isCreator = _args2.length > 5 && _args2[5] !== undefined ? _args2[5] : null;
                minBlockNumber = _args2.length > 6 ? _args2[6] : undefined;
                req = getUsers(limit, offset, idsArray, walletAddress, handle, isCreator, minBlockNumber);
                _context2.next = 10;
                return this._makeRequest(req);

              case 10:
                return _context2.abrupt("return", _context2.sent);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getUsers$1() {
        return _getUsers.apply(this, arguments);
      }

      return getUsers$1;
    }()
    /**
     * get tracks with all relevant track data
     * can be filtered by providing an integer array of ids
     * @param limit
     * @param offset
     * @param idsArray
     * @param targetUserId the owner of the tracks being queried
     * @param sort a string of form eg. blocknumber:asc,timestamp:desc describing a sort path
     * @param minBlockNumber The min block number
     * @param filterDeleted If set to true, filters the deleted tracks
     * @returns {Object} {Array of track metadata Objects}
     * additional metadata fields on track objects:
     *  {Integer} repost_count - repost count for given track
     *  {Integer} save_count - save count for given track
     *  {Array} followee_reposts - followees of current user that have reposted given track
     *  {Boolean} has_current_user_reposted - has current user reposted given track
     *  {Boolean} has_current_user_saved - has current user saved given track
     * @example
     * await getTracks()
     * await getTracks(100, 0, [3,2,6]) - Invalid track ids will not be accepted
     */

  }, {
    key: "getTracks",
    value: function () {
      var _getTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var limit,
            offset,
            idsArray,
            targetUserId,
            sort,
            minBlockNumber,
            filterDeleted,
            withUsers,
            req,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                limit = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 100;
                offset = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;
                idsArray = _args3.length > 2 ? _args3[2] : undefined;
                targetUserId = _args3.length > 3 ? _args3[3] : undefined;
                sort = _args3.length > 4 ? _args3[4] : undefined;
                minBlockNumber = _args3.length > 5 ? _args3[5] : undefined;
                filterDeleted = _args3.length > 6 ? _args3[6] : undefined;
                withUsers = _args3.length > 7 ? _args3[7] : undefined;
                req = getTracks(limit, offset, idsArray, targetUserId, sort, minBlockNumber, filterDeleted, withUsers);
                _context3.next = 11;
                return this._makeRequest(req);

              case 11:
                return _context3.abrupt("return", _context3.sent);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getTracks$1() {
        return _getTracks.apply(this, arguments);
      }

      return getTracks$1;
    }()
    /**
     * Gets a particular track by its creator's handle and the track's URL slug
     * @param handle the handle of the owner of the track
     * @param slug the URL slug of the track, generally the title urlized
     * @returns {Object} the requested track's metadata
     */

  }, {
    key: "getTracksByHandleAndSlug",
    value: function () {
      var _getTracksByHandleAndSlug = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(handle, slug) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._makeRequest(getTracksByHandleAndSlug(handle, slug),
                /* retry */
                false);

              case 2:
                return _context4.abrupt("return", _context4.sent);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getTracksByHandleAndSlug$1(_x, _x2) {
        return _getTracksByHandleAndSlug.apply(this, arguments);
      }

      return getTracksByHandleAndSlug$1;
    }()
    /**
     * @typedef {Object} getTracksIdentifier
     * @property {string} handle
     * @property {number} id
     * @property {string} url_title
     */

    /**
     * gets all tracks matching identifiers, including unlisted.
     *
     * @param identifiers
     * @returns {(Array)} track
     */

  }, {
    key: "getTracksIncludingUnlisted",
    value: function () {
      var _getTracksIncludingUnlisted = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(identifiers) {
        var withUsers,
            req,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                withUsers = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : false;
                req = getTracksIncludingUnlisted(identifiers, withUsers);
                _context5.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context5.abrupt("return", _context5.sent);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getTracksIncludingUnlisted$1(_x3) {
        return _getTracksIncludingUnlisted.apply(this, arguments);
      }

      return getTracksIncludingUnlisted$1;
    }()
    /**
     * Gets random tracks from trending tracks for a given genre.
     * If genre not given, will return trending tracks across all genres.
     * Excludes specified track ids.
     *
     * @param genre
     * @param limit
     * @param exclusionList
     * @param time
     * @returns {(Array)} track
     */

  }, {
    key: "getRandomTracks",
    value: function () {
      var _getRandomTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(genre, limit, exclusionList, time) {
        var req;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                req = getRandomTracks(genre, limit, exclusionList, time);
                _context6.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context6.abrupt("return", _context6.sent);

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getRandomTracks$1(_x4, _x5, _x6, _x7) {
        return _getRandomTracks.apply(this, arguments);
      }

      return getRandomTracks$1;
    }()
    /**
     * Gets all stems for a given trackId as an array of tracks.
     * @param trackId
     * @returns {(Array)} track
     */

  }, {
    key: "getStemsForTrack",
    value: function () {
      var _getStemsForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(trackId) {
        var req;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                req = getStemsForTrack(trackId);
                _context7.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context7.abrupt("return", _context7.sent);

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getStemsForTrack$1(_x8) {
        return _getStemsForTrack.apply(this, arguments);
      }

      return getStemsForTrack$1;
    }()
    /**
     * Gets all the remixes of a given trackId as an array of tracks.
     * @param trackId
     * @param limit
     * @param offset
     * @returns {(Array)} track
     */

  }, {
    key: "getRemixesOfTrack",
    value: function () {
      var _getRemixesOfTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(trackId, limit, offset) {
        var req;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                req = getRemixesOfTrack(trackId, limit, offset);
                _context8.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context8.abrupt("return", _context8.sent);

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getRemixesOfTrack$1(_x9, _x10, _x11) {
        return _getRemixesOfTrack.apply(this, arguments);
      }

      return getRemixesOfTrack$1;
    }()
    /**
     * Gets the remix parents of a given trackId as an array of tracks.
     * @param limit
     * @param offset
     * @returns {(Array)} track
     */

  }, {
    key: "getRemixTrackParents",
    value: function () {
      var _getRemixTrackParents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(trackId, limit, offset) {
        var req;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                req = getRemixTrackParents(trackId, limit, offset);
                _context9.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context9.abrupt("return", _context9.sent);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getRemixTrackParents$1(_x12, _x13, _x14) {
        return _getRemixTrackParents.apply(this, arguments);
      }

      return getRemixTrackParents$1;
    }()
    /**
     * Gets tracks trending on Audius.
     * @param genre
     * @param timeFrame one of day, week, month, or year
     * @param idsArray track ids
     * @param limit
     * @param offset
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(genre, timeFrame, idsArray, limit, offset) {
        var withUsers,
            req,
            _args10 = arguments;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                withUsers = _args10.length > 5 && _args10[5] !== undefined ? _args10[5] : false;
                req = getTrendingTracks(genre, timeFrame, idsArray, limit, offset, withUsers);
                _context10.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context10.abrupt("return", _context10.sent);

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getTrendingTracks$1(_x15, _x16, _x17, _x18, _x19) {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks$1;
    }()
    /**
     * get full playlist objects, including tracks, for passed in array of playlistId
     * @returns {Array} array of playlist objects
     * additional metadata fields on playlist objects:
     *  {Integer} repost_count - repost count for given playlist
     *  {Integer} save_count - save count for given playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given playlist
     *  {Array} followee_reposts - followees of current user that have reposted given playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given playlist
     *  {Boolean} has_current_user_saved - has current user saved given playlist
     */

  }, {
    key: "getPlaylists",
    value: function () {
      var _getPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var limit,
            offset,
            idsArray,
            targetUserId,
            withUsers,
            req,
            _args11 = arguments;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                limit = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : 100;
                offset = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : 0;
                idsArray = _args11.length > 2 && _args11[2] !== undefined ? _args11[2] : null;
                targetUserId = _args11.length > 3 && _args11[3] !== undefined ? _args11[3] : null;
                withUsers = _args11.length > 4 && _args11[4] !== undefined ? _args11[4] : false;
                req = getPlaylists(limit, offset, idsArray, targetUserId, withUsers);
                _context11.next = 8;
                return this._makeRequest(req);

              case 8:
                return _context11.abrupt("return", _context11.sent);

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getPlaylists$1() {
        return _getPlaylists.apply(this, arguments);
      }

      return getPlaylists$1;
    }()
    /**
     * Return social feed for current user
     * @param filter - filter by "all", "original", or "repost"
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     * @returns {Object} {Array of track and playlist metadata objects}
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */

  }, {
    key: "getSocialFeed",
    value: function () {
      var _getSocialFeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(filter) {
        var limit,
            offset,
            withUsers,
            tracksOnly,
            req,
            _args12 = arguments;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                limit = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : 100;
                offset = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : 0;
                withUsers = _args12.length > 3 && _args12[3] !== undefined ? _args12[3] : false;
                tracksOnly = _args12.length > 4 && _args12[4] !== undefined ? _args12[4] : false;
                req = getSocialFeed(filter, limit, offset, withUsers, tracksOnly);
                _context12.next = 7;
                return this._makeRequest(req);

              case 7:
                return _context12.abrupt("return", _context12.sent);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getSocialFeed$1(_x20) {
        return _getSocialFeed.apply(this, arguments);
      }

      return getSocialFeed$1;
    }()
    /**
     * Return repost feed for requested user
     * @param userId - requested user id
     * @param limit - max # of items to return (for pagination)
     * @param offset - offset into list to return from (for pagination)
     * @returns {Object} {Array of track and playlist metadata objects}
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */

  }, {
    key: "getUserRepostFeed",
    value: function () {
      var _getUserRepostFeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(userId) {
        var limit,
            offset,
            withUsers,
            req,
            _args13 = arguments;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                limit = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : 100;
                offset = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : 0;
                withUsers = _args13.length > 3 && _args13[3] !== undefined ? _args13[3] : false;
                req = getUserRepostFeed(userId, limit, offset, withUsers);
                _context13.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context13.abrupt("return", _context13.sent);

              case 7:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getUserRepostFeed$1(_x21) {
        return _getUserRepostFeed.apply(this, arguments);
      }

      return getUserRepostFeed$1;
    }()
    /**
     * get intersection of users that follow followeeUserId and users that are followed by followerUserId
     * @param followeeUserId user that is followed
     * @param followerUserId user that follows
     * @example
     * getFollowIntersectionUsers(100, 0, 1, 1) - IDs must be valid
     */

  }, {
    key: "getFollowIntersectionUsers",
    value: function () {
      var _getFollowIntersectionUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var limit,
            offset,
            followeeUserId,
            followerUserId,
            req,
            _args14 = arguments;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                limit = _args14.length > 0 && _args14[0] !== undefined ? _args14[0] : 100;
                offset = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : 0;
                followeeUserId = _args14.length > 2 ? _args14[2] : undefined;
                followerUserId = _args14.length > 3 ? _args14[3] : undefined;
                req = getFollowIntersectionUsers(limit, offset, followeeUserId, followerUserId);
                _context14.next = 7;
                return this._makeRequest(req);

              case 7:
                return _context14.abrupt("return", _context14.sent);

              case 8:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getFollowIntersectionUsers$1() {
        return _getFollowIntersectionUsers.apply(this, arguments);
      }

      return getFollowIntersectionUsers$1;
    }()
    /**
     * get intersection of users that have reposted repostTrackId and users that are followed by followerUserId
     * followee = user that is followed; follower = user that follows
     * @param repostTrackId track that is reposted
     * @param followerUserId user that reposted track
     * @example
     * getTrackRepostIntersectionUsers(100, 0, 1, 1) - IDs must be valid
     */

  }, {
    key: "getTrackRepostIntersectionUsers",
    value: function () {
      var _getTrackRepostIntersectionUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        var limit,
            offset,
            repostTrackId,
            followerUserId,
            req,
            _args15 = arguments;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                limit = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : 100;
                offset = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : 0;
                repostTrackId = _args15.length > 2 ? _args15[2] : undefined;
                followerUserId = _args15.length > 3 ? _args15[3] : undefined;
                req = getTrackRepostIntersectionUsers(limit, offset, repostTrackId, followerUserId);
                _context15.next = 7;
                return this._makeRequest(req);

              case 7:
                return _context15.abrupt("return", _context15.sent);

              case 8:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getTrackRepostIntersectionUsers$1() {
        return _getTrackRepostIntersectionUsers.apply(this, arguments);
      }

      return getTrackRepostIntersectionUsers$1;
    }()
    /**
     * get intersection of users that have reposted repostPlaylistId and users that are followed by followerUserId
     * followee = user that is followed; follower = user that follows
     * @param repostPlaylistId playlist that is reposted
     * @param followerUserId user that reposted track
     * @example
     * getPlaylistRepostIntersectionUsers(100, 0, 1, 1) - IDs must be valid
     */

  }, {
    key: "getPlaylistRepostIntersectionUsers",
    value: function () {
      var _getPlaylistRepostIntersectionUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
        var limit,
            offset,
            repostPlaylistId,
            followerUserId,
            req,
            _args16 = arguments;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                limit = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : 100;
                offset = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : 0;
                repostPlaylistId = _args16.length > 2 ? _args16[2] : undefined;
                followerUserId = _args16.length > 3 ? _args16[3] : undefined;
                req = getPlaylistRepostIntersectionUsers(limit, offset, repostPlaylistId, followerUserId);
                _context16.next = 7;
                return this._makeRequest(req);

              case 7:
                return _context16.abrupt("return", _context16.sent);

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getPlaylistRepostIntersectionUsers$1() {
        return _getPlaylistRepostIntersectionUsers.apply(this, arguments);
      }

      return getPlaylistRepostIntersectionUsers$1;
    }()
    /**
     * get users that follow followeeUserId, sorted by follower count descending
     * @param followeeUserId user that is followed
     * @return {Array} array of user objects with standard user metadata
     */

  }, {
    key: "getFollowersForUser",
    value: function () {
      var _getFollowersForUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
        var limit,
            offset,
            followeeUserId,
            req,
            _args17 = arguments;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                limit = _args17.length > 0 && _args17[0] !== undefined ? _args17[0] : 100;
                offset = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : 0;
                followeeUserId = _args17.length > 2 ? _args17[2] : undefined;
                req = getFollowersForUser(limit, offset, followeeUserId);
                _context17.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context17.abrupt("return", _context17.sent);

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getFollowersForUser$1() {
        return _getFollowersForUser.apply(this, arguments);
      }

      return getFollowersForUser$1;
    }()
    /**
     * get users that are followed by followerUserId, sorted by follower count descending
     * @param followerUserId user - i am the one who follows
     * @return {Array} array of user objects with standard user metadata
     */

  }, {
    key: "getFolloweesForUser",
    value: function () {
      var _getFolloweesForUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
        var limit,
            offset,
            followerUserId,
            req,
            _args18 = arguments;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                limit = _args18.length > 0 && _args18[0] !== undefined ? _args18[0] : 100;
                offset = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : 0;
                followerUserId = _args18.length > 2 ? _args18[2] : undefined;
                req = getFolloweesForUser(limit, offset, followerUserId);
                _context18.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context18.abrupt("return", _context18.sent);

              case 7:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getFolloweesForUser$1() {
        return _getFolloweesForUser.apply(this, arguments);
      }

      return getFolloweesForUser$1;
    }()
    /**
     * get users that reposted repostTrackId, sorted by follower count descending
     * @param repostTrackId
     * @return {Array} array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForTrack(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getRepostersForTrack",
    value: function () {
      var _getRepostersForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
        var limit,
            offset,
            repostTrackId,
            req,
            _args19 = arguments;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                limit = _args19.length > 0 && _args19[0] !== undefined ? _args19[0] : 100;
                offset = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : 0;
                repostTrackId = _args19.length > 2 ? _args19[2] : undefined;
                req = getRepostersForTrack(limit, offset, repostTrackId);
                _context19.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context19.abrupt("return", _context19.sent);

              case 7:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getRepostersForTrack$1() {
        return _getRepostersForTrack.apply(this, arguments);
      }

      return getRepostersForTrack$1;
    }()
    /**
     * get users that reposted repostPlaylistId, sorted by follower count descending
     * @param repostPlaylistId
     * @return {Array} array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForPlaylist(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getRepostersForPlaylist",
    value: function () {
      var _getRepostersForPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
        var limit,
            offset,
            repostPlaylistId,
            req,
            _args20 = arguments;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                limit = _args20.length > 0 && _args20[0] !== undefined ? _args20[0] : 100;
                offset = _args20.length > 1 && _args20[1] !== undefined ? _args20[1] : 0;
                repostPlaylistId = _args20.length > 2 ? _args20[2] : undefined;
                req = getRepostersForPlaylist(limit, offset, repostPlaylistId);
                _context20.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context20.abrupt("return", _context20.sent);

              case 7:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getRepostersForPlaylist$1() {
        return _getRepostersForPlaylist.apply(this, arguments);
      }

      return getRepostersForPlaylist$1;
    }()
    /**
     * get users that saved saveTrackId, sorted by follower count descending
     * @param saveTrackId
     * @return {Array} array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForTrack(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getSaversForTrack",
    value: function () {
      var _getSaversForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
        var limit,
            offset,
            saveTrackId,
            req,
            _args21 = arguments;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                limit = _args21.length > 0 && _args21[0] !== undefined ? _args21[0] : 100;
                offset = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : 0;
                saveTrackId = _args21.length > 2 ? _args21[2] : undefined;
                req = getSaversForTrack(limit, offset, saveTrackId);
                _context21.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context21.abrupt("return", _context21.sent);

              case 7:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getSaversForTrack$1() {
        return _getSaversForTrack.apply(this, arguments);
      }

      return getSaversForTrack$1;
    }()
    /**
     * get users that saved savePlaylistId, sorted by follower count descending
     * @param savePlaylistId
     * @return {Array} array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForPlaylist(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getSaversForPlaylist",
    value: function () {
      var _getSaversForPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
        var limit,
            offset,
            savePlaylistId,
            req,
            _args22 = arguments;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                limit = _args22.length > 0 && _args22[0] !== undefined ? _args22[0] : 100;
                offset = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : 0;
                savePlaylistId = _args22.length > 2 ? _args22[2] : undefined;
                req = getSaversForPlaylist(limit, offset, savePlaylistId);
                _context22.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context22.abrupt("return", _context22.sent);

              case 7:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getSaversForPlaylist$1() {
        return _getSaversForPlaylist.apply(this, arguments);
      }

      return getSaversForPlaylist$1;
    }()
    /**
     * get whether a JWT given by Audius Oauth popup is valid
     * @param token - JWT
     * @return {UserProfile | false} profile info of user attached to JWT payload if the JWT is valid, else false
     */

  }, {
    key: "verifyToken",
    value: function () {
      var _verifyToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(token) {
        var req, res;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                req = verifyToken(token);
                _context23.next = 3;
                return this._makeRequest(req);

              case 3:
                res = _context23.sent;

                if (!(res == null || res[0] == null)) {
                  _context23.next = 8;
                  break;
                }

                return _context23.abrupt("return", false);

              case 8:
                return _context23.abrupt("return", res[0]);

              case 9:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function verifyToken$1(_x22) {
        return _verifyToken.apply(this, arguments);
      }

      return verifyToken$1;
    }()
    /**
     * Perform a full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have all same data as returned from standalone endpoints
     * @param text search query
     * @param kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchFull",
    value: function () {
      var _searchFull = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(text, kind) {
        var limit,
            offset,
            req,
            _args24 = arguments;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                limit = _args24.length > 2 && _args24[2] !== undefined ? _args24[2] : 100;
                offset = _args24.length > 3 && _args24[3] !== undefined ? _args24[3] : 0;
                req = searchFull(text, kind, limit, offset);
                _context24.next = 5;
                return this._makeRequest(req);

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function searchFull$1(_x23, _x24) {
        return _searchFull.apply(this, arguments);
      }

      return searchFull$1;
    }()
    /**
     * Perform a lighter-weight full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have core data, and track & playlist objects
     *    also return user object
     * @param text search query
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchAutocomplete",
    value: function () {
      var _searchAutocomplete = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(text) {
        var limit,
            offset,
            req,
            _args25 = arguments;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                limit = _args25.length > 1 && _args25[1] !== undefined ? _args25[1] : 100;
                offset = _args25.length > 2 && _args25[2] !== undefined ? _args25[2] : 0;
                req = searchAutocomplete(text, limit, offset);
                _context25.next = 5;
                return this._makeRequest(req);

              case 5:
                return _context25.abrupt("return", _context25.sent);

              case 6:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function searchAutocomplete$1(_x25) {
        return _searchAutocomplete.apply(this, arguments);
      }

      return searchAutocomplete$1;
    }()
    /**
     * Perform a tags-only search. Returns tracks with required tag and users
     * that have used a tag greater than a specified number of times
     * @param text search query
     * @param userTagCount min # of times a user must have used a tag to be returned
     * @param kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param limit max # of items to return per list (for pagination)
     * @param offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchTags",
    value: function () {
      var _searchTags = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(text) {
        var userTagCount,
            kind,
            limit,
            offset,
            req,
            _args26 = arguments;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                userTagCount = _args26.length > 1 && _args26[1] !== undefined ? _args26[1] : 2;
                kind = _args26.length > 2 && _args26[2] !== undefined ? _args26[2] : 'all';
                limit = _args26.length > 3 && _args26[3] !== undefined ? _args26[3] : 100;
                offset = _args26.length > 4 && _args26[4] !== undefined ? _args26[4] : 0;
                req = searchTags(text, userTagCount, kind, limit, offset);
                _context26.next = 7;
                return this._makeRequest(req);

              case 7:
                return _context26.abrupt("return", _context26.sent);

              case 8:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function searchTags$1(_x26) {
        return _searchTags.apply(this, arguments);
      }

      return searchTags$1;
    }()
    /**
     * Return saved playlists for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getSavedPlaylists",
    value: function () {
      var _getSavedPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27() {
        var limit,
            offset,
            withUsers,
            req,
            _args27 = arguments;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                limit = _args27.length > 0 && _args27[0] !== undefined ? _args27[0] : 100;
                offset = _args27.length > 1 && _args27[1] !== undefined ? _args27[1] : 0;
                withUsers = _args27.length > 2 && _args27[2] !== undefined ? _args27[2] : false;
                req = getSavedPlaylists(limit, offset, withUsers);
                _context27.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context27.abrupt("return", _context27.sent);

              case 7:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getSavedPlaylists$1() {
        return _getSavedPlaylists.apply(this, arguments);
      }

      return getSavedPlaylists$1;
    }()
    /**
     * Return saved albums for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getSavedAlbums",
    value: function () {
      var _getSavedAlbums = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28() {
        var limit,
            offset,
            withUsers,
            req,
            _args28 = arguments;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                limit = _args28.length > 0 && _args28[0] !== undefined ? _args28[0] : 100;
                offset = _args28.length > 1 && _args28[1] !== undefined ? _args28[1] : 0;
                withUsers = _args28.length > 2 && _args28[2] !== undefined ? _args28[2] : false;
                req = getSavedAlbums(limit, offset, withUsers);
                _context28.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context28.abrupt("return", _context28.sent);

              case 7:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getSavedAlbums$1() {
        return _getSavedAlbums.apply(this, arguments);
      }

      return getSavedAlbums$1;
    }()
    /**
     * Return saved tracks for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param limit - max # of items to return
     * @param offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getSavedTracks",
    value: function () {
      var _getSavedTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29() {
        var limit,
            offset,
            withUsers,
            req,
            _args29 = arguments;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                limit = _args29.length > 0 && _args29[0] !== undefined ? _args29[0] : 100;
                offset = _args29.length > 1 && _args29[1] !== undefined ? _args29[1] : 0;
                withUsers = _args29.length > 2 && _args29[2] !== undefined ? _args29[2] : false;
                req = getSavedTracks(limit, offset, withUsers);
                _context29.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context29.abrupt("return", _context29.sent);

              case 7:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getSavedTracks$1() {
        return _getSavedTracks.apply(this, arguments);
      }

      return getSavedTracks$1;
    }()
    /**
     * Return user collections (saved & uploaded) along w/ users for those collections
     */

  }, {
    key: "getUserAccount",
    value: function () {
      var _getUserAccount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(wallet) {
        var req;
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                req = getUserAccount(wallet);
                _context30.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context30.abrupt("return", _context30.sent);

              case 4:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getUserAccount$1(_x27) {
        return _getUserAccount.apply(this, arguments);
      }

      return getUserAccount$1;
    }()
  }, {
    key: "getTopPlaylists",
    value: function () {
      var _getTopPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(type, limit, mood, filter) {
        var withUsers,
            req,
            _args31 = arguments;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                withUsers = _args31.length > 4 && _args31[4] !== undefined ? _args31[4] : false;
                req = getTopPlaylists(type, limit, mood, filter, withUsers);
                _context31.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context31.abrupt("return", _context31.sent);

              case 5:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getTopPlaylists$1(_x28, _x29, _x30, _x31) {
        return _getTopPlaylists.apply(this, arguments);
      }

      return getTopPlaylists$1;
    }()
  }, {
    key: "getTopFolloweeWindowed",
    value: function () {
      var _getTopFolloweeWindowed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(type, window, limit) {
        var withUsers,
            req,
            _args32 = arguments;
        return regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                withUsers = _args32.length > 3 && _args32[3] !== undefined ? _args32[3] : false;
                req = getTopFolloweeWindowed(type, window, limit, withUsers);
                _context32.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context32.abrupt("return", _context32.sent);

              case 5:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function getTopFolloweeWindowed$1(_x32, _x33, _x34) {
        return _getTopFolloweeWindowed.apply(this, arguments);
      }

      return getTopFolloweeWindowed$1;
    }()
  }, {
    key: "getTopFolloweeSaves",
    value: function () {
      var _getTopFolloweeSaves = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(type, limit) {
        var withUsers,
            req,
            _args33 = arguments;
        return regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                withUsers = _args33.length > 2 && _args33[2] !== undefined ? _args33[2] : false;
                req = getTopFolloweeSaves(type, limit, withUsers);
                _context33.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context33.abrupt("return", _context33.sent);

              case 5:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getTopFolloweeSaves$1(_x35, _x36) {
        return _getTopFolloweeSaves.apply(this, arguments);
      }

      return getTopFolloweeSaves$1;
    }()
  }, {
    key: "getLatest",
    value: function () {
      var _getLatest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(type) {
        var req;
        return regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                req = getLatest(type);
                _context34.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context34.abrupt("return", _context34.sent);

              case 4:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function getLatest$1(_x37) {
        return _getLatest.apply(this, arguments);
      }

      return getLatest$1;
    }()
  }, {
    key: "getTopCreatorsByGenres",
    value: function () {
      var _getTopCreatorsByGenres = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(genres) {
        var limit,
            offset,
            withUsers,
            req,
            _args35 = arguments;
        return regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                limit = _args35.length > 1 && _args35[1] !== undefined ? _args35[1] : 30;
                offset = _args35.length > 2 && _args35[2] !== undefined ? _args35[2] : 0;
                withUsers = _args35.length > 3 && _args35[3] !== undefined ? _args35[3] : false;
                req = getTopCreatorsByGenres(genres, limit, offset, withUsers);
                _context35.next = 6;
                return this._makeRequest(req);

              case 6:
                return _context35.abrupt("return", _context35.sent);

              case 7:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function getTopCreatorsByGenres$1(_x38) {
        return _getTopCreatorsByGenres.apply(this, arguments);
      }

      return getTopCreatorsByGenres$1;
    }()
  }, {
    key: "getURSMContentNodes",
    value: function () {
      var _getURSMContentNodes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36() {
        var ownerWallet,
            req,
            _args36 = arguments;
        return regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                ownerWallet = _args36.length > 0 && _args36[0] !== undefined ? _args36[0] : null;
                req = getURSMContentNodes(ownerWallet);
                _context36.next = 4;
                return this._makeRequest(req);

              case 4:
                return _context36.abrupt("return", _context36.sent);

              case 5:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function getURSMContentNodes$1() {
        return _getURSMContentNodes.apply(this, arguments);
      }

      return getURSMContentNodes$1;
    }()
  }, {
    key: "getNotifications",
    value: function () {
      var _getNotifications = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(minBlockNumber, trackIds, timeout) {
        var req;
        return regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                req = getNotifications(minBlockNumber, trackIds, timeout);
                _context37.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context37.abrupt("return", _context37.sent);

              case 4:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function getNotifications$1(_x39, _x40, _x41) {
        return _getNotifications.apply(this, arguments);
      }

      return getNotifications$1;
    }()
  }, {
    key: "getSolanaNotifications",
    value: function () {
      var _getSolanaNotifications = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(minSlotNumber, timeout) {
        var req;
        return regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                req = getSolanaNotifications(minSlotNumber, timeout);
                _context38.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context38.abrupt("return", _context38.sent);

              case 4:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function getSolanaNotifications$1(_x42, _x43) {
        return _getSolanaNotifications.apply(this, arguments);
      }

      return getSolanaNotifications$1;
    }()
  }, {
    key: "getTrackListenMilestones",
    value: function () {
      var _getTrackListenMilestones = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(timeout) {
        var req;
        return regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                req = getTrackListenMilestones(timeout);
                _context39.next = 3;
                return this._makeRequest(req);

              case 3:
                return _context39.abrupt("return", _context39.sent);

              case 4:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function getTrackListenMilestones$1(_x44) {
        return _getTrackListenMilestones.apply(this, arguments);
      }

      return getTrackListenMilestones$1;
    }()
  }, {
    key: "getChallengeAttestation",
    value: function () {
      var _getChallengeAttestation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(challengeId, encodedUserId, specifier, oracleAddress, discoveryProviderEndpoint) {
        var req, _yield$this$_performR, data;

        return regeneratorRuntime.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                req = getChallengeAttestation(challengeId, encodedUserId, specifier, oracleAddress);
                _context40.next = 3;
                return this._performRequestWithMonitoring(req, discoveryProviderEndpoint);

              case 3:
                _yield$this$_performR = _context40.sent;
                data = _yield$this$_performR.data;
                return _context40.abrupt("return", data);

              case 6:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function getChallengeAttestation$1(_x45, _x46, _x47, _x48, _x49) {
        return _getChallengeAttestation.apply(this, arguments);
      }

      return getChallengeAttestation$1;
    }()
  }, {
    key: "getCreateSenderAttestation",
    value: function () {
      var _getCreateSenderAttestation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(senderEthAddress, discoveryProviderEndpoint) {
        var req, _yield$this$_performR2, data;

        return regeneratorRuntime.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                req = getCreateSenderAttestation(senderEthAddress);
                _context41.next = 3;
                return this._performRequestWithMonitoring(req, discoveryProviderEndpoint);

              case 3:
                _yield$this$_performR2 = _context41.sent;
                data = _yield$this$_performR2.data;
                return _context41.abrupt("return", data);

              case 6:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function getCreateSenderAttestation$1(_x50, _x51) {
        return _getCreateSenderAttestation.apply(this, arguments);
      }

      return getCreateSenderAttestation$1;
    }()
  }, {
    key: "getUndisbursedChallenges",
    value: function () {
      var _getUndisbursedChallenges = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42() {
        var limit,
            offset,
            completedBlockNumber,
            encodedUserId,
            req,
            res,
            _args42 = arguments;
        return regeneratorRuntime.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                limit = _args42.length > 0 && _args42[0] !== undefined ? _args42[0] : null;
                offset = _args42.length > 1 && _args42[1] !== undefined ? _args42[1] : null;
                completedBlockNumber = _args42.length > 2 && _args42[2] !== undefined ? _args42[2] : null;
                encodedUserId = _args42.length > 3 && _args42[3] !== undefined ? _args42[3] : null;
                req = getUndisbursedChallenges(limit, offset, completedBlockNumber, encodedUserId);
                _context42.next = 7;
                return this._makeRequest(req);

              case 7:
                res = _context42.sent;

                if (res) {
                  _context42.next = 10;
                  break;
                }

                return _context42.abrupt("return", []);

              case 10:
                return _context42.abrupt("return", res.map(function (r) {
                  return _objectSpread2(_objectSpread2({}, r), {}, {
                    amount: parseInt(r.amount)
                  });
                }));

              case 11:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function getUndisbursedChallenges$1() {
        return _getUndisbursedChallenges.apply(this, arguments);
      }

      return getUndisbursedChallenges$1;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

    /**
     * Performs a single request, defined in the request, via axios, calling any
     * monitoring callbacks as needed.
     *
     * @param {{
       endpoint: string,
       urlParams: string,
       queryParams: object,
       method: string,
       headers: object,
     }} requestObj
     * @param {string} discoveryProviderEndpoint
     * @returns
     * @memberof DiscoveryProvider
     */

  }, {
    key: "_performRequestWithMonitoring",
    value: function () {
      var _performRequestWithMonitoring2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee43(requestObj, discoveryProviderEndpoint) {
        var _axiosRequest$url;

        var axiosRequest, response, parsedResponse, url, start, duration, _error$response$data, _error$response, error, resp, _duration, errMsg;

        return regeneratorRuntime.wrap(function _callee43$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                axiosRequest = this._createDiscProvRequest(requestObj, discoveryProviderEndpoint);
                url = new URL((_axiosRequest$url = axiosRequest.url) !== null && _axiosRequest$url !== void 0 ? _axiosRequest$url : '');
                start = Date.now();
                _context43.prev = 3;
                _context43.next = 6;
                return axios__default["default"](axiosRequest);

              case 6:
                response = _context43.sent;
                duration = Date.now() - start;
                parsedResponse = Utils$b.parseDataFromResponse(response); // Fire monitoring callbacks for request success case

                if ('request' in this.monitoringCallbacks) {
                  try {
                    this.monitoringCallbacks.request({
                      endpoint: url.origin,
                      pathname: url.pathname,
                      queryString: url.search,
                      signer: response.data.signer,
                      signature: response.data.signature,
                      requestMethod: axiosRequest.method,
                      status: response.status,
                      responseTimeMillis: duration
                    });
                  } catch (e) {
                    // Swallow errors -- this method should not throw generally
                    console.error(e);
                  }
                }

                _context43.next = 22;
                break;

              case 12:
                _context43.prev = 12;
                _context43.t0 = _context43["catch"](3);
                error = _context43.t0;
                resp = error.response;
                _duration = Date.now() - start;
                errMsg = (_error$response$data = (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) !== null && _error$response$data !== void 0 ? _error$response$data : error; // Fire monitoring callbaks for request failure case

                if ('request' in this.monitoringCallbacks) {
                  try {
                    this.monitoringCallbacks.request({
                      endpoint: url.origin,
                      pathname: url.pathname,
                      queryString: url.search,
                      requestMethod: axiosRequest.method,
                      status: resp === null || resp === void 0 ? void 0 : resp.status,
                      responseTimeMillis: _duration
                    });
                  } catch (e) {
                    // Swallow errors -- this method should not throw generally
                    console.error(e);
                  }
                }

                if (!(resp && resp.status === 404)) {
                  _context43.next = 21;
                  break;
                }

                throw new Error('404');

              case 21:
                throw errMsg;

              case 22:
                return _context43.abrupt("return", parsedResponse);

              case 23:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee43, this, [[3, 12]]);
      }));

      function _performRequestWithMonitoring(_x52, _x53) {
        return _performRequestWithMonitoring2.apply(this, arguments);
      }

      return _performRequestWithMonitoring;
    }()
    /**
     * Gets how many blocks behind a discovery node is.
     * If this method throws (missing data in health check response),
     * return an unhealthy number of blocks
     * @param parsedResponse health check response object
     * @returns a number of blocks if behind or null if not behind
     */

  }, {
    key: "_getBlocksBehind",
    value: function () {
      var _getBlocksBehind2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee44(parsedResponse) {
        var indexedBlock, chainBlock, blockDiff;
        return regeneratorRuntime.wrap(function _callee44$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                _context44.prev = 0;
                indexedBlock = parsedResponse.latest_indexed_block, chainBlock = parsedResponse.latest_chain_block;
                blockDiff = chainBlock - indexedBlock;

                if (!(blockDiff > this.unhealthyBlockDiff)) {
                  _context44.next = 5;
                  break;
                }

                return _context44.abrupt("return", blockDiff);

              case 5:
                return _context44.abrupt("return", null);

              case 8:
                _context44.prev = 8;
                _context44.t0 = _context44["catch"](0);
                console.error(_context44.t0);
                return _context44.abrupt("return", this.unhealthyBlockDiff);

              case 12:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee44, this, [[0, 8]]);
      }));

      function _getBlocksBehind(_x54) {
        return _getBlocksBehind2.apply(this, arguments);
      }

      return _getBlocksBehind;
    }()
    /**
     * Gets how many plays slots behind a discovery node is.
     * If this method throws (missing data in health check response),
     * return an unhealthy number of slots
     * @param parsedResponse health check response object
     * @returns a number of slots if behind or null if not behind
     */

  }, {
    key: "_getPlaysSlotsBehind",
    value: function () {
      var _getPlaysSlotsBehind2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee45(parsedResponse) {
        var indexedSlotPlays, chainSlotPlays, slotDiff;
        return regeneratorRuntime.wrap(function _callee45$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
                if (this.unhealthySlotDiffPlays) {
                  _context45.next = 2;
                  break;
                }

                return _context45.abrupt("return", null);

              case 2:
                _context45.prev = 2;
                indexedSlotPlays = parsedResponse.latest_indexed_slot_plays, chainSlotPlays = parsedResponse.latest_chain_slot_plays;
                slotDiff = chainSlotPlays - indexedSlotPlays;

                if (!(slotDiff > this.unhealthySlotDiffPlays)) {
                  _context45.next = 7;
                  break;
                }

                return _context45.abrupt("return", slotDiff);

              case 7:
                return _context45.abrupt("return", null);

              case 10:
                _context45.prev = 10;
                _context45.t0 = _context45["catch"](2);
                console.error(_context45.t0);
                return _context45.abrupt("return", this.unhealthySlotDiffPlays);

              case 14:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee45, this, [[2, 10]]);
      }));

      function _getPlaysSlotsBehind(_x55) {
        return _getPlaysSlotsBehind2.apply(this, arguments);
      }

      return _getPlaysSlotsBehind;
    }()
    /**
     * Makes a request to a discovery node, reselecting if necessary
     * @param {{
     *  endpoint: string
     *  urlParams: object
     *  queryParams: object
     *  method: string
     *  headers: object
     * }} {
     *  endpoint: the base route
     *  urlParams: string of URL params to be concatenated after base route
     *  queryParams: URL query (search) params
     *  method: string HTTP method
     * }
     * @param retry whether to retry on failure
     * @param attemptedRetries number of attempted retries (stops retrying at max)
     */

  }, {
    key: "_makeRequest",
    value: function () {
      var _makeRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee46(requestObj) {
        var retry,
            attemptedRetries,
            newDiscProvEndpoint,
            updateDiscProvEndpointMsg,
            parsedResponse,
            error,
            failureStr,
            attemptStr,
            errorStr,
            requestStr,
            fullErrString,
            notInRegressedMode,
            blockDiff,
            playsSlotDiff,
            _args46 = arguments;
        return regeneratorRuntime.wrap(function _callee46$(_context46) {
          while (1) {
            switch (_context46.prev = _context46.next) {
              case 0:
                retry = _args46.length > 1 && _args46[1] !== undefined ? _args46[1] : true;
                attemptedRetries = _args46.length > 2 && _args46[2] !== undefined ? _args46[2] : 0;
                _context46.prev = 2;
                _context46.next = 5;
                return this.getHealthyDiscoveryProviderEndpoint(attemptedRetries);

              case 5:
                newDiscProvEndpoint = _context46.sent;

                // If new DP endpoint is selected, update disc prov endpoint and reset attemptedRetries count
                if (this.discoveryProviderEndpoint !== newDiscProvEndpoint) {
                  updateDiscProvEndpointMsg = "Current Discovery Provider endpoint ".concat(this.discoveryProviderEndpoint, " is unhealthy. ");
                  updateDiscProvEndpointMsg += "Switching over to the new Discovery Provider endpoint ".concat(newDiscProvEndpoint, "!");
                  console.info(updateDiscProvEndpointMsg);
                  this.discoveryProviderEndpoint = newDiscProvEndpoint;
                  attemptedRetries = 0;
                }

                _context46.next = 13;
                break;

              case 9:
                _context46.prev = 9;
                _context46.t0 = _context46["catch"](2);
                console.error(_context46.t0);
                return _context46.abrupt("return");

              case 13:
                _context46.prev = 13;
                _context46.next = 16;
                return this._performRequestWithMonitoring(requestObj, this.discoveryProviderEndpoint);

              case 16:
                parsedResponse = _context46.sent;
                _context46.next = 43;
                break;

              case 19:
                _context46.prev = 19;
                _context46.t1 = _context46["catch"](13);
                error = _context46.t1;
                failureStr = 'Failed to make Discovery Provider request, ';
                attemptStr = "attempt #".concat(attemptedRetries, ", ");
                errorStr = "error ".concat(JSON.stringify(error.message), ", ");
                requestStr = "request: ".concat(JSON.stringify(requestObj));
                fullErrString = "".concat(failureStr).concat(attemptStr).concat(errorStr).concat(requestStr);
                console.warn(fullErrString);

                if (!retry) {
                  _context46.next = 42;
                  break;
                }

                if (!(error.message === '404')) {
                  _context46.next = 39;
                  break;
                }

                this.request404Count += 1;

                if (!(this.request404Count < this.maxRequestsForTrue404)) {
                  _context46.next = 37;
                  break;
                }

                _context46.next = 34;
                return this._makeRequest(requestObj, retry, this.selectionRequestRetries + 1);

              case 34:
                return _context46.abrupt("return", _context46.sent);

              case 37:
                this.request404Count = 0;
                return _context46.abrupt("return", null);

              case 39:
                _context46.next = 41;
                return this._makeRequest(requestObj, retry, attemptedRetries + 1);

              case 41:
                return _context46.abrupt("return", _context46.sent);

              case 42:
                return _context46.abrupt("return", null);

              case 43:
                // Validate health check response
                // Regressed mode signals we couldn't find a node that wasn't behind by some measure
                // so we should should pick something
                notInRegressedMode = this.ethContracts && !this.ethContracts.isInRegressedMode();
                _context46.next = 46;
                return this._getBlocksBehind(parsedResponse);

              case 46:
                blockDiff = _context46.sent;

                if (!(notInRegressedMode && blockDiff)) {
                  _context46.next = 54;
                  break;
                }

                if (!retry) {
                  _context46.next = 53;
                  break;
                }

                console.info("".concat(this.discoveryProviderEndpoint, " is too far behind [block diff: ").concat(blockDiff, "]. Retrying request at attempt #").concat(attemptedRetries, "..."));
                _context46.next = 52;
                return this._makeRequest(requestObj, retry, attemptedRetries + 1);

              case 52:
                return _context46.abrupt("return", _context46.sent);

              case 53:
                return _context46.abrupt("return", null);

              case 54:
                _context46.next = 56;
                return this._getPlaysSlotsBehind(parsedResponse);

              case 56:
                playsSlotDiff = _context46.sent;

                if (!(notInRegressedMode && playsSlotDiff)) {
                  _context46.next = 64;
                  break;
                }

                if (!retry) {
                  _context46.next = 63;
                  break;
                }

                console.info("".concat(this.discoveryProviderEndpoint, " is too far behind [slot diff: ").concat(playsSlotDiff, "]. Retrying request at attempt #").concat(attemptedRetries, "..."));
                _context46.next = 62;
                return this._makeRequest(requestObj, retry, attemptedRetries + 1);

              case 62:
                return _context46.abrupt("return", _context46.sent);

              case 63:
                return _context46.abrupt("return", null);

              case 64:
                // Reset 404 counts
                this.request404Count = 0; // Everything looks good, return the data!

                return _context46.abrupt("return", parsedResponse.data);

              case 66:
              case "end":
                return _context46.stop();
            }
          }
        }, _callee46, this, [[2, 9], [13, 19]]);
      }));

      function _makeRequest(_x56) {
        return _makeRequest2.apply(this, arguments);
      }

      return _makeRequest;
    }()
    /**
     * Gets the healthy discovery provider endpoint used in creating the axios request later.
     * If the number of retries is over the max count for retires, clear the cache and reselect
     * another healthy discovery provider. Else, return the current discovery provider endpoint
     * @param attemptedRetries the number of attempted requests made to the current disc prov endpoint
     */

  }, {
    key: "getHealthyDiscoveryProviderEndpoint",
    value: function () {
      var _getHealthyDiscoveryProviderEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee47(attemptedRetries) {
        var endpoint;
        return regeneratorRuntime.wrap(function _callee47$(_context47) {
          while (1) {
            switch (_context47.prev = _context47.next) {
              case 0:
                endpoint = this.discoveryProviderEndpoint;

                if (!(attemptedRetries > this.selectionRequestRetries)) {
                  _context47.next = 8;
                  break;
                }

                // Add to unhealthy list if current disc prov endpoint has reached max retry count
                console.info("Attempted max retries with endpoint ".concat(endpoint));
                this.serviceSelector.addUnhealthy(endpoint); // Clear the cached endpoint and select new endpoint from backups

                this.serviceSelector.clearCached();
                _context47.next = 7;
                return this.serviceSelector.select();

              case 7:
                endpoint = _context47.sent;

              case 8:
                if (endpoint) {
                  _context47.next = 10;
                  break;
                }

                throw new Error('All Discovery Providers are unhealthy and unavailable.');

              case 10:
                return _context47.abrupt("return", endpoint);

              case 11:
              case "end":
                return _context47.stop();
            }
          }
        }, _callee47, this);
      }));

      function getHealthyDiscoveryProviderEndpoint(_x57) {
        return _getHealthyDiscoveryProviderEndpoint.apply(this, arguments);
      }

      return getHealthyDiscoveryProviderEndpoint;
    }()
    /**
     * Creates the discovery provider axios request object with necessary configs
     * @param requestObj
     * @param discoveryProviderEndpoint
     */

  }, {
    key: "_createDiscProvRequest",
    value: function _createDiscProvRequest(requestObj, discoveryProviderEndpoint) {
      var _requestObj$timeout, _requestObj$method;

      // Sanitize URL params if needed
      if (requestObj.queryParams) {
        Object.entries(requestObj.queryParams).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              k = _ref2[0],
              v = _ref2[1];

          if (v === undefined || v === null) {
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete requestObj.queryParams[k];
          }
        });
      }

      var requestUrl = urlJoin__default["default"](discoveryProviderEndpoint, requestObj.endpoint, requestObj.urlParams, {
        query: requestObj.queryParams
      });
      var headers = {};

      if (requestObj.headers) {
        headers = requestObj.headers;
      }

      var currentUserId = this.userStateManager.getCurrentUserId();

      if (currentUserId) {
        headers['X-User-ID'] = currentUserId;
      }

      var timeout = (_requestObj$timeout = requestObj.timeout) !== null && _requestObj$timeout !== void 0 ? _requestObj$timeout : this.selectionRequestTimeout;
      var axiosRequest = {
        url: requestUrl,
        headers: headers,
        method: (_requestObj$method = requestObj.method) !== null && _requestObj$method !== void 0 ? _requestObj$method : 'get',
        timeout: timeout
      };

      if (requestObj.method === 'post' && requestObj.data) {
        axiosRequest = _objectSpread2(_objectSpread2({}, axiosRequest), {}, {
          data: requestObj.data
        });
      }

      return axiosRequest;
    }
  }]);

  return DiscoveryProvider;
}();

var discoveryProvider = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DiscoveryProvider: DiscoveryProvider
});

var require$$11 = /*@__PURE__*/getAugmentedNamespace(discoveryProvider);

var CSS = "\n.audiusLoginButton {\n  cursor: pointer;\n  font-family: Helvetica, Arial, sans-serif;\n  text-align: center;\n  color: #FFFFFF;\n  font-weight: 700;\n  font-size: 14px;\n  line-height: 100%;\n  align-items: center;\n  display: flex;\n  border: 0;\n  height: 28px;\n  justify-content: center;\n  padding: 0px 16px;\n  background: #CC0FE0;\n  border-radius: 4px;\n  transition: all 0.07s ease-in-out;\n}\n\n.audiusLoginButton:hover {\n  background: #D127E3;\n  transform: perspective(1px) scale3d(1.04, 1.04, 1.04);\n}\n\n.audiusLoginButton.disableHoverGrow:hover {\n  transform: none;\n}\n\n.audiusLoginButton:active {\n  background: #A30CB3;\n}\n\n.audiusLoginButton.pill {\n  border-radius: 99px;\n}\n\n.audiusLoginButton.fullWidth {\n  width: 100%;\n}\n\n.audiusLoginButton.small {\n  height: 20px;\n  font-size: 11px;\n  padding: 0px 32px;\n}\n\n.audiusLoginButton.large {\n  height: 40px;\n  font-size: 18px;\n  padding: 0px 18px;\n}\n"; // From https://stackoverflow.com/a/27747377

var generateId = function generateId() {
  var arr = new Uint8Array(40 / 2) // Result of function will be 40 chars long
  ;
  (window.crypto || window.msCrypto).getRandomValues(arr);
  return Array.from(arr, function dec2hex(dec) {
    return dec.toString(16).padStart(2, '0');
  }).join('');
};

var generateAudiusLogoSvg = function generateAudiusLogoSvg(size) {
  var height;
  var paddingRight;

  if (size === 'small') {
    height = 16;
    paddingRight = 5;
  } else if (size === 'medium') {
    height = 18;
    paddingRight = 5;
  } else {
    height = 24;
    paddingRight = 10;
  }

  return "<svg width=\"".concat(height, "px\" height=\"").concat(height, "px\" viewBox=\"0 0 56 48\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"padding-right: ").concat(paddingRight, "px;\">\n<g id=\"Assets\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n    <g id=\"assets\" transform=\"translate(-1555.000000, -2588.000000)\">\n        <g id=\"audiusLogoGlyph\" transform=\"translate(1555.000000, 2588.000000)\">\n            <path d=\"M55.8191698,46.0362519 L42.4551012,23.3458831 L36.1870263,12.7036635 L29.0910326,0.65551431 C28.5766233,-0.217848954 27.2890668,-0.218676884 26.7734944,0.654065432 L13.3787621,23.3270477 L7.90582764,32.5909699 C7.39025522,33.4637122 8.03324043,34.5553386 9.06332791,34.5560631 L19.4031138,34.56279 C19.881044,34.5631005 20.3230236,34.3136864 20.5623059,33.9087249 L25.9362708,24.8122516 L26.7580568,23.4212248 C26.790518,23.3662709 26.8260456,23.3149392 26.8641108,23.2669192 C27.4325516,22.5520012 28.5935412,22.6041608 29.0755951,23.4226737 L34.6514114,32.8894388 L35.682239,34.6396841 C35.7412402,34.7399672 35.7843808,34.8430445 35.813987,34.9470533 C36.0430129,35.7492145 35.4339691,36.6039494 34.5220954,36.6034319 L22.3586676,36.5954631 C21.8806317,36.5951526 21.4387578,36.8445667 21.1994756,37.2496317 L16.0236614,46.0105861 C15.5080889,46.8833284 16.1510741,47.9749548 17.1810559,47.9756793 L27.9002253,47.9827167 L41.2664086,47.9913065 L54.6590261,47.9999997 C55.6892193,48.0006207 56.3335791,46.9096152 55.8191698,46.0362519\" id=\"Audius-Logo\" fill=\"#ffffff\" fill-rule=\"evenodd\"></path>\n            <rect id=\"bound\" x=\"0\" y=\"0\" width=\"56\" height=\"48\"></rect>\n        </g>\n    </g>\n</g>\n</svg>");
};

var OAUTH_URL = 'https://audius.co/oauth/auth';
var CSRF_TOKEN_KEY = 'audiusOauthState';
var Oauth = /*#__PURE__*/function () {
  function Oauth(discoveryProvider) {
    _classCallCheck(this, Oauth);

    if (typeof window === 'undefined') {
      // TODO(nkang): Add link to documentation once written
      throw new Error('Audius OAuth SDK functions are only available in browser. Refer to our documentation to learn how to implement Audius OAuth manually.');
    }

    this.discoveryProvider = discoveryProvider;
    this.appName = null;
    this.activePopupWindow = null;
    this.loginSuccessCallback = null;
    this.loginErrorCallback = null;
    this.popupCheckInterval = null;
  }

  _createClass(Oauth, [{
    key: "init",
    value: function init(appName, successCallback, errorCallback) {
      var _this = this;

      this.appName = appName;
      this.loginSuccessCallback = successCallback;
      this.loginErrorCallback = errorCallback !== null && errorCallback !== void 0 ? errorCallback : null;
      window.addEventListener('message', function (e) {
        _this._receiveMessage(e);
      }, false);
    }
  }, {
    key: "login",
    value: function login() {
      var _this2 = this;

      if (!this.appName) {
        this._surfaceError('App name not set (set with `init` method).');

        return;
      }

      if (!this.loginSuccessCallback) {
        this._surfaceError('Login success callback not set (set with `init` method).');

        return;
      }

      var csrfToken = generateId();
      window.localStorage.setItem(CSRF_TOKEN_KEY, csrfToken);
      var windowOptions = 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=375, height=720, top=100, left=100';
      var originURISafe = encodeURIComponent(window.location.origin);
      var appNameURISafe = encodeURI(this.appName);
      var fullOauthUrl = "".concat(OAUTH_URL, "?scope=read&state=").concat(csrfToken, "&redirect_uri=postMessage&origin=").concat(originURISafe, "&app_name=").concat(appNameURISafe);
      this.activePopupWindow = window.open(fullOauthUrl, '', windowOptions);

      this._clearPopupCheckInterval();

      this.popupCheckInterval = setInterval(function () {
        var _this2$activePopupWin;

        if ((_this2$activePopupWin = _this2.activePopupWindow) !== null && _this2$activePopupWin !== void 0 && _this2$activePopupWin.closed) {
          _this2._surfaceError('The login popup was closed prematurely.');

          if (_this2.popupCheckInterval) {
            clearInterval(_this2.popupCheckInterval);
          }
        }
      }, 500);
    }
  }, {
    key: "renderButton",
    value: function renderButton(element, options) {
      var _options$size,
          _options$customText,
          _this3 = this;

      if (!element) {
        console.error('Target element for Audius OAuth button is empty.');
      }

      var style = document.createElement('style');
      style.textContent = CSS;
      document.head.appendChild(style);
      var button = document.createElement('button');
      button.id = 'audius-login-button';
      button.classList.add('audiusLoginButton');

      if ((options === null || options === void 0 ? void 0 : options.corners) === 'pill') {
        button.classList.add('pill');
      }

      if ((options === null || options === void 0 ? void 0 : options.size) === 'small') {
        button.classList.add('small');
      }

      if ((options === null || options === void 0 ? void 0 : options.size) === 'large') {
        button.classList.add('large');
      }

      if (options !== null && options !== void 0 && options.fullWidth) {
        button.classList.add('fullWidth');
      }

      if (options !== null && options !== void 0 && options.disableHoverGrow) {
        button.classList.add('disableHoverGrow');
      }

      button.innerHTML = "".concat(generateAudiusLogoSvg((_options$size = options === null || options === void 0 ? void 0 : options.size) !== null && _options$size !== void 0 ? _options$size : 'medium'), " ").concat((_options$customText = options === null || options === void 0 ? void 0 : options.customText) !== null && _options$customText !== void 0 ? _options$customText : 'Continue With Audius');

      button.onclick = function () {
        _this3.login();
      };

      element.replaceWith(button);
    }
  }, {
    key: "verifyToken",
    value: function () {
      var _verifyToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(token) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.discoveryProvider.verifyToken(token);

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function verifyToken(_x) {
        return _verifyToken.apply(this, arguments);
      }

      return verifyToken;
    }()
    /* ------- INTERNAL FUNCTIONS ------- */

  }, {
    key: "_surfaceError",
    value: function _surfaceError(errorMessage) {
      if (this.loginErrorCallback) {
        this.loginErrorCallback(errorMessage);
      } else {
        console.error(errorMessage);
      }
    }
  }, {
    key: "_clearPopupCheckInterval",
    value: function _clearPopupCheckInterval() {
      if (this.popupCheckInterval) {
        clearInterval(this.popupCheckInterval);
      }
    }
  }, {
    key: "_receiveMessage",
    value: function () {
      var _receiveMessage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(event) {
        var oauthOrigin, decodedJwt;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                oauthOrigin = new URL(OAUTH_URL).origin;

                if (!(event.origin !== oauthOrigin || event.source !== this.activePopupWindow || !event.data.state || !event.data.token)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                this._clearPopupCheckInterval();

                if (this.activePopupWindow) {
                  if (!this.activePopupWindow.closed) {
                    this.activePopupWindow.close();
                  }

                  this.activePopupWindow = null;
                }

                if (window.localStorage.getItem(CSRF_TOKEN_KEY) !== event.data.state) {
                  this._surfaceError('State mismatch.');
                } // Verify token and decode


                _context2.next = 8;
                return this.verifyToken(event.data.token);

              case 8:
                decodedJwt = _context2.sent;

                if (decodedJwt) {
                  if (this.loginSuccessCallback) {
                    this.loginSuccessCallback(decodedJwt);
                  }
                } else {
                  this._surfaceError('The token was invalid.');
                }

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _receiveMessage(_x2) {
        return _receiveMessage2.apply(this, arguments);
      }

      return _receiveMessage;
    }()
  }]);

  return Oauth;
}();

var oauth = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Oauth: Oauth
});

var require$$12 = /*@__PURE__*/getAugmentedNamespace(oauth);

var require$$4 = /*@__PURE__*/getAugmentedNamespace(signatures);

var bs58 = bs58__default["default"];
var toBuffer = require$$1__default$2["default"].toBuffer;
var zeroPad = require$$2__default["default"].zeroPad;
var providers = require$$3__default$1["default"].providers;
var wormholeSDK = require$$4__default$1["default"];
var SolanaUtils = utils;
var Utils$6 = require$$18.Utils;
var wAudioFromWeiAudio = wAudio.wAudioFromWeiAudio;
var sign$1 = require$$4.sign,
    getTransferTokensDigest = require$$4.getTransferTokensDigest;
/** Singleton state-manager for Audius Eth Contracts */

var Wormhole = /*#__PURE__*/function () {
  /**
   * Wormhole constructor
   * @param {object} hedgehog
   * @param {object} ethWeb3Manager
   * @param {object} ethContracts
   * @param {object} identityService
   * @param {object} solanaWeb3Manager
   * @param {Array<string>} rpcHosts
   * @param {string} solBridgeAddress
   * @param {string} solTokenBridgeAddress
   * @param {string} ethBridgeAddress
   * @param {string} ethTokenBridgeAddress
   * @param {boolean} isServer
  */
  function Wormhole(hedgehog, ethWeb3Manager, ethContracts, identityService, solanaWeb3Manager, rpcHosts, solBridgeAddress, solTokenBridgeAddress, ethBridgeAddress, ethTokenBridgeAddress, isServer) {
    _classCallCheck(this, Wormhole);

    // Wormhole service dependecies
    this.hedgehog = hedgehog;
    this.ethWeb3Manager = ethWeb3Manager;
    this.ethContracts = ethContracts;
    this.identityService = identityService;
    this.solanaWeb3Manager = solanaWeb3Manager; // Wormhole config

    this.rpcHosts = rpcHosts;
    this.solBridgeAddress = solBridgeAddress;
    this.solTokenBridgeAddress = solTokenBridgeAddress;
    this.ethBridgeAddress = ethBridgeAddress;
    this.ethTokenBridgeAddress = ethTokenBridgeAddress;
    this.wormholeSDK = wormholeSDK;
  }

  _createClass(Wormhole, [{
    key: "getSignedVAAWithRetry",
    value: function () {
      var _getSignedVAAWithRetry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(hosts, emitterChain, emitterAddress, sequence) {
        var extraGrpcOpts,
            retryTimeout,
            retryAttempts,
            currentWormholeRpcHost,
            getNextRpcHost,
            result,
            attempts,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                extraGrpcOpts = _args.length > 4 && _args[4] !== undefined ? _args[4] : {};
                retryTimeout = _args.length > 5 && _args[5] !== undefined ? _args[5] : 5000;
                retryAttempts = _args.length > 6 && _args[6] !== undefined ? _args[6] : 60;
                currentWormholeRpcHost = -1;

                getNextRpcHost = function getNextRpcHost() {
                  return ++currentWormholeRpcHost % hosts.length;
                };

                attempts = 0;

              case 6:
                if (result) {
                  _context.next = 22;
                  break;
                }

                attempts++;
                _context.next = 10;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, retryTimeout);
                });

              case 10:
                _context.prev = 10;
                _context.next = 13;
                return this.wormholeSDK.getSignedVAA(hosts[getNextRpcHost()], emitterChain, emitterAddress, sequence, extraGrpcOpts);

              case 13:
                result = _context.sent;
                _context.next = 20;
                break;

              case 16:
                _context.prev = 16;
                _context.t0 = _context["catch"](10);

                if (!(retryAttempts !== undefined && attempts > retryAttempts)) {
                  _context.next = 20;
                  break;
                }

                throw _context.t0;

              case 20:
                _context.next = 6;
                break;

              case 22:
                return _context.abrupt("return", result);

              case 23:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[10, 16]]);
      }));

      function getSignedVAAWithRetry(_x, _x2, _x3, _x4) {
        return _getSignedVAAWithRetry.apply(this, arguments);
      }

      return getSignedVAAWithRetry;
    }()
    /**
     * Sends `amount` tokens to `solanaAccount` by way of the wormhole
     * @param {string} ethTxReceipt The tx receipt
     * @param {function} [customSignTransaction] Optional custom sign transaction parameter
     * @param {Object?} options The grpc options passed to get signed VAA for different transport
     *
     * else will attempt to relay
     * @returns {Promise} Promise object of {
          transactionSignature: string,
          error: Error,
          phase: string,
          logs: Array<string>
        }
     */

  }, {
    key: "attestAndCompleteTransferEthToSol",
    value: function () {
      var _attestAndCompleteTransferEthToSol = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(ethTxReceipt, customSignTransaction) {
        var _this = this;

        var options,
            phases,
            phase,
            logs,
            receipt,
            sequence,
            emitterAddress,
            _yield$this$getSigned,
            vaaBytes,
            connection,
            signTransaction,
            transaction,
            finalTxSignature,
            signedTransaction,
            txid,
            _yield$connection$get2,
            blockhash,
            transactionData,
            _yield$this$identityS,
            transactionSignature,
            _args5 = arguments;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};
                phases = {
                  GET_RECEIPT: 'GET_RECEIPT',
                  GET_SIGNED_VAA: 'GET_SIGNED_VAA',
                  POST_VAA_SOLANA: 'POST_VAA_SOLANA',
                  REDEEM_ON_SOLANA: 'REDEEM_ON_SOLANA'
                };
                phase = phases.GET_RECEIPT;
                logs = ["Attest and complete transfer for eth to sol for reciept ".concat(ethTxReceipt)];
                _context5.prev = 4;
                _context5.next = 7;
                return this.ethWeb3Manager.web3.eth.getTransactionReceipt(ethTxReceipt);

              case 7:
                receipt = _context5.sent;
                sequence = this.wormholeSDK.parseSequenceFromLogEth(receipt, this.ethBridgeAddress);
                emitterAddress = this.wormholeSDK.getEmitterAddressEth(this.ethTokenBridgeAddress);
                phase = phases.GET_SIGNED_VAA;
                _context5.next = 13;
                return this.getSignedVAAWithRetry(this.rpcHosts, this.wormholeSDK.CHAIN_ID_ETH, emitterAddress, sequence, options);

              case 13:
                _yield$this$getSigned = _context5.sent;
                vaaBytes = _yield$this$getSigned.vaaBytes;
                connection = this.solanaWeb3Manager.connection;

                if (customSignTransaction) {
                  signTransaction = customSignTransaction;
                } else {
                  signTransaction = /*#__PURE__*/function () {
                    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(transaction) {
                      var _yield$connection$get, blockhash, transactionData, _yield$_this$identity, transactionSignature;

                      return regeneratorRuntime.wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return connection.getLatestBlockhash();

                            case 2:
                              _yield$connection$get = _context2.sent;
                              blockhash = _yield$connection$get.blockhash;
                              // Must call serialize message to set the correct signatures on the transaction
                              transaction.serializeMessage();
                              transactionData = {
                                recentBlockhash: blockhash,
                                instructions: transaction.instructions.map(SolanaUtils.prepareInstructionForRelay),
                                signatures: transaction.signatures.map(function (sig) {
                                  return {
                                    publicKey: sig.publicKey.toString(),
                                    signature: sig.signature
                                  };
                                })
                              };
                              _context2.next = 8;
                              return _this.identityService.solanaRelayRaw(transactionData);

                            case 8:
                              _yield$_this$identity = _context2.sent;
                              transactionSignature = _yield$_this$identity.transactionSignature;
                              logs.push("Relay sol tx for postVAA with signature ".concat(transactionSignature));
                              return _context2.abrupt("return", {
                                serialize: function serialize() {}
                              });

                            case 12:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2);
                    }));

                    return function signTransaction(_x7) {
                      return _ref.apply(this, arguments);
                    };
                  }();

                  connection.sendRawTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            return _context3.abrupt("return", '');

                          case 1:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));
                  connection.confirmTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            return _context4.abrupt("return", '');

                          case 1:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));
                }

                phase = phases.POST_VAA_SOLANA;
                _context5.next = 20;
                return this.wormholeSDK.postVaaSolana(connection, signTransaction, this.solBridgeAddress, this.solanaWeb3Manager.feePayerAddress.toString(), // payerAddress
                vaaBytes);

              case 20:
                // Finally, redeem on Solana
                phase = phases.REDEEM_ON_SOLANA;
                _context5.next = 23;
                return this.wormholeSDK.redeemOnSolana(connection, this.solBridgeAddress, this.solTokenBridgeAddress, this.solanaWeb3Manager.feePayerAddress.toString(), // payerAddress,
                vaaBytes);

              case 23:
                transaction = _context5.sent;

                if (!customSignTransaction) {
                  _context5.next = 36;
                  break;
                }

                _context5.next = 27;
                return signTransaction(transaction);

              case 27:
                signedTransaction = _context5.sent;
                _context5.next = 30;
                return connection.sendRawTransaction(signedTransaction.serialize());

              case 30:
                txid = _context5.sent;
                finalTxSignature = txid;
                _context5.next = 34;
                return connection.confirmTransaction(txid);

              case 34:
                _context5.next = 47;
                break;

              case 36:
                transaction.serializeMessage();
                _context5.next = 39;
                return connection.getLatestBlockhash();

              case 39:
                _yield$connection$get2 = _context5.sent;
                blockhash = _yield$connection$get2.blockhash;
                transactionData = {
                  recentBlockhash: blockhash,
                  instructions: transaction.instructions.map(SolanaUtils.prepareInstructionForRelay),
                  signatures: transaction.signatures.map(function (sig) {
                    return {
                      publicKey: sig.publicKey.toString(),
                      signature: sig.signature
                    };
                  })
                };
                _context5.next = 44;
                return this.identityService.solanaRelayRaw(transactionData);

              case 44:
                _yield$this$identityS = _context5.sent;
                transactionSignature = _yield$this$identityS.transactionSignature;
                finalTxSignature = transactionSignature;

              case 47:
                logs.push("Complete redeem on sol with signature ".concat(finalTxSignature));
                return _context5.abrupt("return", {
                  transactionSignature: finalTxSignature,
                  error: null,
                  phase: phase,
                  logs: logs
                });

              case 51:
                _context5.prev = 51;
                _context5.t0 = _context5["catch"](4);
                return _context5.abrupt("return", {
                  error: _context5.t0.message,
                  phase: phase,
                  logs: logs
                });

              case 54:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[4, 51]]);
      }));

      function attestAndCompleteTransferEthToSol(_x5, _x6) {
        return _attestAndCompleteTransferEthToSol.apply(this, arguments);
      }

      return attestAndCompleteTransferEthToSol;
    }()
    /**
     * Sends `amount` tokens to `solanaAccount` by way of the wormhole
     * @param {BN} amount The amount of AUDIO to send in Wrapped Audio (8 decimals)
     * @param {string} ethTargetAddress The eth address to transfer AUDIO
     * @param {Object?} options The grpc options passed to get signed VAA for different transport
     */

  }, {
    key: "sendTokensFromSolToEthViaWormhole",
    value: function () {
      var _sendTokensFromSolToEthViaWormhole = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(amount, ethTargetAddress) {
        var options,
            phases,
            phase,
            logs,
            wAudioAmount,
            rootSolanaAccount,
            solanaAddress,
            associatedTokenAccount,
            tokenAccountInfo,
            connection,
            tx,
            _yield$connection$get3,
            blockhash,
            transactionData,
            _yield$this$identityS2,
            transactionSignature,
            info,
            sequence,
            emitterAddress,
            _yield$this$getSigned2,
            vaaBytes,
            signer,
            _args6 = arguments;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                options = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : {};
                phases = {
                  GENERATE_SOL_ROOT_ACCT: 'GENERATE_SOL_ROOT_ACCT',
                  TRANSFER_WAUDIO_TO_ROOT: 'TRANSFER_WAUDIO_TO_ROOT',
                  TRANFER_FROM_SOL: 'TRANFER_FROM_SOL',
                  GET_SIGNED_VAA: 'GET_SIGNED_VAA',
                  GET_EMITTER_ADDR: 'GET_EMITTER_ADDR',
                  REDEEM_ON_ETH: 'REDEEM_ON_ETH'
                };
                phase = phases.GENERATE_SOL_ROOT_ACCT;
                logs = ["Transferring ".concat(amount, " WAUDIO to ").concat(ethTargetAddress)];
                _context6.prev = 4;
                wAudioAmount = wAudioFromWeiAudio(amount); // Generate a solana keypair derived from the hedgehog private key
                // NOTE: The into to fromSeed is a 32 bytes Uint8Array

                rootSolanaAccount = this.solanaWeb3Manager.solanaWeb3.Keypair.fromSeed(this.hedgehog.wallet.getPrivateKey());
                solanaAddress = rootSolanaAccount.publicKey.toString();
                logs.push("Root Solana Account: ".concat(solanaAddress)); // Find the token account owned by the root solana account and get the token account's info

                _context6.next = 11;
                return this.solanaWeb3Manager.findAssociatedTokenAddress(solanaAddress);

              case 11:
                associatedTokenAccount = _context6.sent;
                _context6.next = 14;
                return this.solanaWeb3Manager.getAssociatedTokenAccountInfo(associatedTokenAccount.toString());

              case 14:
                tokenAccountInfo = _context6.sent;

                if (tokenAccountInfo) {
                  _context6.next = 21;
                  break;
                }

                logs.push("Creating Associated Token Account: ".concat(associatedTokenAccount.toString()));
                _context6.next = 19;
                return this.solanaWeb3Manager.createAssociatedTokenAccount(solanaAddress);

              case 19:
                _context6.next = 22;
                break;

              case 21:
                logs.push("Associated Token Account Exits: ".concat(associatedTokenAccount.toString()));

              case 22:
                phase = phases.TRANSFER_WAUDIO_TO_ROOT; // Move wrapped audio from then user bank account to the user's token wallet

                _context6.next = 25;
                return this.solanaWeb3Manager.transferWAudio(tokenAccountInfo.address.toString(), amount);

              case 25:
                logs.push("Transferred waudio ".concat(wAudioAmount.toString(), " balance to associated token account"));
                phase = phases.TRANFER_FROM_SOL;
                connection = this.solanaWeb3Manager.connection; // Submit transaction - results in a Wormhole message being published

                _context6.next = 30;
                return this.wormholeSDK.transferFromSolana(connection, // solana web3 Connection
                this.solBridgeAddress, // bridge address
                this.solTokenBridgeAddress, // token bridge address
                this.solanaWeb3Manager.feePayerAddress, // payerAddress
                tokenAccountInfo.address.toString(), // fromAddress
                this.solanaWeb3Manager.mintAddress, // mintAddress
                wAudioAmount, // BigInt
                zeroPad(toBuffer(ethTargetAddress), 32), // Uint8Array of length 32 targetAddress
                this.wormholeSDK.CHAIN_ID_ETH, // ChainId targetChain
                zeroPad(toBuffer(this.ethContracts.AudiusTokenClient.contractAddress), 32), // Uint8Array of length 32 originAddress
                this.wormholeSDK.CHAIN_ID_ETH, //  ChainId originChain
                solanaAddress // from owner address
                );

              case 30:
                tx = _context6.sent;
                // Must call serialize message to set the correct signatures on the transaction
                tx.serializeMessage();
                tx.partialSign(rootSolanaAccount);
                _context6.next = 35;
                return connection.getLatestBlockhash();

              case 35:
                _yield$connection$get3 = _context6.sent;
                blockhash = _yield$connection$get3.blockhash;
                transactionData = {
                  recentBlockhash: blockhash,
                  instructions: tx.instructions.map(SolanaUtils.prepareInstructionForRelay),
                  signatures: tx.signatures.map(function (sig) {
                    return {
                      publicKey: sig.publicKey.toString(),
                      signature: sig.signature
                    };
                  })
                };
                _context6.next = 40;
                return this.identityService.solanaRelayRaw(transactionData);

              case 40:
                _yield$this$identityS2 = _context6.sent;
                transactionSignature = _yield$this$identityS2.transactionSignature;
                logs.push("Transferred to wormhole with signature: ".concat(transactionSignature));
                phase = phases.GET_EMITTER_ADDR; // Get the sequence number and emitter address required to fetch the signedVAA of our message

                _context6.next = 46;
                return connection.getTransaction(transactionSignature);

              case 46:
                info = _context6.sent;
                sequence = this.wormholeSDK.parseSequenceFromLogSolana(info);
                _context6.next = 50;
                return this.wormholeSDK.getEmitterAddressSolana(this.solTokenBridgeAddress);

              case 50:
                emitterAddress = _context6.sent;
                // Fetch the signedVAA from the Wormhole Network (this may require retries while you wait for confirmation)
                phase = phases.GET_SIGNED_VAA;
                _context6.next = 54;
                return this.getSignedVAAWithRetry(this.rpcHosts, this.wormholeSDK.CHAIN_ID_SOLANA, emitterAddress, sequence, options);

              case 54:
                _yield$this$getSigned2 = _context6.sent;
                vaaBytes = _yield$this$getSigned2.vaaBytes;
                // Redeem on Ethereum
                // NOTE: The signer should be the user's personal wallet
                phase = phases.REDEEM_ON_ETH;
                signer = new providers.Web3Provider(window.ethereum).getSigner();
                _context6.next = 60;
                return this.wormholeSDK.redeemOnEth(this.ethTokenBridgeAddress, signer, vaaBytes);

              case 60:
                logs.push('Redeemed on eth');
                return _context6.abrupt("return", {
                  phase: phase,
                  logs: logs,
                  error: null
                });

              case 64:
                _context6.prev = 64;
                _context6.t0 = _context6["catch"](4);
                return _context6.abrupt("return", {
                  error: _context6.t0.message,
                  phase: phase,
                  logs: logs
                });

              case 67:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[4, 64]]);
      }));

      function sendTokensFromSolToEthViaWormhole(_x8, _x9) {
        return _sendTokensFromSolToEthViaWormhole.apply(this, arguments);
      }

      return sendTokensFromSolToEthViaWormhole;
    }()
    /**
     * Locks assets owned by `fromAccount` into the Solana wormhole with a target
     * solanaAccount destination via the provided relayer wallet.
     * @param {string} fromAccount the account holding the ETH AUDIO to transfer
     * @param {BN} amount The amount of AUDIO to send in WEI (18 decimals)
     * @param {string} solanaAccount The solana token account
     */

  }, {
    key: "_getTransferTokensToEthWormholeParams",
    value: function () {
      var _getTransferTokensToEthWormholeParams2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(fromAccount, amount, solanaAccount) {
        var web3, wormholeClientAddress, chainId, currentBlockNumber, currentBlock, deadline, solanaB58, recipient, nonce, arbiterFee, digest, myPrivateKey, signedDigest;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                web3 = this.ethWeb3Manager.getWeb3();
                wormholeClientAddress = this.ethContracts.WormholeClient.contractAddress;
                _context7.next = 4;
                return web3.eth.getChainId();

              case 4:
                chainId = _context7.sent;
                _context7.next = 7;
                return web3.eth.getBlockNumber();

              case 7:
                currentBlockNumber = _context7.sent;
                _context7.next = 10;
                return web3.eth.getBlock(currentBlockNumber);

              case 10:
                currentBlock = _context7.sent;
                // 1 hour, sufficiently far in future
                deadline = currentBlock.timestamp + 60 * 60 * 1;
                solanaB58 = bs58.decode(solanaAccount).toString('hex');
                recipient = toBuffer("0x".concat(solanaB58));
                _context7.next = 16;
                return this.ethContracts.WormholeClient.nonces(fromAccount);

              case 16:
                nonce = _context7.sent;
                arbiterFee = Utils$6.toBN('0');
                digest = getTransferTokensDigest(web3, 'AudiusWormholeClient', wormholeClientAddress, chainId, {
                  from: fromAccount,
                  amount: amount,
                  recipientChain: chainId,
                  recipient: recipient,
                  arbiterFee: arbiterFee
                }, nonce, deadline);
                myPrivateKey = this.hedgehog.wallet._privKey;
                signedDigest = sign$1(digest, myPrivateKey);
                return _context7.abrupt("return", {
                  chainId: chainId,
                  deadline: deadline,
                  recipient: recipient,
                  arbiterFee: arbiterFee,
                  signedDigest: signedDigest
                });

              case 22:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _getTransferTokensToEthWormholeParams(_x10, _x11, _x12) {
        return _getTransferTokensToEthWormholeParams2.apply(this, arguments);
      }

      return _getTransferTokensToEthWormholeParams;
    }()
    /**
     * Locks assets owned by `fromAccount` into the Solana wormhole with a target
     * solanaAccount destination via the provided relayer wallet.
     * @param {string} fromAccount the account holding the ETH AUDIO to transfer
     * @param {BN} amount The amount of AUDIO to send in WEI (18 decimals)
     * @param {string} solanaAccount The solana token account
     * @param {string} relayer The eth relayer to permission to aprrove and transfer
     */

  }, {
    key: "transferTokensToEthWormhole",
    value: function () {
      var _transferTokensToEthWormhole = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(fromAccount, amount, solanaAccount, relayer) {
        var _yield$this$_getTrans, chainId, deadline, recipient, arbiterFee, signedDigest, tx;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._getTransferTokensToEthWormholeParams(fromAccount, amount, solanaAccount);

              case 2:
                _yield$this$_getTrans = _context8.sent;
                chainId = _yield$this$_getTrans.chainId;
                deadline = _yield$this$_getTrans.deadline;
                recipient = _yield$this$_getTrans.recipient;
                arbiterFee = _yield$this$_getTrans.arbiterFee;
                signedDigest = _yield$this$_getTrans.signedDigest;
                _context8.next = 10;
                return this.ethContracts.WormholeClient.transferTokens(fromAccount, amount, chainId, recipient, arbiterFee, deadline, signedDigest, relayer);

              case 10:
                tx = _context8.sent;
                return _context8.abrupt("return", tx);

              case 12:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function transferTokensToEthWormhole(_x13, _x14, _x15, _x16) {
        return _transferTokensToEthWormhole.apply(this, arguments);
      }

      return transferTokensToEthWormhole;
    }()
  }, {
    key: "getTransferTokensToEthWormholeMethod",
    value: function () {
      var _getTransferTokensToEthWormholeMethod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(fromAccount, amount, solanaAccount, relayer) {
        var _yield$this$_getTrans2, chainId, deadline, recipient, arbiterFee, signedDigest, method;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._getTransferTokensToEthWormholeParams(fromAccount, amount, solanaAccount);

              case 2:
                _yield$this$_getTrans2 = _context9.sent;
                chainId = _yield$this$_getTrans2.chainId;
                deadline = _yield$this$_getTrans2.deadline;
                recipient = _yield$this$_getTrans2.recipient;
                arbiterFee = _yield$this$_getTrans2.arbiterFee;
                signedDigest = _yield$this$_getTrans2.signedDigest;
                _context9.next = 10;
                return this.ethContracts.WormholeClient.WormholeContract.methods.transferTokens(fromAccount, amount, chainId, recipient, arbiterFee, deadline, signedDigest.v, signedDigest.r, signedDigest.s);

              case 10:
                method = _context9.sent;
                return _context9.abrupt("return", method);

              case 12:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getTransferTokensToEthWormholeMethod(_x17, _x18, _x19, _x20) {
        return _getTransferTokensToEthWormholeMethod.apply(this, arguments);
      }

      return getTransferTokensToEthWormholeMethod;
    }()
  }]);

  return Wormhole;
}();

var wormhole = Wormhole;

var require$$14 = /*@__PURE__*/getAugmentedNamespace(ABIDecoder);

var schemaValidator = /*#__PURE__*/Object.freeze({
  __proto__: null,
  trackSchemaType: trackSchemaType,
  userSchemaType: userSchemaType,
  SchemaValidator: SchemaValidator
});

var require$$15 = /*@__PURE__*/getAugmentedNamespace(schemaValidator);

var supportsLocalStorage = function supportsLocalStorage() {
  return typeof window !== 'undefined' && window && window.localStorage;
};
/**
 * Singleton class to store the current user if initialized.
 * Some instances of AudiusLibs and services require a current user to
 * return valid queries, e.g. requesting the a discprov to return a reposted track.
 */


var UserStateManager = /*#__PURE__*/function () {
  function UserStateManager() {
    _classCallCheck(this, UserStateManager);

    // Should reflect the same fields as discovery node's /users?handle=<handle>
    this.currentUser = null;
  }
  /**
   * Sets this.currentUser with currentUser
   * @param {Object} currentUser fields to override this.currentUser with
   */


  _createClass(UserStateManager, [{
    key: "setCurrentUser",
    value: function setCurrentUser(currentUser) {
      this.currentUser = currentUser;

      if (supportsLocalStorage()) {
        window.localStorage.setItem(CURRENT_USER_EXISTS_LOCAL_STORAGE_KEY, 'true');
      }
    }
  }, {
    key: "getCurrentUser",
    value: function getCurrentUser() {
      return this.currentUser;
    }
  }, {
    key: "getCurrentUserId",
    value: function getCurrentUserId() {
      return this.currentUser ? this.currentUser.user_id : null;
    }
  }, {
    key: "clearUser",
    value: function clearUser() {
      this.currentUser = null;

      if (supportsLocalStorage()) {
        window.localStorage.removeItem(CURRENT_USER_EXISTS_LOCAL_STORAGE_KEY);
      }
    }
  }]);

  return UserStateManager;
}();

var userStateManager = /*#__PURE__*/Object.freeze({
  __proto__: null,
  UserStateManager: UserStateManager
});

var require$$16 = /*@__PURE__*/getAugmentedNamespace(userStateManager);

var axios$2 = axios__default["default"];
/** Sanity check for whether a user is a creator. If not, make them one. */

var hasCID = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(node, cid) {
    var url, res;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = "".concat(node.endpoint, "/ipfs/").concat(cid);
            _context.prev = 1;
            _context.next = 4;
            return axios$2.head(url);

          case 4:
            res = _context.sent;
            return _context.abrupt("return", res.status === 200);

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            return _context.abrupt("return", false);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 8]]);
  }));

  return function hasCID(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var hasAllCID = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(node, cids) {
    var hasAll;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return Promise.all(cids.map(function (cid) {
              return hasCID(node, cid);
            }));

          case 2:
            hasAll = _context2.sent;
            return _context2.abrupt("return", hasAll.every(Boolean));

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function hasAllCID(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();

var findCorrectNode = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(nodes, cids) {
    var i, hasAll;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            i = 0;

          case 1:
            if (!(i < nodes.length)) {
              _context3.next = 10;
              break;
            }

            _context3.next = 4;
            return hasAllCID(nodes[i], cids);

          case 4:
            hasAll = _context3.sent;

            if (!hasAll) {
              _context3.next = 7;
              break;
            }

            return _context3.abrupt("return", nodes[i]);

          case 7:
            ++i;
            _context3.next = 1;
            break;

          case 10:
            return _context3.abrupt("return", null);

          case 11:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function findCorrectNode(_x5, _x6) {
    return _ref3.apply(this, arguments);
  };
}();

var isCreator$1 = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(libs) {
    var user, cids, tracks, nodes, correctNode;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            console.debug('Sanity Check - isCreator');
            user = libs.userStateManager.getCurrentUser();

            if (!( // There is no currently logged in user
            !user || // The user has no tracks (they shouldn't become a creator)
            !user.track_count || // The user is a creator and has a creator node endpoint
            user.is_creator && user.creator_node_endpoint)) {
              _context4.next = 4;
              break;
            }

            return _context4.abrupt("return");

          case 4:
            console.debug('Sanity Check - isCreator - Running Check'); // Find the CIDs for all of the user's content (tracks + images)

            cids = [user.profile_picture, user.cover_photo];
            _context4.next = 8;
            return libs.Track.getTracks(500, 0, null, user.user_id);

          case 8:
            tracks = _context4.sent;
            tracks.forEach(function (track) {
              cids.push(track.cover_art);
              cids.push(track.metadata_multihash);
              track.track_segments.forEach(function (segment) {
                cids.push(segment.multihash);
              });
            });
            cids = cids.filter(Boolean); // Check whether all the CIDs are availabile on a creator node

            _context4.next = 13;
            return libs.ServiceProvider.listCreatorNodes();

          case 13:
            nodes = _context4.sent;
            _context4.next = 16;
            return findCorrectNode(nodes, cids);

          case 16:
            correctNode = _context4.sent;

            if (!correctNode) {
              _context4.next = 27;
              break;
            }

            _context4.prev = 18;
            console.debug('Sanity Check - isCreator - Upgrading to Creator');
            _context4.next = 22;
            return libs.User.upgradeToCreator(null, correctNode.endpoint);

          case 22:
            _context4.next = 27;
            break;

          case 24:
            _context4.prev = 24;
            _context4.t0 = _context4["catch"](18);
            console.error(_context4.t0); // We were actually a creator the whole time O_O

          case 27:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[18, 24]]);
  }));

  return function isCreator(_x7) {
    return _ref4.apply(this, arguments);
  };
}();

var isCreator_1 = isCreator$1;

var sanitizeNodes$1 = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(libs, secondaries) {
    var user, sanitizedEndpoint, newMetadata;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            console.debug('Sanity Check - sanitizeNodes');
            user = libs.userStateManager.getCurrentUser();

            if (!(!user || !user.is_creator)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return");

          case 4:
            sanitizedEndpoint = user.creator_node_endpoint.split(',').filter(Boolean).join(',');

            if (!(sanitizedEndpoint !== user.creator_node_endpoint)) {
              _context.next = 11;
              break;
            }

            console.debug("Sanity Check - sanitizingNodes - ".concat(user.creator_node_endpoint, " -> ").concat(sanitizedEndpoint));
            newMetadata = _objectSpread2({}, user);
            newMetadata.creator_node_endpoint = sanitizedEndpoint;
            _context.next = 11;
            return libs.User.updateCreator(user.user_id, newMetadata);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function sanitizeNodes(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var sanitizeNodes_1 = sanitizeNodes$1;

var CreatorNode$5 = require$$10.CreatorNode;
/**
 * Add secondary creator nodes for a user if they don't have any
 * Goal: Make it so users always have a replica set
 */

var addSecondaries$1 = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(libs) {
    var user, primary, secondaries, currentEndpoints, services, newSecondaries, newEndpoints, newMetadata;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            console.debug('Sanity Check - addSecondaries');
            user = libs.userStateManager.getCurrentUser();

            if (!(!user || !user.is_creator)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return");

          case 4:
            primary = CreatorNode$5.getPrimary(user.creator_node_endpoint);
            secondaries = CreatorNode$5.getSecondaries(user.creator_node_endpoint); // Get current endpoints and check if we don't have enough secondaries

            if (!(secondaries.length < 2)) {
              _context.next = 20;
              break;
            }

            console.debug("Sanity Check - addSecondaries - User has only ".concat(secondaries.length)); // Find new healthy secondaries

            currentEndpoints = CreatorNode$5.getEndpoints(user.creator_node_endpoint);
            _context.next = 11;
            return libs.ServiceProvider.getSelectableCreatorNodes(
            /* whitelist */
            null,
            /* blacklist */
            new Set(currentEndpoints));

          case 11:
            services = _context.sent;
            console.debug("Sanity Check - addSecondaries - found services ".concat(JSON.stringify(services)));
            newSecondaries = Object.keys(services).slice(0, 2 - secondaries.length); // Combine primary, current secondaries, and new secondaries

            newEndpoints = [primary].concat(_toConsumableArray(secondaries), _toConsumableArray(newSecondaries));
            newMetadata = _objectSpread2({}, user);
            newMetadata.creator_node_endpoint = newEndpoints.join(',');
            console.debug("Sanity Check - addSecondaries - new nodes ".concat(newMetadata.creator_node_endpoint));
            _context.next = 20;
            return libs.User.updateCreator(user.user_id, newMetadata);

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function addSecondaries(_x) {
    return _ref.apply(this, arguments);
  };
}();

var addSecondaries_1 = addSecondaries$1;

var CreatorNode$4 = require$$10.CreatorNode;
/**
 * Syncs a creator node if its blocknubmer is behind the passed
 * in blocknumber.
 */

var syncNodeIfBehind = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(libs, endpoint) {
    var _yield$libs$creatorNo, isBehind, isConfigured;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return libs.creatorNode.getSyncStatus(endpoint);

          case 3:
            _yield$libs$creatorNo = _context.sent;
            isBehind = _yield$libs$creatorNo.isBehind;
            isConfigured = _yield$libs$creatorNo.isConfigured;

            if (!(isBehind || !isConfigured)) {
              _context.next = 10;
              break;
            }

            console.debug("Sanity Check - syncNodes - syncing ".concat(endpoint));
            _context.next = 10;
            return libs.creatorNode.syncSecondary(endpoint);

          case 10:
            _context.next = 15;
            break;

          case 12:
            _context.prev = 12;
            _context.t0 = _context["catch"](0);
            console.error(_context.t0);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 12]]);
  }));

  return function syncNodeIfBehind(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var syncNodes$1 = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(libs) {
    var user, secondaries;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            console.debug('Sanity Check - syncNodes');
            user = libs.userStateManager.getCurrentUser();

            if (!(!user || !user.is_creator)) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return");

          case 4:
            secondaries = CreatorNode$4.getSecondaries(user.creator_node_endpoint);
            _context2.next = 7;
            return Promise.all(secondaries.map(function (secondary) {
              return syncNodeIfBehind(libs, secondary);
            }));

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function syncNodes(_x3) {
    return _ref2.apply(this, arguments);
  };
}();

var syncNodes_1 = syncNodes$1;

var Utils$5 = require$$18.Utils;
var CreatorNode$3 = require$$10.CreatorNode;
var THREE_SECONDS = 3000;
var MAX_TRIES = 3;
/** Check if the user's primary creator node is healthy */

var checkPrimaryHealthy = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(libs, primary, tries) {
    var healthy;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return Utils$5.isHealthy(primary);

          case 2:
            healthy = _context.sent;

            if (!healthy) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return", healthy);

          case 7:
            if (!(tries === 0)) {
              _context.next = 9;
              break;
            }

            return _context.abrupt("return", false);

          case 9:
            _context.next = 11;
            return Utils$5.wait(THREE_SECONDS);

          case 11:
            return _context.abrupt("return", checkPrimaryHealthy(libs, primary, tries - 1));

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function checkPrimaryHealthy(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
/** Gets new endpoints from a user's secondaries */


var getNewPrimary = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(libs, secondaries) {
    var _iterator, _step, secondary, _yield$libs$creatorNo, isBehind;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _iterator = _createForOfIteratorHelper(secondaries);
            _context2.prev = 1;

            _iterator.s();

          case 3:
            if ((_step = _iterator.n()).done) {
              _context2.next = 13;
              break;
            }

            secondary = _step.value;
            _context2.next = 7;
            return libs.creatorNode.getSyncStatus(secondary);

          case 7:
            _yield$libs$creatorNo = _context2.sent;
            isBehind = _yield$libs$creatorNo.isBehind;

            if (isBehind) {
              _context2.next = 11;
              break;
            }

            return _context2.abrupt("return", secondary);

          case 11:
            _context2.next = 3;
            break;

          case 13:
            _context2.next = 18;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t0 = _context2["catch"](1);

            _iterator.e(_context2.t0);

          case 18:
            _context2.prev = 18;

            _iterator.f();

            return _context2.finish(18);

          case 21:
            throw new Error("Could not find valid secondaries for user ".concat(secondaries));

          case 22:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[1, 15, 18, 21]]);
  }));

  return function getNewPrimary(_x4, _x5) {
    return _ref2.apply(this, arguments);
  };
}();

var rolloverNodes$1 = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(libs, creatorNodeWhitelist) {
    var user, primary, healthy, secondaries, newPrimary, index, newSecondaries, autoselect, newEndpoints, newMetadata;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            console.debug('Sanity Check - rolloverNodes');
            user = libs.userStateManager.getCurrentUser();

            if (!(!user || !user.is_creator)) {
              _context3.next = 4;
              break;
            }

            return _context3.abrupt("return");

          case 4:
            primary = CreatorNode$3.getPrimary(user.creator_node_endpoint);
            _context3.next = 7;
            return checkPrimaryHealthy(libs, primary, MAX_TRIES);

          case 7:
            healthy = _context3.sent;

            if (!healthy) {
              _context3.next = 10;
              break;
            }

            return _context3.abrupt("return");

          case 10:
            secondaries = CreatorNode$3.getSecondaries(user.creator_node_endpoint);
            _context3.prev = 11;
            _context3.next = 14;
            return getNewPrimary(libs, secondaries);

          case 14:
            newPrimary = _context3.sent;
            index = secondaries.indexOf(newPrimary); // Get new secondaries and backfill up to 2

            newSecondaries = _toConsumableArray(secondaries);
            newSecondaries.splice(index, 1);
            _context3.next = 20;
            return libs.ServiceProvider.autoSelectCreatorNodes({
              numberOfNodes: 2 - newSecondaries.length,
              whitelist: creatorNodeWhitelist,
              // Exclude ones we currently have
              blacklist: new Set([newPrimary].concat(_toConsumableArray(newSecondaries))),
              preferHigherPatchForPrimary: libs.User.preferHigherPatchForPrimary,
              preferHigherPatchForSecondaries: libs.User.preferHigherPatchForSecondaries
            });

          case 20:
            autoselect = _context3.sent;
            newSecondaries = newSecondaries.concat([autoselect.primary].concat(_toConsumableArray(autoselect.secondaries))); // Set the new endpoint and connect to it

            newEndpoints = [newPrimary].concat(_toConsumableArray(newSecondaries));
            _context3.next = 25;
            return libs.creatorNode.setEndpoint(newEndpoints[0]);

          case 25:
            // Update the user
            newMetadata = _objectSpread2({}, user);
            newMetadata.creator_node_endpoint = newEndpoints.join(',');
            console.debug("Sanity Check - rolloverNodes - new nodes ".concat(newMetadata.creator_node_endpoint));
            _context3.next = 30;
            return libs.User.updateCreator(user.user_id, newMetadata);

          case 30:
            _context3.next = 35;
            break;

          case 32:
            _context3.prev = 32;
            _context3.t0 = _context3["catch"](11);
            console.error(_context3.t0);

          case 35:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[11, 32]]);
  }));

  return function rolloverNodes(_x6, _x7) {
    return _ref3.apply(this, arguments);
  };
}();

var rolloverNodes_1 = rolloverNodes$1;

var needsRecoveryEmail = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(libs) {
    var user, events;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            console.debug('Sanity Check - needsRecoveryEmail');
            user = libs.userStateManager.getCurrentUser();

            if (!(!user || !user.wallet)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return");

          case 4:
            _context.next = 6;
            return libs.identityService.getUserEvents(user.wallet);

          case 6:
            events = _context.sent;

            if (!events.needsRecoveryEmail) {
              _context.next = 11;
              break;
            }

            console.debug('Sanity Check - needsRecoveryEmail - Sending Email'); // Send email

            _context.next = 11;
            return libs.Account.generateRecoveryLink();

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function needsRecoveryEmail(_x) {
    return _ref.apply(this, arguments);
  };
}();

var needsRecoveryEmail_1 = needsRecoveryEmail;

var assignReplicaSetIfNecessary$1 = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(libs) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return libs.User.assignReplicaSetIfNecessary();

          case 3:
            _context.next = 8;
            break;

          case 5:
            _context.prev = 5;
            _context.t0 = _context["catch"](0);
            // If sanity check fails, do not block main thread and log error
            console.error(_context.t0.message);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 5]]);
  }));

  return function assignReplicaSetIfNecessary(_x) {
    return _ref.apply(this, arguments);
  };
}();

var assignReplicaSetIfNecessary_1 = assignReplicaSetIfNecessary$1;

var isCreator = isCreator_1;
var sanitizeNodes = sanitizeNodes_1;
var addSecondaries = addSecondaries_1;
var syncNodes = syncNodes_1;
var rolloverNodes = rolloverNodes_1;
var recoveryEmail = needsRecoveryEmail_1;
var assignReplicaSetIfNecessary = assignReplicaSetIfNecessary_1; // Checks to run at startup to ensure a user is in a good state.

var SanityChecks = /*#__PURE__*/function () {
  function SanityChecks(libsInstance) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      skipRollover: false
    };

    _classCallCheck(this, SanityChecks);

    this.libs = libsInstance;
    this.options = options;
  }
  /**
   * Runs sanity checks
   * @param {Set<string>} creatorNodeWhitelist
   */


  _createClass(SanityChecks, [{
    key: "run",
    value: function () {
      var _run = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var creatorNodeWhitelist,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                creatorNodeWhitelist = _args.length > 0 && _args[0] !== undefined ? _args[0] : null;
                _context.next = 3;
                return isCreator(this.libs);

              case 3:
                _context.next = 5;
                return sanitizeNodes(this.libs);

              case 5:
                _context.next = 7;
                return addSecondaries(this.libs);

              case 7:
                _context.next = 9;
                return assignReplicaSetIfNecessary(this.libs);

              case 9:
                _context.next = 11;
                return syncNodes(this.libs);

              case 11:
                if (this.options.skipRollover) {
                  _context.next = 14;
                  break;
                }

                _context.next = 14;
                return rolloverNodes(this.libs, creatorNodeWhitelist);

              case 14:
                _context.next = 16;
                return recoveryEmail(this.libs);

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function run() {
        return _run.apply(this, arguments);
      }

      return run;
    }()
  }]);

  return SanityChecks;
}();

var sanityChecks = SanityChecks;

var Services$6 = Object.freeze({
  IDENTITY_SERVICE: 'Identity Service',
  HEDGEHOG: 'Hedgehog',
  DISCOVERY_PROVIDER: 'Discovery Provider',
  CREATOR_NODE: 'Creator Node',
  COMSTOCK: 'Comstock',
  SOLANA_WEB3_MANAGER: 'Solana Web3 Manager'
});

var Base$7 = /*#__PURE__*/function () {
  function Base(userStateManager, identityService, hedgehog, discoveryProvider, web3Manager, contracts, ethWeb3Manager, ethContracts, solanaWeb3Manager, anchorAudiusData, wormholeClient, creatorNode, comstock, captcha, isServer) {
    var _this$_serviceMapping;

    var logger = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : console;

    _classCallCheck(this, Base);

    this.userStateManager = userStateManager;
    this.identityService = identityService;
    this.hedgehog = hedgehog;
    this.discoveryProvider = discoveryProvider;
    this.web3Manager = web3Manager;
    this.contracts = contracts;
    this.ethWeb3Manager = ethWeb3Manager;
    this.ethContracts = ethContracts;
    this.solanaWeb3Manager = solanaWeb3Manager;
    this.anchorAudiusData = anchorAudiusData;
    this.wormholeClient = wormholeClient;
    this.creatorNode = creatorNode;
    this.comstock = comstock;
    this.captcha = captcha;
    this.isServer = isServer;
    this.logger = logger;
    this._serviceMapping = (_this$_serviceMapping = {}, _defineProperty(_this$_serviceMapping, Services$6.IDENTITY_SERVICE, this.identityService), _defineProperty(_this$_serviceMapping, Services$6.HEDGEHOG, this.hedgehog), _defineProperty(_this$_serviceMapping, Services$6.DISCOVERY_PROVIDER, this.discoveryProvider), _defineProperty(_this$_serviceMapping, Services$6.CREATOR_NODE, this.creatorNode), _defineProperty(_this$_serviceMapping, Services$6.COMSTOCK, this.comstock), _defineProperty(_this$_serviceMapping, Services$6.SOLANA_WEB3_MANAGER, this.solanaWeb3Manager), _this$_serviceMapping);
  }

  _createClass(Base, [{
    key: "REQUIRES",
    value: function REQUIRES() {
      var _this = this;

      for (var _len = arguments.length, services = new Array(_len), _key = 0; _key < _len; _key++) {
        services[_key] = arguments[_key];
      }

      services.forEach(function (s) {
        if (!_this._serviceMapping[s]) return Base._missingService(services);
      });
    }
  }, {
    key: "IS_OBJECT",
    value: function IS_OBJECT(o) {
      if (_typeof(o) !== 'object') return Base._invalidType('object');
    }
  }, {
    key: "OBJECT_HAS_PROPS",
    value: function OBJECT_HAS_PROPS(o, props, requiredProps) {
      var missingProps = [];
      props.forEach(function (prop) {
        if (!Object.prototype.hasOwnProperty.call(o, prop)) missingProps.push(prop);
      });
      if (missingProps.length > 0) return Base._missingProps(missingProps);
      var missingRequiredProps = [];
      requiredProps.forEach(function (prop) {
        if (!Object.prototype.hasOwnProperty.call(o, prop) || o[prop] === '') missingRequiredProps.push(prop);
      });
      if (missingRequiredProps.length > 0) return Base._missingPropValues(missingRequiredProps);
    }
  }, {
    key: "FILE_IS_VALID",
    value: function FILE_IS_VALID(file) {
      if (this.isServer) {
        if (!file || _typeof(file) !== 'object' || typeof file.pipe !== 'function' || !file.readable) {
          return Base._invalidFile();
        }
      } else {
        if (!file || _typeof(file) !== 'object') {
          return Base._missingFile();
        }
      }
    }
    /* ------- PRIVATE  ------- */

  }], [{
    key: "_missingService",
    value: function _missingService() {
      for (var _len2 = arguments.length, serviceNames = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        serviceNames[_key2] = arguments[_key2];
      }

      throw new Error("Requires the following services: ".concat(serviceNames.join(', ')));
    }
  }, {
    key: "_invalidType",
    value: function _invalidType(type) {
      throw new Error("Argument must be of type ".concat(type));
    }
  }, {
    key: "_missingProps",
    value: function _missingProps(props) {
      throw new Error("Missing props ".concat(props.join(', ')));
    }
  }, {
    key: "_missingPropValues",
    value: function _missingPropValues(props) {
      throw new Error("Missing field values ".concat(props.join(', ')));
    }
  }, {
    key: "_invalidFile",
    value: function _invalidFile() {
      throw new Error('Expected file as readable stream');
    }
  }, {
    key: "_missingFile",
    value: function _missingFile() {
      throw new Error('Missing or malformed file');
    }
  }]);

  return Base;
}();

var base = {
  Base: Base$7,
  Services: Services$6
};

var Base$6 = base.Base,
    Services$5 = base.Services;
var CreatorNode$2 = require$$10.CreatorNode;
var Utils$4 = require$$18.Utils;
var AuthHeaders = require$$5.AuthHeaders;
var getPermitDigest = require$$4.getPermitDigest,
    sign = require$$4.sign;
var PublicKey = require$$1__default["default"].PublicKey;
var BN$1 = anchor__default["default"].BN;

var Account = /*#__PURE__*/function (_Base) {
  _inherits(Account, _Base);

  var _super = _createSuper(Account);

  function Account(userApi) {
    var _this;

    _classCallCheck(this, Account);

    for (var _len = arguments.length, services = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      services[_key - 1] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(services));
    _this.User = userApi;
    _this.getCurrentUser = _this.getCurrentUser.bind(_assertThisInitialized(_this));
    _this.login = _this.login.bind(_assertThisInitialized(_this));
    _this.logout = _this.logout.bind(_assertThisInitialized(_this));
    _this.signUp = _this.signUp.bind(_assertThisInitialized(_this));
    _this.generateRecoveryLink = _this.generateRecoveryLink.bind(_assertThisInitialized(_this));
    _this.confirmCredentials = _this.confirmCredentials.bind(_assertThisInitialized(_this));
    _this.changePassword = _this.changePassword.bind(_assertThisInitialized(_this));
    _this.resetPassword = _this.resetPassword.bind(_assertThisInitialized(_this));
    _this.checkIfEmailRegistered = _this.checkIfEmailRegistered.bind(_assertThisInitialized(_this));
    _this.getUserEmail = _this.getUserEmail.bind(_assertThisInitialized(_this));
    _this.associateTwitterUser = _this.associateTwitterUser.bind(_assertThisInitialized(_this));
    _this.associateInstagramUser = _this.associateInstagramUser.bind(_assertThisInitialized(_this));
    _this.handleIsValid = _this.handleIsValid.bind(_assertThisInitialized(_this));
    _this.lookupTwitterHandle = _this.lookupTwitterHandle.bind(_assertThisInitialized(_this));
    _this.updateCreatorNodeEndpoint = _this.updateCreatorNodeEndpoint.bind(_assertThisInitialized(_this));
    _this.searchFull = _this.searchFull.bind(_assertThisInitialized(_this));
    _this.searchAutocomplete = _this.searchAutocomplete.bind(_assertThisInitialized(_this));
    _this.searchTags = _this.searchTags.bind(_assertThisInitialized(_this));
    _this.sendTokensFromEthToSol = _this.sendTokensFromEthToSol.bind(_assertThisInitialized(_this));
    _this.sendTokensFromSolToEth = _this.sendTokensFromSolToEth.bind(_assertThisInitialized(_this));
    _this.getUserAccountOnSolana = _this.getUserAccountOnSolana.bind(_assertThisInitialized(_this));
    _this.userHasClaimedSolAccount = _this.userHasClaimedSolAccount.bind(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Fetches the user metadata for the current account
   * @return {Object} user metadata
   */


  _createClass(Account, [{
    key: "getCurrentUser",
    value: function getCurrentUser() {
      return this.userStateManager.getCurrentUser();
    }
    /**
     * Logs a user into Audius
     * @param {string} email
     * @param {string} password
     */

  }, {
    key: "login",
    value: function () {
      var _login = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(email, password) {
        var phases, phase, ownerWallet, userAccount, creatorNodeEndpoint;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                phases = {
                  FIND_WALLET: 'FIND_WALLET',
                  FIND_USER: 'FIND_USER'
                };
                phase = '';
                phase = phases.FIND_WALLET;

                if (this.web3Manager.web3IsExternal()) {
                  _context.next = 16;
                  break;
                }

                this.REQUIRES(Services$5.HEDGEHOG);
                _context.prev = 5;
                _context.next = 8;
                return this.hedgehog.login(email, password);

              case 8:
                ownerWallet = _context.sent;
                _context.next = 11;
                return this.web3Manager.setOwnerWallet(ownerWallet);

              case 11:
                _context.next = 16;
                break;

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](5);
                return _context.abrupt("return", {
                  error: _context.t0.message,
                  phase: phase
                });

              case 16:
                phase = phases.FIND_USER;
                _context.next = 19;
                return this.discoveryProvider.getUserAccount(this.web3Manager.getWalletAddress());

              case 19:
                userAccount = _context.sent;

                if (!userAccount) {
                  _context.next = 25;
                  break;
                }

                this.userStateManager.setCurrentUser(userAccount);
                creatorNodeEndpoint = userAccount.creator_node_endpoint;

                if (creatorNodeEndpoint) {
                  this.creatorNode.setEndpoint(CreatorNode$2.getPrimary(creatorNodeEndpoint));
                }

                return _context.abrupt("return", {
                  user: userAccount,
                  error: false,
                  phase: phase
                });

              case 25:
                return _context.abrupt("return", {
                  error: 'No user found',
                  phase: phase
                });

              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[5, 13]]);
      }));

      function login(_x, _x2) {
        return _login.apply(this, arguments);
      }

      return login;
    }()
    /**
     * Logs a user out of Audius
     * Note: Actions will stop working at this point, but
     * clients may wish to call window.location.reload()
     * to show the user as logged out
     */

  }, {
    key: "logout",
    value: function logout() {
      if (!this.web3Manager.web3IsExternal()) {
        this.REQUIRES(Services$5.HEDGEHOG);
        this.hedgehog.logout();
        this.userStateManager.clearUser();
      }
    }
    /**
     * Signs a user up for Audius
     * @param {string} email
     * @param {string} password
     * @param {Object} metadata
     * @param {?File} [profilePictureFile] an optional file to upload as the profile picture
     * @param {?File} [coverPhotoFile] an optional file to upload as the cover phtoo
     * @param {?boolean} [hasWallet]
     * @param {?boolean} [host] The host url used for the recovery email
     * @param {?boolean} [createWAudioUserBank] an optional flag to create the solana user bank account
     * @param {?Function} [handleUserBankOutcomes] an optional callback to record user bank outcomes
     * @param {?Object} [userBankOutcomes] an optional object with request, succes, and failure keys to record user bank outcomes
     * @param {?string} [feePayerOverride] an optional string in case the client wants to switch between fee payers
     * @param {?boolean} [generateRecoveryLink] an optional flag to skip generating recovery link for testing purposes
    */

  }, {
    key: "signUp",
    value: function () {
      var _signUp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(email, password, metadata) {
        var _this2 = this;

        var profilePictureFile,
            coverPhotoFile,
            hasWallet,
            host,
            handleUserBankOutcomes,
            userBankOutcomes,
            feePayerOverride,
            generateRecoveryLink,
            phases,
            phase,
            userId,
            blockHash,
            blockNumber,
            ownerWallet,
            response,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                profilePictureFile = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : null;
                coverPhotoFile = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : null;
                hasWallet = _args3.length > 5 && _args3[5] !== undefined ? _args3[5] : false;
                host = _args3.length > 6 && _args3[6] !== undefined ? _args3[6] : typeof window !== 'undefined' && window.location.origin || null;
                handleUserBankOutcomes = _args3.length > 7 && _args3[7] !== undefined ? _args3[7] : function () {};
                userBankOutcomes = _args3.length > 8 && _args3[8] !== undefined ? _args3[8] : {};
                feePayerOverride = _args3.length > 9 && _args3[9] !== undefined ? _args3[9] : null;
                generateRecoveryLink = _args3.length > 10 && _args3[10] !== undefined ? _args3[10] : true;
                phases = {
                  ADD_REPLICA_SET: 'ADD_REPLICA_SET',
                  CREATE_USER_RECORD: 'CREATE_USER_RECORD',
                  HEDGEHOG_SIGNUP: 'HEDGEHOG_SIGNUP',
                  SOLANA_USER_BANK_CREATION: 'SOLANA_USER_BANK_CREATION',
                  UPLOAD_PROFILE_IMAGES: 'UPLOAD_PROFILE_IMAGES',
                  ADD_USER: 'ADD_USER'
                };
                phase = '';
                _context3.prev = 10;
                this.REQUIRES(Services$5.CREATOR_NODE, Services$5.IDENTITY_SERVICE);

                if (!this.web3Manager.web3IsExternal()) {
                  _context3.next = 18;
                  break;
                }

                phase = phases.CREATE_USER_RECORD;
                _context3.next = 16;
                return this.identityService.createUserRecord(email, this.web3Manager.getWalletAddress());

              case 16:
                _context3.next = 29;
                break;

              case 18:
                this.REQUIRES(Services$5.HEDGEHOG); // If an owner wallet already exists, don't try to recreate it

                if (hasWallet) {
                  _context3.next = 29;
                  break;
                }

                phase = phases.HEDGEHOG_SIGNUP;
                _context3.next = 23;
                return this.hedgehog.signUp(email, password);

              case 23:
                ownerWallet = _context3.sent;
                _context3.next = 26;
                return this.web3Manager.setOwnerWallet(ownerWallet);

              case 26:
                if (!generateRecoveryLink) {
                  _context3.next = 29;
                  break;
                }

                _context3.next = 29;
                return this.generateRecoveryLink({
                  handle: metadata.handle,
                  host: host
                });

              case 29:
                // Create a wAudio user bank address.
                // If userbank creation fails, we still proceed
                // through signup
                if (this.solanaWeb3Manager) {
                  phase = phases.SOLANA_USER_BANK_CREATION; // Fire and forget createUserBank. In the case of failure, we will
                  // retry to create user banks in a later session before usage

                  _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                    var _yield$_this2$solanaW, error, errorCode;

                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.prev = 0;
                            handleUserBankOutcomes(userBankOutcomes.Request);
                            _context2.next = 4;
                            return _this2.solanaWeb3Manager.createUserBank(feePayerOverride);

                          case 4:
                            _yield$_this2$solanaW = _context2.sent;
                            error = _yield$_this2$solanaW.error;
                            errorCode = _yield$_this2$solanaW.errorCode;

                            if (error || errorCode) {
                              console.error("Failed to create userbank, with err: ".concat(error, ", ").concat(errorCode));
                              handleUserBankOutcomes(userBankOutcomes.Failure, {
                                error: error,
                                errorCode: errorCode
                              });
                            } else {
                              console.log('Successfully created userbank!');
                              handleUserBankOutcomes('Create User Bank: Success');
                            }

                            _context2.next = 14;
                            break;

                          case 10:
                            _context2.prev = 10;
                            _context2.t0 = _context2["catch"](0);
                            console.error("Got error creating userbank: ".concat(_context2.t0, ", continuing..."));
                            handleUserBankOutcomes(userBankOutcomes.Failure, {
                              error: _context2.t0.toString()
                            });

                          case 14:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, null, [[0, 10]]);
                  }))();
                } // Add user to chain


                phase = phases.ADD_USER;
                _context3.next = 33;
                return this.User.addUser(metadata);

              case 33:
                response = _context3.sent;
                userId = response.userId;
                blockHash = response.blockHash;
                blockNumber = response.blockNumber; // Assign replica set to user, updates creator_node_endpoint on chain, and then update metadata object on content node + chain (in this order)

                phase = phases.ADD_REPLICA_SET;
                _context3.next = 40;
                return this.User.assignReplicaSet({
                  userId: userId
                });

              case 40:
                metadata = _context3.sent;
                // Upload profile pic and cover photo to primary Content Node and sync across secondaries
                phase = phases.UPLOAD_PROFILE_IMAGES;
                _context3.next = 44;
                return this.User.uploadProfileImages(profilePictureFile, coverPhotoFile, metadata);

              case 44:
                _context3.next = 49;
                break;

              case 46:
                _context3.prev = 46;
                _context3.t0 = _context3["catch"](10);
                return _context3.abrupt("return", {
                  error: _context3.t0.message,
                  phase: phase,
                  errorStatus: _context3.t0.response ? _context3.t0.response.status : null
                });

              case 49:
                return _context3.abrupt("return", {
                  blockHash: blockHash,
                  blockNumber: blockNumber,
                  userId: userId
                });

              case 50:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[10, 46]]);
      }));

      function signUp(_x3, _x4, _x5) {
        return _signUp.apply(this, arguments);
      }

      return signUp;
    }()
    /**
     * Generates and sends a recovery email for a user
     * @param {string} [handle] The user handle, defaults to the current user handle
     * @param {string} [host] The host domain, defaults to window.location.origin
     */

  }, {
    key: "generateRecoveryLink",
    value: function () {
      var _generateRecoveryLink = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _ref2,
            handle,
            host,
            recoveryInfo,
            unixTs,
            data,
            signature,
            recoveryData,
            _args4 = arguments;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _ref2 = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {}, handle = _ref2.handle, host = _ref2.host;
                this.REQUIRES(Services$5.IDENTITY_SERVICE);
                _context4.prev = 2;
                _context4.next = 5;
                return this.hedgehog.generateRecoveryInfo();

              case 5:
                recoveryInfo = _context4.sent;
                handle = handle || this.userStateManager.getCurrentUser().handle;
                unixTs = Math.round(new Date().getTime() / 1000); // current unix timestamp (sec)

                data = "Click sign to authenticate with identity service: ".concat(unixTs);
                _context4.next = 11;
                return this.web3Manager.sign(data);

              case 11:
                signature = _context4.sent;
                recoveryData = {
                  login: recoveryInfo.login,
                  host: host || recoveryInfo.host,
                  data: data,
                  signature: signature,
                  handle: handle
                };
                _context4.next = 15;
                return this.identityService.sendRecoveryInfo(recoveryData);

              case 15:
                _context4.next = 20;
                break;

              case 17:
                _context4.prev = 17;
                _context4.t0 = _context4["catch"](2);
                console.error(_context4.t0);

              case 20:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[2, 17]]);
      }));

      function generateRecoveryLink() {
        return _generateRecoveryLink.apply(this, arguments);
      }

      return generateRecoveryLink;
    }()
  }, {
    key: "resetPassword",
    value: function () {
      var _resetPassword = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(email, newpassword) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.hedgehog.resetPassword(email, newpassword));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function resetPassword(_x6, _x7) {
        return _resetPassword.apply(this, arguments);
      }

      return resetPassword;
    }()
  }, {
    key: "changePassword",
    value: function () {
      var _changePassword = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(email, newpassword, oldpassword) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", this.hedgehog.changePassword(email, newpassword, oldpassword));

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function changePassword(_x8, _x9, _x10) {
        return _changePassword.apply(this, arguments);
      }

      return changePassword;
    }()
  }, {
    key: "confirmCredentials",
    value: function () {
      var _confirmCredentials = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(email, password) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", this.hedgehog.confirmCredentials(email, password));

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function confirmCredentials(_x11, _x12) {
        return _confirmCredentials.apply(this, arguments);
      }

      return confirmCredentials;
    }()
    /**
     * Check if an email address has been previously registered.
     * @param {string} email
     * @returns {{exists: boolean}}
     */

  }, {
    key: "checkIfEmailRegistered",
    value: function () {
      var _checkIfEmailRegistered = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(email) {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this.REQUIRES(Services$5.IDENTITY_SERVICE);
                return _context8.abrupt("return", this.identityService.checkIfEmailRegistered(email));

              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function checkIfEmailRegistered(_x13) {
        return _checkIfEmailRegistered.apply(this, arguments);
      }

      return checkIfEmailRegistered;
    }()
    /**
     * Get the current user's email address
     * @returns {{email: string | undefined | null}}
     */

  }, {
    key: "getUserEmail",
    value: function () {
      var _getUserEmail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this.REQUIRES(Services$5.IDENTITY_SERVICE);
                return _context9.abrupt("return", this.identityService.getUserEmail());

              case 2:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getUserEmail() {
        return _getUserEmail.apply(this, arguments);
      }

      return getUserEmail;
    }()
    /**
     * Associates a user with a twitter uuid.
     * @param {string} uuid from the Twitter API
     * @param {number} userId
     * @param {string} handle
     */

  }, {
    key: "associateTwitterUser",
    value: function () {
      var _associateTwitterUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(uuid, userId, handle) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this.REQUIRES(Services$5.IDENTITY_SERVICE);
                return _context10.abrupt("return", this.identityService.associateTwitterUser(uuid, userId, handle));

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function associateTwitterUser(_x14, _x15, _x16) {
        return _associateTwitterUser.apply(this, arguments);
      }

      return associateTwitterUser;
    }()
    /**
     * Associates a user with an instagram uuid.
     * @param {string} uuid from the Instagram API
     * @param {number} userId
     * @param {string} handle
     */

  }, {
    key: "associateInstagramUser",
    value: function () {
      var _associateInstagramUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(uuid, userId, handle) {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this.REQUIRES(Services$5.IDENTITY_SERVICE);
                return _context11.abrupt("return", this.identityService.associateInstagramUser(uuid, userId, handle));

              case 2:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function associateInstagramUser(_x17, _x18, _x19) {
        return _associateInstagramUser.apply(this, arguments);
      }

      return associateInstagramUser;
    }()
    /**
     * Checks if a requested handle is valid (unused).
     * @param {string} handle
     */

  }, {
    key: "handleIsValid",
    value: function () {
      var _handleIsValid = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(handle) {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                return _context12.abrupt("return", this.contracts.UserFactoryClient.handleIsValid(handle));

              case 1:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function handleIsValid(_x20) {
        return _handleIsValid.apply(this, arguments);
      }

      return handleIsValid;
    }()
    /**
     * Looks up a Twitter account by handle.
     * @returns {Object} twitter API response.
     */

  }, {
    key: "lookupTwitterHandle",
    value: function () {
      var _lookupTwitterHandle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(handle) {
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                this.REQUIRES(Services$5.IDENTITY_SERVICE);
                return _context13.abrupt("return", this.identityService.lookupTwitterHandle(handle));

              case 2:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function lookupTwitterHandle(_x21) {
        return _lookupTwitterHandle.apply(this, arguments);
      }

      return lookupTwitterHandle;
    }()
    /**
     * Updates a user's creator node endpoint. Sets the connected creator node in the libs instance
     * and updates the user's metadata blob.
     * @param {string} url
     */

  }, {
    key: "updateCreatorNodeEndpoint",
    value: function () {
      var _updateCreatorNodeEndpoint = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(url) {
        var user;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                this.REQUIRES(Services$5.CREATOR_NODE);
                user = this.userStateManager.getCurrentUser();

                if (!user.is_creator) {
                  _context14.next = 8;
                  break;
                }

                _context14.next = 5;
                return this.creatorNode.setEndpoint(url);

              case 5:
                // Only a creator will have a creator node endpoint
                user.creator_node_endpoint = url;
                _context14.next = 8;
                return this.User.updateCreator(user.user_id, user);

              case 8:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function updateCreatorNodeEndpoint(_x22) {
        return _updateCreatorNodeEndpoint.apply(this, arguments);
      }

      return updateCreatorNodeEndpoint;
    }()
    /**
     * Perform a full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have all same data as returned from standalone endpoints
     * @param {string} text search query
     * @param {string} kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param {number} limit max # of items to return per list (for pagination)
     * @param {number} offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchFull",
    value: function () {
      var _searchFull = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(text, kind) {
        var limit,
            offset,
            _args15 = arguments;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                limit = _args15.length > 2 && _args15[2] !== undefined ? _args15[2] : 100;
                offset = _args15.length > 3 && _args15[3] !== undefined ? _args15[3] : 0;
                this.REQUIRES(Services$5.DISCOVERY_PROVIDER);
                return _context15.abrupt("return", this.discoveryProvider.searchFull(text, kind, limit, offset));

              case 4:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function searchFull(_x23, _x24) {
        return _searchFull.apply(this, arguments);
      }

      return searchFull;
    }()
    /**
     * Perform a lighter-weight full-text search. Returns tracks, users, playlists, albums
     *    with optional user-specific results for each
     *  - user, track, and playlist objects have core data, and track & playlist objects
     *    also return user object
     * @param {string} text search query
     * @param {number} limit max # of items to return per list (for pagination)
     * @param {number} offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchAutocomplete",
    value: function () {
      var _searchAutocomplete = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(text) {
        var limit,
            offset,
            _args16 = arguments;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                limit = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : 100;
                offset = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : 0;
                this.REQUIRES(Services$5.DISCOVERY_PROVIDER);
                return _context16.abrupt("return", this.discoveryProvider.searchAutocomplete(text, limit, offset));

              case 4:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function searchAutocomplete(_x25) {
        return _searchAutocomplete.apply(this, arguments);
      }

      return searchAutocomplete;
    }()
    /**
     * Perform a tags-only search. Returns tracks with required tag and users
     * that have used a tag greater than a specified number of times
     * @param {string} text search query
     * @param {number} user_tag_count min # of times a user must have used a tag to be returned
     * @param {string} kind 'tracks', 'users', 'playlists', 'albums', 'all'
     * @param {number} limit max # of items to return per list (for pagination)
     * @param {number} offset offset into list to return from (for pagination)
     */

  }, {
    key: "searchTags",
    value: function () {
      var _searchTags = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(text) {
        var user_tag_count,
            kind,
            limit,
            offset,
            _args17 = arguments;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                user_tag_count = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : 2;
                kind = _args17.length > 2 ? _args17[2] : undefined;
                limit = _args17.length > 3 && _args17[3] !== undefined ? _args17[3] : 100;
                offset = _args17.length > 4 && _args17[4] !== undefined ? _args17[4] : 0;
                this.REQUIRES(Services$5.DISCOVERY_PROVIDER);
                return _context17.abrupt("return", this.discoveryProvider.searchTags(text, user_tag_count, kind, limit, offset));

              case 6:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function searchTags(_x26) {
        return _searchTags.apply(this, arguments);
      }

      return searchTags;
    }()
    /**
     * Check if the user has a distribution claim
     * @param {number?} index The index of the claim to check (if known)
     */

  }, {
    key: "getHasClaimed",
    value: function () {
      var _getHasClaimed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(index) {
        var userWallet, web3, wallet, claim;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                this.REQUIRES(Services$5.COMSTOCK);

                if (!index) {
                  _context18.next = 3;
                  break;
                }

                return _context18.abrupt("return", this.ethContracts.ClaimDistributionClient.isClaimed(index));

              case 3:
                userWallet = this.web3Manager.getWalletAddress();
                web3 = this.web3Manager.getWeb3();
                wallet = web3.utils.toChecksumAddress(userWallet);
                _context18.next = 8;
                return this.comstock.getComstock({
                  wallet: wallet
                });

              case 8:
                claim = _context18.sent;
                return _context18.abrupt("return", this.ethContracts.ClaimDistributionClient.isClaimed(claim.index));

              case 10:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getHasClaimed(_x27) {
        return _getHasClaimed.apply(this, arguments);
      }

      return getHasClaimed;
    }()
    /**
     * Get the distribution claim amount
     */

  }, {
    key: "getClaimDistributionAmount",
    value: function () {
      var _getClaimDistributionAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
        var userWallet, web3, wallet, claimDistribution, amount;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                this.REQUIRES(Services$5.COMSTOCK);
                userWallet = this.web3Manager.getWalletAddress();
                web3 = this.web3Manager.getWeb3();
                wallet = web3.utils.toChecksumAddress(userWallet);
                _context19.next = 6;
                return this.comstock.getComstock({
                  wallet: wallet
                });

              case 6:
                claimDistribution = _context19.sent;
                amount = Utils$4.toBN(claimDistribution.amount.replace('0x', ''), 16);
                return _context19.abrupt("return", amount);

              case 9:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getClaimDistributionAmount() {
        return _getClaimDistributionAmount.apply(this, arguments);
      }

      return getClaimDistributionAmount;
    }()
    /**
     * Make the claim
     * @param {number?} index The index of the claim to check
     * @param {BN?} amount The amount to be claimed
     * @param {Array<string>?} merkleProof The merkle proof for the claim
     */

  }, {
    key: "makeDistributionClaim",
    value: function () {
      var _makeDistributionClaim = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(index, amount, merkleProof) {
        var userWallet, web3, wallet, claim;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                this.REQUIRES(Services$5.COMSTOCK, Services$5.IDENTITY_SERVICE);
                userWallet = this.web3Manager.getWalletAddress();
                web3 = this.web3Manager.getWeb3();
                wallet = web3.utils.toChecksumAddress(userWallet);

                if (!(index && amount && merkleProof)) {
                  _context20.next = 6;
                  break;
                }

                return _context20.abrupt("return", this.ethContracts.ClaimDistributionClient.claim(index, userWallet, amount, merkleProof));

              case 6:
                _context20.next = 8;
                return this.comstock.getComstock({
                  wallet: wallet
                });

              case 8:
                claim = _context20.sent;
                return _context20.abrupt("return", this.ethContracts.ClaimDistributionClient.claim(claim.index, userWallet, claim.amount, claim.proof));

              case 10:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function makeDistributionClaim(_x28, _x29, _x30) {
        return _makeDistributionClaim.apply(this, arguments);
      }

      return makeDistributionClaim;
    }()
    /**
     * Sends `amount` tokens to `recipientAddress`
     */

  }, {
    key: "permitAndSendTokens",
    value: function () {
      var _permitAndSendTokens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(recipientAddress, amount) {
        var myWalletAddress, _yield$this$identityS, selectedEthWallet;

        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                this.REQUIRES(Services$5.IDENTITY_SERVICE);
                myWalletAddress = this.web3Manager.getWalletAddress();
                _context21.next = 4;
                return this.identityService.getEthRelayer(myWalletAddress);

              case 4:
                _yield$this$identityS = _context21.sent;
                selectedEthWallet = _yield$this$identityS.selectedEthWallet;
                _context21.next = 8;
                return this.permitProxySendTokens(myWalletAddress, selectedEthWallet, amount);

              case 8:
                _context21.next = 10;
                return this.sendTokens(myWalletAddress, recipientAddress, selectedEthWallet, amount);

              case 10:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function permitAndSendTokens(_x31, _x32) {
        return _permitAndSendTokens.apply(this, arguments);
      }

      return permitAndSendTokens;
    }()
    /**
     * Sends Eth `amount` tokens to `solanaAccount` by way of the wormhole
     * 1.) Permits the eth relay to proxy send tokens on behalf of the user
     * 2.) Transfers the tokens on the eth side to the wormhole contract
     * 3.) Gathers attestations from wormhole oracles and relizes the tokens on sol
     */

  }, {
    key: "sendTokensFromEthToSol",
    value: function () {
      var _sendTokensFromEthToSol = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(amount, solanaAccount) {
        var phases, phase, logs, myWalletAddress, wormholeAddress, _yield$this$identityS2, selectedEthWallet, transferTokensTx, transferTransactionHash, response;

        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                this.REQUIRES(Services$5.IDENTITY_SERVICE);
                phases = {
                  PERMIT_PROXY_SEND: 'PERMIT_PROXY_SEND',
                  TRANSFER_TOKENS: 'TRANSFER_TOKENS',
                  ATTEST_AND_COMPLETE_TRANSFER: 'ATTEST_AND_COMPLETE_TRANSFER'
                };
                phase = phases.PERMIT_PROXY_SEND;
                logs = ["Send tokens from eth to sol to ".concat(solanaAccount, " for ").concat(amount.toString())];
                _context22.prev = 4;
                myWalletAddress = this.web3Manager.getWalletAddress();
                wormholeAddress = this.ethContracts.WormholeClient.contractAddress;
                _context22.next = 9;
                return this.identityService.getEthRelayer(myWalletAddress);

              case 9:
                _yield$this$identityS2 = _context22.sent;
                selectedEthWallet = _yield$this$identityS2.selectedEthWallet;
                _context22.next = 13;
                return this.permitProxySendTokens(myWalletAddress, wormholeAddress, amount);

              case 13:
                logs.push('Completed permit proxy send tokens');
                phase = phases.TRANSFER_TOKENS;
                _context22.next = 17;
                return this.wormholeClient.transferTokensToEthWormhole(myWalletAddress, amount, solanaAccount, selectedEthWallet);

              case 17:
                transferTokensTx = _context22.sent;
                transferTransactionHash = transferTokensTx.txHash;
                logs.push("Completed transfer tokens with tx ".concat(transferTransactionHash));
                phase = phases.ATTEST_AND_COMPLETE_TRANSFER;
                _context22.next = 23;
                return this.wormholeClient.attestAndCompleteTransferEthToSol(transferTransactionHash);

              case 23:
                response = _context22.sent;

                if (response.transactionSignature) {
                  logs.push("Receive sol wrapped tokens in tx ".concat(response.transactionSignature));
                }

                return _context22.abrupt("return", {
                  txSignature: response.transactionSignature,
                  phase: response.phase,
                  error: response.error || null,
                  logs: logs.concat(response.logs)
                });

              case 28:
                _context22.prev = 28;
                _context22.t0 = _context22["catch"](4);
                return _context22.abrupt("return", {
                  error: _context22.t0.message,
                  phase: phase,
                  logs: logs
                });

              case 31:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this, [[4, 28]]);
      }));

      function sendTokensFromEthToSol(_x33, _x34) {
        return _sendTokensFromEthToSol.apply(this, arguments);
      }

      return sendTokensFromEthToSol;
    }()
    /**
     * Sends Eth `amount` tokens to `solanaAccount` on the identity service
     * by way of the wormhole.
     */

  }, {
    key: "proxySendTokensFromEthToSol",
    value: function () {
      var _proxySendTokensFromEthToSol = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(amount, solanaAccount) {
        var myWalletAddress, wormholeAddress, _yield$this$identityS3, selectedEthWallet, permitMethod, permit, transferTokensMethod, transferTokens;

        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                this.REQUIRES(Services$5.IDENTITY_SERVICE);
                myWalletAddress = this.web3Manager.getWalletAddress();
                wormholeAddress = this.ethContracts.WormholeClient.contractAddress;
                _context23.next = 5;
                return this.identityService.getEthRelayer(myWalletAddress);

              case 5:
                _yield$this$identityS3 = _context23.sent;
                selectedEthWallet = _yield$this$identityS3.selectedEthWallet;
                _context23.next = 9;
                return this.getPermitProxySendTokensMethod(myWalletAddress, wormholeAddress, amount);

              case 9:
                permitMethod = _context23.sent;
                _context23.next = 12;
                return this.ethWeb3Manager.getRelayMethodParams(this.ethContracts.AudiusTokenClient.contractAddress, permitMethod, selectedEthWallet);

              case 12:
                permit = _context23.sent;
                _context23.next = 15;
                return this.wormholeClient.getTransferTokensToEthWormholeMethod(myWalletAddress, amount, solanaAccount, selectedEthWallet);

              case 15:
                transferTokensMethod = _context23.sent;
                _context23.next = 18;
                return this.ethWeb3Manager.getRelayMethodParams(this.ethContracts.WormholeClient.contractAddress, transferTokensMethod, selectedEthWallet);

              case 18:
                transferTokens = _context23.sent;
                return _context23.abrupt("return", this.identityService.wormholeRelay({
                  senderAddress: myWalletAddress,
                  permit: permit,
                  transferTokens: transferTokens
                }));

              case 20:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function proxySendTokensFromEthToSol(_x35, _x36) {
        return _proxySendTokensFromEthToSol.apply(this, arguments);
      }

      return proxySendTokensFromEthToSol;
    }()
    /**
     * Sends `amount` tokens to `ethAccount` by way of the wormhole
     * 1.) Creates a solana root wallet
     * 2.) Sends the tokens from the user bank account to the solana wallet
     * 3.) Permits the solana wallet to approve transfer to wormhole
     * 4.) Transfers to the wrapped audio to the sol wormhole contract
     * 5.) Gathers attestations from wormhole oracles and realizes the tokens on eth
     */

  }, {
    key: "sendTokensFromSolToEth",
    value: function () {
      var _sendTokensFromSolToEth = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(amount, ethAccount) {
        var _yield$this$wormholeC, error, logs, phase;

        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.wormholeClient.sendTokensFromSolToEthViaWormhole(amount, ethAccount);

              case 2:
                _yield$this$wormholeC = _context24.sent;
                error = _yield$this$wormholeC.error;
                logs = _yield$this$wormholeC.logs;
                phase = _yield$this$wormholeC.phase;
                return _context24.abrupt("return", {
                  error: error,
                  logs: logs,
                  phase: phase
                });

              case 7:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function sendTokensFromSolToEth(_x37, _x38) {
        return _sendTokensFromSolToEth.apply(this, arguments);
      }

      return sendTokensFromSolToEth;
    }()
  }, {
    key: "_getPermitProxySendTokensParams",
    value: function () {
      var _getPermitProxySendTokensParams2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(owner, relayerAddress, amount) {
        var web3, myPrivateKey, chainId, name, tokenAddress, nonce, currentBlockNumber, currentBlock, deadline, digest, result;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                web3 = this.ethWeb3Manager.getWeb3();
                myPrivateKey = this.web3Manager.getOwnerWalletPrivateKey();
                _context25.next = 4;
                return new Promise(function (resolve) {
                  return web3.eth.getChainId(function (_, chainId) {
                    return resolve(chainId);
                  });
                });

              case 4:
                chainId = _context25.sent;
                _context25.next = 7;
                return this.ethContracts.AudiusTokenClient.name();

              case 7:
                name = _context25.sent;
                tokenAddress = this.ethContracts.AudiusTokenClient.contractAddress; // Submit permit request to give address approval, via relayer

                _context25.next = 11;
                return this.ethContracts.AudiusTokenClient.nonces(owner);

              case 11:
                nonce = _context25.sent;
                _context25.next = 14;
                return web3.eth.getBlockNumber();

              case 14:
                currentBlockNumber = _context25.sent;
                _context25.next = 17;
                return web3.eth.getBlock(currentBlockNumber);

              case 17:
                currentBlock = _context25.sent;
                // 1 hour, sufficiently far in future
                deadline = currentBlock.timestamp + 60 * 60 * 1;
                digest = getPermitDigest(web3, name, tokenAddress, chainId, {
                  owner: owner,
                  spender: relayerAddress,
                  value: amount
                }, nonce, deadline);
                result = sign(digest, myPrivateKey);
                return _context25.abrupt("return", {
                  result: result,
                  deadline: deadline
                });

              case 22:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function _getPermitProxySendTokensParams(_x39, _x40, _x41) {
        return _getPermitProxySendTokensParams2.apply(this, arguments);
      }

      return _getPermitProxySendTokensParams;
    }()
    /**
     * Permits `relayerAddress` to send `amount` on behalf of the current user, `owner`
     */

  }, {
    key: "permitProxySendTokens",
    value: function () {
      var _permitProxySendTokens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(owner, relayerAddress, amount) {
        var _yield$this$_getPermi, result, deadline, tx;

        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this._getPermitProxySendTokensParams(owner, relayerAddress, amount);

              case 2:
                _yield$this$_getPermi = _context26.sent;
                result = _yield$this$_getPermi.result;
                deadline = _yield$this$_getPermi.deadline;
                _context26.next = 7;
                return this.ethContracts.AudiusTokenClient.permit(owner, relayerAddress, amount, deadline, result.v, result.r, result.s);

              case 7:
                tx = _context26.sent;
                return _context26.abrupt("return", tx);

              case 9:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function permitProxySendTokens(_x42, _x43, _x44) {
        return _permitProxySendTokens.apply(this, arguments);
      }

      return permitProxySendTokens;
    }()
    /**
     * Gets the permit method to proxy send tokens `relayerAddress` to send `amount` on behalf of the current user, `owner`
     */

  }, {
    key: "getPermitProxySendTokensMethod",
    value: function () {
      var _getPermitProxySendTokensMethod = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(owner, relayerAddress, amount) {
        var _yield$this$_getPermi2, result, deadline, contractMethod;

        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return this._getPermitProxySendTokensParams(owner, relayerAddress, amount);

              case 2:
                _yield$this$_getPermi2 = _context27.sent;
                result = _yield$this$_getPermi2.result;
                deadline = _yield$this$_getPermi2.deadline;
                contractMethod = this.ethContracts.AudiusTokenClient.AudiusTokenContract.methods.permit(owner, relayerAddress, amount, deadline, result.v, result.r, result.s);
                return _context27.abrupt("return", contractMethod);

              case 7:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getPermitProxySendTokensMethod(_x45, _x46, _x47) {
        return _getPermitProxySendTokensMethod.apply(this, arguments);
      }

      return getPermitProxySendTokensMethod;
    }()
    /**
     * Sends `amount` tokens to `address` from `owner`
     */

  }, {
    key: "sendTokens",
    value: function () {
      var _sendTokens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(owner, address, relayer, amount) {
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                this.REQUIRES(Services$5.IDENTITY_SERVICE);
                return _context28.abrupt("return", this.ethContracts.AudiusTokenClient.transferFrom(owner, address, relayer, amount));

              case 2:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function sendTokens(_x48, _x49, _x50, _x51) {
        return _sendTokens.apply(this, arguments);
      }

      return sendTokens;
    }()
    /**
     * Updates the minimum delegation amount for a user in identity
     * NOTE: Requests eth account signature
     */

  }, {
    key: "updateMinimumDelegationAmount",
    value: function () {
      var _updateMinimumDelegationAmount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(amount) {
        var _this$identityService;

        var unixTs, message, signature, wallet;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                this.REQUIRES(Services$5.IDENTITY_SERVICE);
                unixTs = Math.round(new Date().getTime() / 1000); // current unix timestamp (sec)

                message = "Click sign to authenticate with identity service: ".concat(unixTs);
                _context29.next = 5;
                return this.ethWeb3Manager.sign(message);

              case 5:
                signature = _context29.sent;
                wallet = this.ethWeb3Manager.getWalletAddress();
                return _context29.abrupt("return", this.identityService.updateMinimumDelegationAmount(wallet, amount, (_this$identityService = {}, _defineProperty(_this$identityService, AuthHeaders.MESSAGE, message), _defineProperty(_this$identityService, AuthHeaders.SIGNATURE, signature), _this$identityService)));

              case 8:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function updateMinimumDelegationAmount(_x52) {
        return _updateMinimumDelegationAmount.apply(this, arguments);
      }

      return updateMinimumDelegationAmount;
    }()
    /**
     * Get current user account PDA from SOL given an ID and ETH wallet address
     * @returns {object} with keys ethAddress, authority, replicaSet or
     * null when account not found
     */

  }, {
    key: "getUserAccountOnSolana",
    value: function () {
      var _getUserAccountOnSolana = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30() {
        var _ref3,
            userId,
            wallet,
            user,
            userIdSeed,
            _yield$this$solanaWeb,
            userAccountPDA,
            account,
            _args30 = arguments;

        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _ref3 = _args30.length > 0 && _args30[0] !== undefined ? _args30[0] : {
                  userId: null,
                  wallet: null
                }, userId = _ref3.userId, wallet = _ref3.wallet;
                this.REQUIRES(Services$5.SOLANA_WEB3_MANAGER); // If wallet or userId are not passed in, use the user loaded in libs

                if (!wallet || !userId) {
                  user = this.getCurrentUser();
                  wallet = user.wallet;
                  userId = user.userId;
                }

                if (!(userId instanceof BN$1)) {
                  userId = new BN$1(userId);
                } // matches format for PDA derivation seed in SOL program
                // use BN.toArrayLike instead of .toBuffer for browser compat reasons


                userIdSeed = userId.toArrayLike(Buffer, 'le', 4);
                _context30.next = 7;
                return this.solanaWeb3Manager.findDerivedPair(this.solanaWeb3Manager.audiusDataProgramId, this.solanaWeb3Manager.audiusDataAdminStorageKeypairPublicKey, userIdSeed);

              case 7:
                _yield$this$solanaWeb = _context30.sent;
                userAccountPDA = _yield$this$solanaWeb.derivedAddress;
                _context30.next = 11;
                return this.solanaWeb3Manager.fetchAccount(userAccountPDA);

              case 11:
                account = _context30.sent;
                return _context30.abrupt("return", account);

              case 13:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getUserAccountOnSolana() {
        return _getUserAccountOnSolana.apply(this, arguments);
      }

      return getUserAccountOnSolana;
    }()
    /**
     * Checks that the current user has claimed account PDA on SOL
     * @returns {boolean} userHasClaimedAccount
     */

  }, {
    key: "userHasClaimedSolAccount",
    value: function () {
      var _userHasClaimedSolAccount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31() {
        var _ref4,
            _ref4$account,
            account,
            _ref4$wallet,
            wallet,
            _ref4$userId,
            userId,
            userHasClaimedAccount,
            _args31 = arguments;

        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                _ref4 = _args31.length > 0 && _args31[0] !== undefined ? _args31[0] : {
                  account: null,
                  wallet: null,
                  userId: null
                }, _ref4$account = _ref4.account, account = _ref4$account === void 0 ? null : _ref4$account, _ref4$wallet = _ref4.wallet, wallet = _ref4$wallet === void 0 ? null : _ref4$wallet, _ref4$userId = _ref4.userId, userId = _ref4$userId === void 0 ? null : _ref4$userId;

                if (!(!account && !wallet && !userId)) {
                  _context31.next = 3;
                  break;
                }

                throw new Error('Must supply EITHER an `account` OR `wallet` and `userId` to look up whether userHasClaimedSolAccount');

              case 3:
                if (!(!account && wallet && userId)) {
                  _context31.next = 7;
                  break;
                }

                _context31.next = 6;
                return this.getUserAccountOnSolana({
                  wallet: wallet,
                  userId: userId
                });

              case 6:
                account = _context31.sent;

              case 7:
                userHasClaimedAccount = PublicKey["default"].toString() !== account.authority.toString();
                return _context31.abrupt("return", userHasClaimedAccount);

              case 9:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function userHasClaimedSolAccount() {
        return _userHasClaimedSolAccount.apply(this, arguments);
      }

      return userHasClaimedSolAccount;
    }()
  }]);

  return Account;
}(Base$6);

var account = Account;

var user = createModule("/$$rollup_base$$/src/api");

var pick = require$$0__default$3["default"].pick,
    isEqual = require$$0__default$3["default"].isEqual;
var Base$5 = base.Base,
    Services$4 = base.Services;
var Utils$3 = require$$18.Utils;
var CreatorNode$1 = require$$10.CreatorNode,
    getSpIDForEndpoint = require$$10.getSpIDForEndpoint,
    setSpIDForEndpoint = require$$10.setSpIDForEndpoint; // User metadata fields that are required on the metadata object and can have
// null or non-null values

var USER_PROPS = ['is_creator', 'is_verified', 'is_deactivated', 'name', 'handle', 'profile_picture', 'profile_picture_sizes', 'cover_photo', 'cover_photo_sizes', 'bio', 'location', 'creator_node_endpoint', 'associated_wallets', 'associated_sol_wallets', 'collectibles', 'playlist_library', 'events']; // User metadata fields that are required on the metadata object and only can have
// non-null values

var USER_REQUIRED_PROPS = ['name', 'handle']; // Constants for user metadata fields

var USER_PROP_NAME_CONSTANTS = Object.freeze({
  NAME: 'name',
  IS_CREATOR: 'is_creator',
  BIO: 'bio',
  LOCATION: 'location',
  PROFILE_PICTURE_SIZES: 'profile_picture_sizes',
  COVER_PHOTO_SIZES: 'cover_photo_sizes',
  CREATOR_NODE_ENDPOINT: 'creator_node_endpoint'
});

var Users = /*#__PURE__*/function (_Base) {
  _inherits(Users, _Base);

  var _super = _createSuper(Users);

  function Users(serviceProvider, preferHigherPatchForPrimary, preferHigherPatchForSecondaries) {
    var _this;

    _classCallCheck(this, Users);

    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.ServiceProvider = serviceProvider;
    _this.preferHigherPatchForPrimary = preferHigherPatchForPrimary;
    _this.preferHigherPatchForSecondaries = preferHigherPatchForSecondaries;
    _this.getUsers = _this.getUsers.bind(_assertThisInitialized(_this));
    _this.getMutualFollowers = _this.getMutualFollowers.bind(_assertThisInitialized(_this));
    _this.getFollowersForUser = _this.getFollowersForUser.bind(_assertThisInitialized(_this));
    _this.getFolloweesForUser = _this.getFolloweesForUser.bind(_assertThisInitialized(_this));
    _this.getUserRepostFeed = _this.getUserRepostFeed.bind(_assertThisInitialized(_this));
    _this.getSocialFeed = _this.getSocialFeed.bind(_assertThisInitialized(_this));
    _this.getTopCreatorsByGenres = _this.getTopCreatorsByGenres.bind(_assertThisInitialized(_this));
    _this.uploadProfileImages = _this.uploadProfileImages.bind(_assertThisInitialized(_this));
    _this.addUser = _this.addUser.bind(_assertThisInitialized(_this));
    _this.updateUser = _this.updateUser.bind(_assertThisInitialized(_this));
    _this.updateCreator = _this.updateCreator.bind(_assertThisInitialized(_this));
    _this.upgradeToCreator = _this.upgradeToCreator.bind(_assertThisInitialized(_this));
    _this.updateIsVerified = _this.updateIsVerified.bind(_assertThisInitialized(_this));
    _this.addUserFollow = _this.addUserFollow.bind(_assertThisInitialized(_this));
    _this.deleteUserFollow = _this.deleteUserFollow.bind(_assertThisInitialized(_this)); // For adding replica set to users on sign up

    _this.assignReplicaSet = _this.assignReplicaSet.bind(_assertThisInitialized(_this));
    _this.getClockValuesFromReplicaSet = _this.getClockValuesFromReplicaSet.bind(_assertThisInitialized(_this));
    _this._waitForCreatorNodeEndpointIndexing = _this._waitForCreatorNodeEndpointIndexing.bind(_assertThisInitialized(_this));
    _this._addUserOperations = _this._addUserOperations.bind(_assertThisInitialized(_this));
    _this._updateUserOperations = _this._updateUserOperations.bind(_assertThisInitialized(_this));
    _this._validateUserMetadata = _this._validateUserMetadata.bind(_assertThisInitialized(_this));
    _this.cleanUserMetadata = _this.cleanUserMetadata.bind(_assertThisInitialized(_this)); // For adding a creator_node_endpoint for a user if null

    _this.assignReplicaSetIfNecessary = _this.assignReplicaSetIfNecessary.bind(_assertThisInitialized(_this));
    return _this;
  }
  /* ----------- GETTERS ---------- */

  /**
   * get users with all relevant user data
   * can be filtered by providing an integer array of ids
   * @param {number} limit
   * @param {number} offset
   * @param {Object} idsArray
   * @param {String} walletAddress
   * @param {String} handle
   * @param {Boolean} isCreator null returns all users, true returns creators only, false returns users only
   * @param {number} currentUserId the currently logged in user
   * @returns {Object} {Array of User metadata Objects}
   * additional metadata fields on user objects:
   *  {Integer} track_count - track count for given user
   *  {Integer} playlist_count - playlist count for given user
   *  {Integer} album_count - album count for given user
   *  {Integer} follower_count - follower count for given user
   *  {Integer} followee_count - followee count for given user
   *  {Integer} repost_count - repost count for given user
   *  {Integer} track_blocknumber - blocknumber of latest track for user
   *  {Boolean} does_current_user_follow - does current user follow given user
   *  {Array} followee_follows - followees of current user that follow given user
   * @example
   * await getUsers()
   * await getUsers(100, 0, [3,2,6]) - Invalid user ids will not be accepted
   */


  _createClass(Users, [{
    key: "getUsers",
    value: function () {
      var _getUsers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var limit,
            offset,
            idsArray,
            walletAddress,
            handle,
            isCreator,
            minBlockNumber,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                limit = _args.length > 0 && _args[0] !== undefined ? _args[0] : 100;
                offset = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;
                idsArray = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
                walletAddress = _args.length > 3 && _args[3] !== undefined ? _args[3] : null;
                handle = _args.length > 4 && _args[4] !== undefined ? _args[4] : null;
                isCreator = _args.length > 5 && _args[5] !== undefined ? _args[5] : null;
                minBlockNumber = _args.length > 6 && _args[6] !== undefined ? _args[6] : null;
                this.REQUIRES(Services$4.DISCOVERY_PROVIDER);
                return _context.abrupt("return", this.discoveryProvider.getUsers(limit, offset, idsArray, walletAddress, handle, isCreator, minBlockNumber));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getUsers() {
        return _getUsers.apply(this, arguments);
      }

      return getUsers;
    }()
    /**
     * get intersection of users that follow followeeUserId and users that are followed by followerUserId
     * @param {number} followeeUserId user that is followed
     * @example
     * getMutualFollowers(100, 0, 1, 1) - IDs must be valid
     */

  }, {
    key: "getMutualFollowers",
    value: function () {
      var _getMutualFollowers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var limit,
            offset,
            followeeUserId,
            followerUserId,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                limit = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 100;
                offset = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;
                followeeUserId = _args2.length > 2 ? _args2[2] : undefined;
                this.REQUIRES(Services$4.DISCOVERY_PROVIDER);
                followerUserId = this.userStateManager.getCurrentUserId();

                if (!followerUserId) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return", this.discoveryProvider.getFollowIntersectionUsers(limit, offset, followeeUserId, followerUserId));

              case 7:
                return _context2.abrupt("return", []);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getMutualFollowers() {
        return _getMutualFollowers.apply(this, arguments);
      }

      return getMutualFollowers;
    }()
    /**
     * get users that follow followeeUserId, sorted by follower count descending
     * @param {number} currentUserId the currently logged in user
     * @param {number} followeeUserId user that is followed
     * @return {Array} array of user objects with standard user metadata
     */

  }, {
    key: "getFollowersForUser",
    value: function () {
      var _getFollowersForUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var limit,
            offset,
            followeeUserId,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                limit = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 100;
                offset = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;
                followeeUserId = _args3.length > 2 ? _args3[2] : undefined;
                this.REQUIRES(Services$4.DISCOVERY_PROVIDER);
                return _context3.abrupt("return", this.discoveryProvider.getFollowersForUser(limit, offset, followeeUserId));

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getFollowersForUser() {
        return _getFollowersForUser.apply(this, arguments);
      }

      return getFollowersForUser;
    }()
    /**
     * get users that are followed by followerUserId, sorted by follower count descending
     * @param {number} currentUserId the currently logged in user
     * @param {number} followerUserId user - i am the one who follows
     * @return {Array} array of user objects with standard user metadata
     */

  }, {
    key: "getFolloweesForUser",
    value: function () {
      var _getFolloweesForUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var limit,
            offset,
            followerUserId,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                limit = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : 100;
                offset = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 0;
                followerUserId = _args4.length > 2 ? _args4[2] : undefined;
                this.REQUIRES(Services$4.DISCOVERY_PROVIDER);
                return _context4.abrupt("return", this.discoveryProvider.getFolloweesForUser(limit, offset, followerUserId));

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getFolloweesForUser() {
        return _getFolloweesForUser.apply(this, arguments);
      }

      return getFolloweesForUser;
    }()
    /**
     * Return repost feed for requested user
     * @param {number} userId - requested user id
     * @param {filter} string - filter by "all", "original", or "repost"
     * @param {number} limit - max # of items to return (for pagination)
     * @param {number} offset - offset into list to return from (for pagination)
     * @returns {Object} {Array of track and playlist metadata objects}
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */

  }, {
    key: "getUserRepostFeed",
    value: function () {
      var _getUserRepostFeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(userId, filter) {
        var limit,
            offset,
            withUsers,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                limit = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : 100;
                offset = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : 0;
                withUsers = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : false;
                this.REQUIRES(Services$4.DISCOVERY_PROVIDER);
                return _context5.abrupt("return", this.discoveryProvider.getUserRepostFeed(userId, filter, limit, offset, withUsers));

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getUserRepostFeed(_x, _x2) {
        return _getUserRepostFeed.apply(this, arguments);
      }

      return getUserRepostFeed;
    }()
    /**
     * Return social feed for current user
     * @param {number} limit - max # of items to return
     * @param {filter} string - filter by "all", "original", or "repost"
     * @param {number} offset - offset into list to return from (for pagination)
     * @returns {Object} {Array of track and playlist metadata objects}
     * additional metadata fields on track and playlist objects:
     *  {String} activity_timestamp - timestamp of requested user's repost for given track or playlist,
     *    used for sorting feed
     *  {Integer} repost_count - repost count of given track/playlist
     *  {Integer} save_count - save count of given track/playlist
     *  {Boolean} has_current_user_reposted - has current user reposted given track/playlist
     *  {Array} followee_reposts - followees of current user that have reposted given track/playlist
     */

  }, {
    key: "getSocialFeed",
    value: function () {
      var _getSocialFeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(filter) {
        var limit,
            offset,
            withUsers,
            tracksOnly,
            owner,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                limit = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 100;
                offset = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : 0;
                withUsers = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : false;
                tracksOnly = _args6.length > 4 && _args6[4] !== undefined ? _args6[4] : false;
                this.REQUIRES(Services$4.DISCOVERY_PROVIDER);
                owner = this.userStateManager.getCurrentUser();

                if (!owner) {
                  _context6.next = 8;
                  break;
                }

                return _context6.abrupt("return", this.discoveryProvider.getSocialFeed(filter, limit, offset, withUsers, tracksOnly));

              case 8:
                return _context6.abrupt("return", []);

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getSocialFeed(_x3) {
        return _getSocialFeed.apply(this, arguments);
      }

      return getSocialFeed;
    }()
    /**
     * Returns the top users for the specified genres
     * @param {number} limit - max # of items to return
     * @param {number} offset - offset into list to return from (for pagination)
     * @param {Object} {Array of genres} - filter by genres ie. "Rock", "Alternative"
     * @param {Boolean} with_users - If the userIds should be returned or the full user metadata
     * @returns {Object} {Array of user objects if with_users set, else array of userIds}
     */

  }, {
    key: "getTopCreatorsByGenres",
    value: function () {
      var _getTopCreatorsByGenres = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(genres) {
        var limit,
            offset,
            withUsers,
            _args7 = arguments;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                limit = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : 30;
                offset = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : 0;
                withUsers = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : false;
                this.REQUIRES(Services$4.DISCOVERY_PROVIDER);
                return _context7.abrupt("return", this.discoveryProvider.getTopCreatorsByGenres(genres, limit, offset, withUsers));

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getTopCreatorsByGenres(_x4) {
        return _getTopCreatorsByGenres.apply(this, arguments);
      }

      return getTopCreatorsByGenres;
    }()
    /* ------- SETTERS ------- */

    /**
     * Assigns a replica set to the user's metadata and adds new metadata to chain.
     * This creates a record for that user on the connected creator node.
     * @param {Object} param
     * @param {number} param.userId
     */

  }, {
    key: "assignReplicaSet",
    value: function () {
      var _assignReplicaSet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref) {
        var userId, phases, phase, logPrefix, fnStartMs, startMs, user, newMetadata, response, primary, secondaries, newContentNodeEndpoints, errorMsg;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                userId = _ref.userId;
                this.REQUIRES(Services$4.CREATOR_NODE);
                phases = {
                  CLEAN_AND_VALIDATE_METADATA: 'CLEAN_AND_VALIDATE_METADATA',
                  AUTOSELECT_CONTENT_NODES: 'AUTOSELECT_CONTENT_NODES',
                  SYNC_ACROSS_CONTENT_NODES: 'SYNC_ACROSS_CONTENT_NODES',
                  SET_PRIMARY: 'SET_PRIMARY',
                  UPLOAD_METADATA_AND_UPDATE_ON_CHAIN: 'UPLOAD_METADATA_AND_UPDATE_ON_CHAIN'
                };
                phase = '';
                logPrefix = "[User:assignReplicaSet()] [userId: ".concat(userId, "]");
                fnStartMs = Date.now();
                startMs = fnStartMs;
                user = this.userStateManager.getCurrentUser(); // Failed the addUser() step

                if (user) {
                  _context8.next = 10;
                  break;
                }

                throw new Error('No current user');

              case 10:
                if (!(user.creator_node_endpoint && user.creator_node_endpoint.length > 0)) {
                  _context8.next = 12;
                  break;
                }

                return _context8.abrupt("return");

              case 12:
                // The new metadata object that will contain the replica set
                newMetadata = _objectSpread2({}, user);
                _context8.prev = 13;
                // Create starter metadata and validate
                phase = phases.CLEAN_AND_VALIDATE_METADATA; // Autoselect a new replica set and update the metadata object with new content node endpoints

                phase = phases.AUTOSELECT_CONTENT_NODES;
                _context8.next = 18;
                return this.ServiceProvider.autoSelectCreatorNodes({
                  performSyncCheck: false,
                  preferHigherPatchForPrimary: this.preferHigherPatchForPrimary,
                  preferHigherPatchForSecondaries: this.preferHigherPatchForSecondaries
                });

              case 18:
                response = _context8.sent;
                console.log("".concat(logPrefix, " [phase: ").concat(phase, "] ServiceProvider.autoSelectCreatorNodes() completed in ").concat(Date.now() - startMs, "ms"));
                startMs = Date.now(); // Ideally, 1 primary and n-1 secondaries are chosen. The best-worst case scenario is that at least 1 primary
                // is chosen. If a primary was not selected (which also implies that secondaries were not chosen), throw
                // an error.

                primary = response.primary, secondaries = response.secondaries;

                if (primary) {
                  _context8.next = 24;
                  break;
                }

                throw new Error('Could not select a primary.');

              case 24:
                newContentNodeEndpoints = CreatorNode$1.buildEndpoint(primary, secondaries);
                newMetadata.creator_node_endpoint = newContentNodeEndpoints; // Update the new primary to the auto-selected primary

                phase = phases.SET_PRIMARY;
                _context8.next = 29;
                return this.creatorNode.setEndpoint(primary);

              case 29:
                // Update metadata in CN and on chain of newly assigned replica set
                phase = phases.UPLOAD_METADATA_AND_UPDATE_ON_CHAIN;
                _context8.next = 32;
                return this.updateAndUploadMetadata({
                  newMetadata: newMetadata,
                  userId: userId
                });

              case 32:
                console.log("".concat(logPrefix, " [phase: ").concat(phase, "] updateAndUploadMetadata() completed in ").concat(Date.now() - startMs, "ms"));
                console.log("".concat(logPrefix, " completed in ").concat(Date.now() - fnStartMs, "ms"));
                _context8.next = 41;
                break;

              case 36:
                _context8.prev = 36;
                _context8.t0 = _context8["catch"](13);
                errorMsg = "assignReplicaSet() Error -- Phase ".concat(phase, " in ").concat(Date.now() - fnStartMs, "ms: ").concat(_context8.t0);
                console.log(errorMsg);
                throw new Error(errorMsg);

              case 41:
                return _context8.abrupt("return", newMetadata);

              case 42:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[13, 36]]);
      }));

      function assignReplicaSet(_x5) {
        return _assignReplicaSet.apply(this, arguments);
      }

      return assignReplicaSet;
    }()
    /**
     * Util to upload profile picture and cover photo images and update
     * a metadata object. This method inherently calls triggerSecondarySyncs().
     * @param {?File} profilePictureFile an optional file to upload as the profile picture
     * @param {?File} coverPhotoFile an optional file to upload as the cover photo
     * @param {Object} metadata to update
     * @returns {Object} the passed in metadata object with profile_picture_sizes and cover_photo_sizes fields added
     */

  }, {
    key: "uploadProfileImages",
    value: function () {
      var _uploadProfileImages = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(profilePictureFile, coverPhotoFile, metadata) {
        var didMetadataUpdate, resp, _resp;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                didMetadataUpdate = false;

                if (!profilePictureFile) {
                  _context9.next = 7;
                  break;
                }

                _context9.next = 4;
                return this.creatorNode.uploadImage(profilePictureFile, true);

              case 4:
                resp = _context9.sent;
                metadata.profile_picture_sizes = resp.dirCID;
                didMetadataUpdate = true;

              case 7:
                if (!coverPhotoFile) {
                  _context9.next = 13;
                  break;
                }

                _context9.next = 10;
                return this.creatorNode.uploadImage(coverPhotoFile, false);

              case 10:
                _resp = _context9.sent;
                metadata.cover_photo_sizes = _resp.dirCID;
                didMetadataUpdate = true;

              case 13:
                if (!didMetadataUpdate) {
                  _context9.next = 16;
                  break;
                }

                _context9.next = 16;
                return this.updateAndUploadMetadata({
                  newMetadata: metadata,
                  userId: metadata.user_id
                });

              case 16:
                return _context9.abrupt("return", metadata);

              case 17:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function uploadProfileImages(_x6, _x7, _x8) {
        return _uploadProfileImages.apply(this, arguments);
      }

      return uploadProfileImages;
    }()
    /**
     * Create an on-chain non-creator user. Some fields are restricted (ex.
     * creator_node_endpoint); this should error if the metadata given attempts to set them.
     * @param {Object} metadata metadata to associate with the user
     */

  }, {
    key: "addUser",
    value: function () {
      var _addUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(metadata) {
        var newMetadata, userId, currentUser, _yield$this$_addUserO, blockHash, blockNumber;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this.IS_OBJECT(metadata);
                newMetadata = this.cleanUserMetadata(metadata);

                this._validateUserMetadata(newMetadata);

                currentUser = this.userStateManager.getCurrentUser();

                if (!(currentUser && currentUser.handle)) {
                  _context10.next = 8;
                  break;
                }

                userId = currentUser.user_id;
                _context10.next = 11;
                break;

              case 8:
                _context10.next = 10;
                return this.contracts.UserFactoryClient.addUser(newMetadata.handle);

              case 10:
                userId = _context10.sent.userId;

              case 11:
                _context10.next = 13;
                return this._addUserOperations(userId, newMetadata);

              case 13:
                _yield$this$_addUserO = _context10.sent;
                blockHash = _yield$this$_addUserO.latestBlockHash;
                blockNumber = _yield$this$_addUserO.latestBlockNumber;
                newMetadata.wallet = this.web3Manager.getWalletAddress();
                newMetadata.user_id = userId;
                this.userStateManager.setCurrentUser(_objectSpread2(_objectSpread2({}, newMetadata), {}, {
                  // Initialize counts to be 0. We don't want to write this data to backends ever really
                  // (hence the cleanUserMetadata above), but we do want to make sure clients
                  // can properly "do math" on these numbers.
                  followee_count: 0,
                  follower_count: 0,
                  repost_count: 0
                }));
                return _context10.abrupt("return", {
                  blockHash: blockHash,
                  blockNumber: blockNumber,
                  userId: userId
                });

              case 20:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function addUser(_x9) {
        return _addUser.apply(this, arguments);
      }

      return addUser;
    }()
    /**
     * Updates a user
     * @param {number} userId
     * @param {Object} metadata
     */

  }, {
    key: "updateUser",
    value: function () {
      var _updateUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(userId, metadata) {
        var newMetadata, users, oldMetadata, _yield$this$_updateUs, blockHash, blockNumber;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this.REQUIRES(Services$4.DISCOVERY_PROVIDER);
                this.IS_OBJECT(metadata);
                newMetadata = this.cleanUserMetadata(metadata);

                this._validateUserMetadata(newMetadata); // Retrieve the current user metadata


                _context11.next = 6;
                return this.discoveryProvider.getUsers(1, 0, [userId], null, null, false, null);

              case 6:
                users = _context11.sent;

                if (!(!users || !users[0])) {
                  _context11.next = 9;
                  break;
                }

                throw new Error("Cannot update user because no current record exists for user id ".concat(userId));

              case 9:
                oldMetadata = users[0];
                _context11.next = 12;
                return this._updateUserOperations(newMetadata, oldMetadata, userId);

              case 12:
                _yield$this$_updateUs = _context11.sent;
                blockHash = _yield$this$_updateUs.latestBlockHash;
                blockNumber = _yield$this$_updateUs.latestBlockNumber;
                this.userStateManager.setCurrentUser(_objectSpread2(_objectSpread2({}, oldMetadata), newMetadata));
                return _context11.abrupt("return", {
                  blockHash: blockHash,
                  blockNumber: blockNumber
                });

              case 17:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function updateUser(_x10, _x11) {
        return _updateUser.apply(this, arguments);
      }

      return updateUser;
    }()
    /**
     * Updates a creator (updates their data on the creator node)
     * @param {number} userId
     * @param {Object} metadata
     */

  }, {
    key: "updateCreator",
    value: function () {
      var _updateCreator = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(userId, metadata) {
        var newMetadata, logPrefix, fnStartMs, startMs, user, oldMetadata, updateEndpointTxBlockNumber, _yield$this$_updateRe, updateEndpointTxReceipt, replicaSetSPIDs, _yield$this$creatorNo, metadataMultihash, metadataFileUUID, updatedMultihashDecoded, _yield$this$contracts, txReceipt, _yield$this$_updateUs2, latestBlockHash, latestBlockNumber;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this.REQUIRES(Services$4.CREATOR_NODE, Services$4.DISCOVERY_PROVIDER);
                this.IS_OBJECT(metadata);
                newMetadata = this.cleanUserMetadata(metadata);

                this._validateUserMetadata(newMetadata);

                logPrefix = "[User:updateCreator()] [userId: ".concat(userId, "]");
                fnStartMs = Date.now();
                startMs = fnStartMs; // Error if libs instance does not already have existing user state

                user = this.userStateManager.getCurrentUser();

                if (user) {
                  _context12.next = 10;
                  break;
                }

                throw new Error('No current user');

              case 10:
                if (!(this.creatorNode.getEndpoint() !== CreatorNode$1.getPrimary(newMetadata.creator_node_endpoint))) {
                  _context12.next = 12;
                  break;
                }

                throw new Error("Not connected to correct content node. Expected ".concat(CreatorNode$1.getPrimary(newMetadata.creator_node_endpoint), ", got ").concat(this.creatorNode.getEndpoint()));

              case 12:
                // Preserve old metadata object
                oldMetadata = _objectSpread2({}, user); // Update user creator_node_endpoint on chain if applicable

                updateEndpointTxBlockNumber = null;

                if (!(newMetadata.creator_node_endpoint !== oldMetadata.creator_node_endpoint)) {
                  _context12.next = 27;
                  break;
                }

                // Perform update to new contract
                startMs = Date.now();
                _context12.next = 18;
                return this._updateReplicaSetOnChain(userId, newMetadata.creator_node_endpoint);

              case 18:
                _yield$this$_updateRe = _context12.sent;
                updateEndpointTxReceipt = _yield$this$_updateRe.txReceipt;
                replicaSetSPIDs = _yield$this$_updateRe.replicaSetSPIDs;
                updateEndpointTxBlockNumber = updateEndpointTxReceipt.blockNumber;
                console.log("".concat(logPrefix, " _updateReplicaSetOnChain() completed in ").concat(Date.now() - startMs, "ms"));
                startMs = Date.now();
                _context12.next = 26;
                return this._waitForURSMCreatorNodeEndpointIndexing(userId, replicaSetSPIDs);

              case 26:
                console.log("".concat(logPrefix, " _waitForURSMCreatorNodeEndpointIndexing() completed in ").concat(Date.now() - startMs, "ms"));

              case 27:
                _context12.next = 29;
                return this.creatorNode.uploadCreatorContent(newMetadata, updateEndpointTxBlockNumber);

              case 29:
                _yield$this$creatorNo = _context12.sent;
                metadataMultihash = _yield$this$creatorNo.metadataMultihash;
                metadataFileUUID = _yield$this$creatorNo.metadataFileUUID;
                // Write metadata multihash to chain
                updatedMultihashDecoded = Utils$3.decodeMultihash(metadataMultihash);
                _context12.next = 35;
                return this.contracts.UserFactoryClient.updateMultihash(userId, updatedMultihashDecoded.digest);

              case 35:
                _yield$this$contracts = _context12.sent;
                txReceipt = _yield$this$contracts.txReceipt;
                _context12.next = 39;
                return this._updateUserOperations(newMetadata, oldMetadata, userId);

              case 39:
                _yield$this$_updateUs2 = _context12.sent;
                latestBlockHash = _yield$this$_updateUs2.latestBlockHash;
                latestBlockNumber = _yield$this$_updateUs2.latestBlockNumber;
                _context12.next = 44;
                return this.creatorNode.associateCreator(userId, metadataFileUUID, Math.max(txReceipt.blockNumber, latestBlockNumber));

              case 44:
                // Update libs instance with new user metadata object
                this.userStateManager.setCurrentUser(_objectSpread2(_objectSpread2({}, oldMetadata), newMetadata));

                if (!latestBlockHash || !latestBlockNumber) {
                  latestBlockHash = txReceipt.blockHash;
                  latestBlockNumber = txReceipt.blockNumber;
                }

                return _context12.abrupt("return", {
                  blockHash: latestBlockHash,
                  blockNumber: latestBlockNumber,
                  userId: userId
                });

              case 47:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function updateCreator(_x12, _x13) {
        return _updateCreator.apply(this, arguments);
      }

      return updateCreator;
    }()
    /**
     * Upgrades a user to a creator using their metadata object.
     * This creates a record for that user on the connected creator node.
     * @param {string} existingEndpoint
     * @param {string} newCreatorNodeEndpoint comma delineated
     */

  }, {
    key: "upgradeToCreator",
    value: function () {
      var _upgradeToCreator = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(existingEndpoint, newCreatorNodeEndpoint) {
        var user, userId, oldMetadata, logPrefix, fnStartMs, startMs, newMetadata, updateEndpointTxBlockNumber, newPrimary, _yield$this$_updateRe2, updateEndpointTxReceipt, replicaSetSPIDs, _yield$this$creatorNo2, metadataMultihash, metadataFileUUID, updatedMultihashDecoded, _yield$this$contracts2, txReceipt, _yield$this$_updateUs3, latestBlockNumber;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                this.REQUIRES(Services$4.CREATOR_NODE); // Error if libs instance does not already have existing user state

                user = this.userStateManager.getCurrentUser();

                if (user) {
                  _context13.next = 4;
                  break;
                }

                throw new Error('No current user');

              case 4:
                if (!(user.is_creator && user.creator_node_endpoint)) {
                  _context13.next = 6;
                  break;
                }

                return _context13.abrupt("return");

              case 6:
                userId = user.user_id;
                oldMetadata = _objectSpread2({}, user);
                logPrefix = "[User:upgradeToCreator()] [userId: ".concat(userId, "]");
                fnStartMs = Date.now();
                startMs = fnStartMs; // Clean and validate metadata

                newMetadata = this.cleanUserMetadata(_objectSpread2({}, user));

                this._validateUserMetadata(newMetadata); // Populate metadata with required fields - wallet, is_creator, creator_node_endpoint


                newMetadata.wallet = this.web3Manager.getWalletAddress();
                newMetadata.is_creator = true;
                updateEndpointTxBlockNumber = null;
                /**
                 * If there is no creator_node_endpoint field or if newCreatorNodeEndpoint is not the same as the existing
                 * metadata creator_node_endpoint field value, update the field with newCreatorNodeEndpoint.
                 * This is because new users on signup will now be assigned a replica set, and do not need to
                 * be assigned a new one via newCreatorNodeEndpoint.
                 */

                if (!(!oldMetadata.creator_node_endpoint || oldMetadata.creator_node_endpoint !== newCreatorNodeEndpoint)) {
                  _context13.next = 36;
                  break;
                }

                newMetadata.creator_node_endpoint = newCreatorNodeEndpoint;
                newPrimary = CreatorNode$1.getPrimary(newCreatorNodeEndpoint); // Sync user data from old primary to new endpoint

                if (!existingEndpoint) {
                  _context13.next = 22;
                  break;
                }

                _context13.next = 22;
                return this.creatorNode.syncSecondary(newPrimary, existingEndpoint,
                /* immediate= */
                true,
                /* validate= */
                false);

              case 22:
                _context13.next = 24;
                return this.creatorNode.setEndpoint(newPrimary);

              case 24:
                // Update user creator_node_endpoint on chain if applicable
                startMs = Date.now();
                _context13.next = 27;
                return this._updateReplicaSetOnChain(userId, newMetadata.creator_node_endpoint);

              case 27:
                _yield$this$_updateRe2 = _context13.sent;
                updateEndpointTxReceipt = _yield$this$_updateRe2.txReceipt;
                replicaSetSPIDs = _yield$this$_updateRe2.replicaSetSPIDs;
                updateEndpointTxBlockNumber = updateEndpointTxReceipt.blockNumber;
                console.log("".concat(logPrefix, " _updateReplicaSetOnChain() completed in ").concat(Date.now() - startMs, "ms"));
                startMs = Date.now();
                _context13.next = 35;
                return this._waitForURSMCreatorNodeEndpointIndexing(userId, replicaSetSPIDs);

              case 35:
                console.log("".concat(logPrefix, " _waitForURSMCreatorNodeEndpointIndexing() completed in ").concat(Date.now() - startMs, "ms"));

              case 36:
                _context13.next = 38;
                return this.creatorNode.uploadCreatorContent(newMetadata, updateEndpointTxBlockNumber);

              case 38:
                _yield$this$creatorNo2 = _context13.sent;
                metadataMultihash = _yield$this$creatorNo2.metadataMultihash;
                metadataFileUUID = _yield$this$creatorNo2.metadataFileUUID;
                // Write metadata multihash to chain
                updatedMultihashDecoded = Utils$3.decodeMultihash(metadataMultihash);
                _context13.next = 44;
                return this.contracts.UserFactoryClient.updateMultihash(userId, updatedMultihashDecoded.digest);

              case 44:
                _yield$this$contracts2 = _context13.sent;
                txReceipt = _yield$this$contracts2.txReceipt;
                _context13.next = 48;
                return this._updateUserOperations(newMetadata, oldMetadata, userId);

              case 48:
                _yield$this$_updateUs3 = _context13.sent;
                latestBlockNumber = _yield$this$_updateUs3.latestBlockNumber;
                _context13.next = 52;
                return this.creatorNode.associateCreator(userId, metadataFileUUID, Math.max(txReceipt.blockNumber, latestBlockNumber));

              case 52:
                // Update libs instance with new user metadata object
                this.userStateManager.setCurrentUser(_objectSpread2(_objectSpread2({}, oldMetadata), newMetadata));
                return _context13.abrupt("return", userId);

              case 54:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function upgradeToCreator(_x14, _x15) {
        return _upgradeToCreator.apply(this, arguments);
      }

      return upgradeToCreator;
    }()
    /**
     * Updates a user on whether they are verified on Audius
     * @param {number} userId
     * @param {boolean} isVerified
     */

  }, {
    key: "updateIsVerified",
    value: function () {
      var _updateIsVerified = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(userId, isVerified, privateKey) {
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                return _context14.abrupt("return", this.contracts.UserFactoryClient.updateIsVerified(userId, isVerified, privateKey));

              case 1:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function updateIsVerified(_x16, _x17, _x18) {
        return _updateIsVerified.apply(this, arguments);
      }

      return updateIsVerified;
    }()
    /**
     * Adds a user follow for a given follower and followee
     * @param {number} followerUserId who is following
     * @param {number} followeeUserId who is being followed...
    */

  }, {
    key: "addUserFollow",
    value: function () {
      var _addUserFollow = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(followeeUserId) {
        var followerUserId;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                followerUserId = this.userStateManager.getCurrentUserId();
                return _context15.abrupt("return", this.contracts.SocialFeatureFactoryClient.addUserFollow(followerUserId, followeeUserId));

              case 2:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function addUserFollow(_x19) {
        return _addUserFollow.apply(this, arguments);
      }

      return addUserFollow;
    }()
    /**
     * Deletes a user follow for a given follower and followee
     * @param {number} followerUserId who is no longer following
     * @param {number} followeeUserId who is no longer being followed...
    */

  }, {
    key: "deleteUserFollow",
    value: function () {
      var _deleteUserFollow = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(followeeUserId) {
        var followerUserId;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                followerUserId = this.userStateManager.getCurrentUserId();
                return _context16.abrupt("return", this.contracts.SocialFeatureFactoryClient.deleteUserFollow(followerUserId, followeeUserId));

              case 2:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function deleteUserFollow(_x20) {
        return _deleteUserFollow.apply(this, arguments);
      }

      return deleteUserFollow;
    }()
    /**
     * Gets the clock status for user in userStateManager across replica set.
     */

  }, {
    key: "getClockValuesFromReplicaSet",
    value: function () {
      var _getClockValuesFromReplicaSet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                return _context17.abrupt("return", this.creatorNode.getClockValuesFromReplicaSet());

              case 1:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getClockValuesFromReplicaSet() {
        return _getClockValuesFromReplicaSet.apply(this, arguments);
      }

      return getClockValuesFromReplicaSet;
    }()
    /* ------- PRIVATE  ------- */

    /**
     * 1. Uploads metadata to primary Content Node (which inherently calls a sync accross secondaries)
     * 2. Updates metadata on chain
     * @param {Object} param
     * @param {Object} param.newMetadata new metadata object
     * @param {number} param.userId
     */

  }, {
    key: "updateAndUploadMetadata",
    value: function () {
      var _updateAndUploadMetadata = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(_ref2) {
        var newMetadata, userId, phases, phase, oldMetadata, logPrefix, fnStartMs, startMs, _yield$this$_updateRe3, replicaSetSPIDs, _yield$this$creatorNo3, metadataMultihash, metadataFileUUID, updatedMultihashDecoded, _yield$this$contracts3, txReceipt, _yield$this$_updateUs4, latestBlockNumber, errorMsg;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                newMetadata = _ref2.newMetadata, userId = _ref2.userId;
                this.REQUIRES(Services$4.CREATOR_NODE, Services$4.DISCOVERY_PROVIDER);
                this.IS_OBJECT(newMetadata);
                phases = {
                  UPDATE_CONTENT_NODE_ENDPOINT_ON_CHAIN: 'UPDATE_CONTENT_NODE_ENDPOINT_ON_CHAIN',
                  UPLOAD_METADATA: 'UPLOAD_METADATA',
                  UPDATE_METADATA_ON_CHAIN: 'UPDATE_METADATA_ON_CHAIN',
                  UPDATE_USER_ON_CHAIN_OPS: 'UPDATE_USER_ON_CHAIN_OPS',
                  ASSOCIATE_USER: 'ASSOCIATE_USER'
                };
                phase = '';
                oldMetadata = this.userStateManager.getCurrentUser();

                if (oldMetadata) {
                  _context18.next = 8;
                  break;
                }

                throw new Error('No current user.');

              case 8:
                newMetadata = this.cleanUserMetadata(newMetadata);

                this._validateUserMetadata(newMetadata);

                logPrefix = "[User:updateAndUploadMetadata()] [userId: ".concat(userId, "]");
                fnStartMs = Date.now();
                startMs = fnStartMs;
                _context18.prev = 13;

                if (!(newMetadata.creator_node_endpoint !== oldMetadata.creator_node_endpoint)) {
                  _context18.next = 25;
                  break;
                }

                phase = phases.UPDATE_CONTENT_NODE_ENDPOINT_ON_CHAIN;
                _context18.next = 18;
                return this._updateReplicaSetOnChain(userId, newMetadata.creator_node_endpoint);

              case 18:
                _yield$this$_updateRe3 = _context18.sent;
                replicaSetSPIDs = _yield$this$_updateRe3.replicaSetSPIDs;
                console.log("".concat(logPrefix, " [phase: ").concat(phase, "] _updateReplicaSetOnChain() completed in ").concat(Date.now() - startMs, "ms"));
                startMs = Date.now();
                _context18.next = 24;
                return this._waitForURSMCreatorNodeEndpointIndexing(userId, replicaSetSPIDs);

              case 24:
                console.log("".concat(logPrefix, " [phase: ").concat(phase, "] _waitForURSMCreatorNodeEndpointIndexing() completed in ").concat(Date.now() - startMs, "ms"));

              case 25:
                // Upload new metadata object to CN
                phase = phases.UPLOAD_METADATA;
                _context18.next = 28;
                return this.creatorNode.uploadCreatorContent(newMetadata);

              case 28:
                _yield$this$creatorNo3 = _context18.sent;
                metadataMultihash = _yield$this$creatorNo3.metadataMultihash;
                metadataFileUUID = _yield$this$creatorNo3.metadataFileUUID;
                console.log("".concat(logPrefix, " [phase: ").concat(phase, "] creatorNode.uploadCreatorContent() completed in ").concat(Date.now() - startMs, "ms"));
                startMs = Date.now(); // Write metadata multihash to chain

                phase = phases.UPDATE_METADATA_ON_CHAIN;
                updatedMultihashDecoded = Utils$3.decodeMultihash(metadataMultihash);
                _context18.next = 37;
                return this.contracts.UserFactoryClient.updateMultihash(userId, updatedMultihashDecoded.digest);

              case 37:
                _yield$this$contracts3 = _context18.sent;
                txReceipt = _yield$this$contracts3.txReceipt;
                console.log("".concat(logPrefix, " [phase: ").concat(phase, "] UserFactoryClient.updateMultihash() completed in ").concat(Date.now() - startMs, "ms"));
                startMs = Date.now(); // Write remaining metadata fields to chain

                phase = phases.UPDATE_USER_ON_CHAIN_OPS;
                _context18.next = 44;
                return this._updateUserOperations(newMetadata, oldMetadata, userId, ['creator_node_endpoint']);

              case 44:
                _yield$this$_updateUs4 = _context18.sent;
                latestBlockNumber = _yield$this$_updateUs4.latestBlockNumber;
                console.log("".concat(logPrefix, " [phase: ").concat(phase, "] _updateUserOperations() completed in ").concat(Date.now() - startMs, "ms"));
                startMs = Date.now(); // Write to CN to associate blockchain user id with updated metadata and block number

                phase = phases.ASSOCIATE_USER;
                _context18.next = 51;
                return this.creatorNode.associateCreator(userId, metadataFileUUID, Math.max(txReceipt.blockNumber, latestBlockNumber));

              case 51:
                console.log("".concat(logPrefix, " [phase: ").concat(phase, "] creatorNode.associateCreator() completed in ").concat(Date.now() - startMs, "ms"));
                startMs = Date.now(); // Update libs instance with new user metadata object

                this.userStateManager.setCurrentUser(_objectSpread2(_objectSpread2({}, oldMetadata), newMetadata));
                console.log("".concat(logPrefix, " completed in ").concat(Date.now() - fnStartMs, "ms"));
                _context18.next = 62;
                break;

              case 57:
                _context18.prev = 57;
                _context18.t0 = _context18["catch"](13);
                // TODO: think about handling the update metadata on chain and associating..
                errorMsg = "updateAndUploadMetadata() Error -- Phase ".concat(phase, " in ").concat(Date.now() - fnStartMs, "ms: ").concat(_context18.t0);
                console.log(errorMsg);
                throw new Error(errorMsg);

              case 62:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this, [[13, 57]]);
      }));

      function updateAndUploadMetadata(_x21) {
        return _updateAndUploadMetadata.apply(this, arguments);
      }

      return updateAndUploadMetadata;
    }()
    /**
     * If a user's creator_node_endpoint is null, assign a replica set.
     * Used during the sanity check and in uploadImage() in files.js
     */

  }, {
    key: "assignReplicaSetIfNecessary",
    value: function () {
      var _assignReplicaSetIfNecessary = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
        var user;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                user = this.userStateManager.getCurrentUser(); // If no user is logged in, or a creator node endpoint is already assigned,
                // skip this call

                if (!(!user || user.creator_node_endpoint)) {
                  _context19.next = 3;
                  break;
                }

                return _context19.abrupt("return");

              case 3:
                _context19.prev = 3;
                _context19.next = 6;
                return this.assignReplicaSet({
                  userId: user.user_id
                });

              case 6:
                _context19.next = 11;
                break;

              case 8:
                _context19.prev = 8;
                _context19.t0 = _context19["catch"](3);
                throw new Error("assignReplicaSetIfNecessary error - ".concat(_context19.t0.toString()));

              case 11:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this, [[3, 8]]);
      }));

      function assignReplicaSetIfNecessary() {
        return _assignReplicaSetIfNecessary.apply(this, arguments);
      }

      return assignReplicaSetIfNecessary;
    }()
    /** Waits for a discovery provider to confirm that a creator node endpoint is updated. */

  }, {
    key: "_waitForCreatorNodeEndpointIndexing",
    value: function () {
      var _waitForCreatorNodeEndpointIndexing2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(userId, creatorNodeEndpoint) {
        var userList, _user;

        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:

                _context20.next = 3;
                return this.discoveryProvider.getUsers(1, 0, [userId]);

              case 3:
                userList = _context20.sent;

                if (!userList) {
                  _context20.next = 8;
                  break;
                }

                _user = userList[0];

                if (!(_user && _user.creator_node_endpoint === creatorNodeEndpoint)) {
                  _context20.next = 8;
                  break;
                }

                return _context20.abrupt("break", 12);

              case 8:
                _context20.next = 10;
                return Utils$3.wait(500);

              case 10:
                _context20.next = 0;
                break;

              case 12:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function _waitForCreatorNodeEndpointIndexing(_x22, _x23) {
        return _waitForCreatorNodeEndpointIndexing2.apply(this, arguments);
      }

      return _waitForCreatorNodeEndpointIndexing;
    }()
  }, {
    key: "_waitForURSMCreatorNodeEndpointIndexing",
    value: function () {
      var _waitForURSMCreatorNodeEndpointIndexing2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(userId, replicaSetSPIDs) {
        var _this2 = this;

        var timeoutMs,
            asyncFn,
            _args22 = arguments;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                timeoutMs = _args22.length > 2 && _args22[2] !== undefined ? _args22[2] : 60000;

                asyncFn = /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
                    var replicaSet;
                    return regeneratorRuntime.wrap(function _callee21$(_context21) {
                      while (1) {
                        switch (_context21.prev = _context21.next) {
                          case 0:

                            _context21.next = 3;
                            return _this2.contracts.UserReplicaSetManagerClient.getUserReplicaSet(userId);

                          case 3:
                            replicaSet = _context21.sent;

                            if (!(replicaSet && Object.prototype.hasOwnProperty.call(replicaSet, 'primaryId') && Object.prototype.hasOwnProperty.call(replicaSet, 'secondaryIds') && replicaSet.primaryId === replicaSetSPIDs[0] && isEqual(replicaSet.secondaryIds, replicaSetSPIDs.slice(1, 3)))) {
                              _context21.next = 6;
                              break;
                            }

                            return _context21.abrupt("break", 8);

                          case 6:
                            _context21.next = 0;
                            break;

                          case 8:
                            _context21.next = 10;
                            return Utils$3.wait(500);

                          case 10:
                          case "end":
                            return _context21.stop();
                        }
                      }
                    }, _callee21);
                  }));

                  return function asyncFn() {
                    return _ref3.apply(this, arguments);
                  };
                }();

                _context22.next = 4;
                return Utils$3.racePromiseWithTimeout(asyncFn(), timeoutMs, "[User:_waitForURSMCreatorNodeEndpointIndexing()] Timeout error after ".concat(timeoutMs, "ms"));

              case 4:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22);
      }));

      function _waitForURSMCreatorNodeEndpointIndexing(_x24, _x25) {
        return _waitForURSMCreatorNodeEndpointIndexing2.apply(this, arguments);
      }

      return _waitForURSMCreatorNodeEndpointIndexing;
    }()
  }, {
    key: "_addUserOperations",
    value: function () {
      var _addUserOperations2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(userId, newMetadata) {
        var exclude,
            addOps,
            metadata,
            ops,
            latestBlockNumber,
            latestBlockHash,
            sortedOpsDesc,
            latestTx,
            _args23 = arguments;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                exclude = _args23.length > 2 && _args23[2] !== undefined ? _args23[2] : [];
                addOps = []; // Remove excluded keys from metadata object

                metadata = _objectSpread2({}, newMetadata);
                exclude.map(function (excludedKey) {
                  return delete metadata[excludedKey];
                });

                if (metadata[USER_PROP_NAME_CONSTANTS.NAME]) {
                  addOps.push(this.contracts.UserFactoryClient.updateName(userId, metadata[USER_PROP_NAME_CONSTANTS.NAME]));
                }

                if (metadata[USER_PROP_NAME_CONSTANTS.LOCATION]) {
                  addOps.push(this.contracts.UserFactoryClient.updateLocation(userId, metadata[USER_PROP_NAME_CONSTANTS.LOCATION]));
                }

                if (metadata[USER_PROP_NAME_CONSTANTS.BIO]) {
                  addOps.push(this.contracts.UserFactoryClient.updateBio(userId, metadata[USER_PROP_NAME_CONSTANTS.BIO]));
                }

                if (metadata[USER_PROP_NAME_CONSTANTS.PROFILE_PICTURE_SIZES]) {
                  addOps.push(this.contracts.UserFactoryClient.updateProfilePhoto(userId, Utils$3.decodeMultihash(metadata[USER_PROP_NAME_CONSTANTS.PROFILE_PICTURE_SIZES]).digest));
                }

                if (metadata[USER_PROP_NAME_CONSTANTS.COVER_PHOTO_SIZES]) {
                  addOps.push(this.contracts.UserFactoryClient.updateCoverPhoto(userId, Utils$3.decodeMultihash(metadata[USER_PROP_NAME_CONSTANTS.COVER_PHOTO_SIZES]).digest));
                }

                if (metadata[USER_PROP_NAME_CONSTANTS.IS_CREATOR]) {
                  addOps.push(this.contracts.UserFactoryClient.updateIsCreator(userId, metadata[USER_PROP_NAME_CONSTANTS.IS_CREATOR]));
                }

                latestBlockNumber = -Infinity;

                if (!(addOps.length > 0)) {
                  _context23.next = 19;
                  break;
                }

                _context23.next = 14;
                return Promise.all(addOps);

              case 14:
                ops = _context23.sent;
                sortedOpsDesc = ops.sort(function (op1, op2) {
                  return op2.txReceipt.blockNumber - op1.txReceipt.blockNumber;
                });
                latestTx = sortedOpsDesc[0].txReceipt;
                latestBlockNumber = latestTx.blockNumber;
                latestBlockHash = latestTx.blockHash;

              case 19:
                return _context23.abrupt("return", {
                  ops: ops,
                  latestBlockNumber: latestBlockNumber,
                  latestBlockHash: latestBlockHash
                });

              case 20:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function _addUserOperations(_x26, _x27) {
        return _addUserOperations2.apply(this, arguments);
      }

      return _addUserOperations;
    }()
  }, {
    key: "_updateUserOperations",
    value: function () {
      var _updateUserOperations2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(newMetadata, currentMetadata, userId) {
        var exclude,
            updateOps,
            metadata,
            key,
            ops,
            latestBlockNumber,
            latestBlockHash,
            sortedOpsDesc,
            latestTx,
            _args24 = arguments;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                exclude = _args24.length > 3 && _args24[3] !== undefined ? _args24[3] : [];
                updateOps = []; // Remove excluded keys from metadata object

                metadata = _objectSpread2({}, newMetadata);
                exclude.map(function (excludedKey) {
                  return delete metadata[excludedKey];
                }); // Compare the existing metadata with the new values and conditionally
                // perform update operations

                for (key in metadata) {
                  if (Object.prototype.hasOwnProperty.call(metadata, key) && Object.prototype.hasOwnProperty.call(currentMetadata, key) && metadata[key] !== currentMetadata[key]) {
                    if (key === USER_PROP_NAME_CONSTANTS.NAME) {
                      updateOps.push(this.contracts.UserFactoryClient.updateName(userId, metadata[USER_PROP_NAME_CONSTANTS.NAME]));
                    }

                    if (key === USER_PROP_NAME_CONSTANTS.IS_CREATOR) {
                      updateOps.push(this.contracts.UserFactoryClient.updateIsCreator(userId, metadata[USER_PROP_NAME_CONSTANTS.IS_CREATOR]));
                    }

                    if (key === USER_PROP_NAME_CONSTANTS.BIO) {
                      updateOps.push(this.contracts.UserFactoryClient.updateBio(userId, metadata[USER_PROP_NAME_CONSTANTS.BIO]));
                    }

                    if (key === USER_PROP_NAME_CONSTANTS.LOCATION) {
                      updateOps.push(this.contracts.UserFactoryClient.updateLocation(userId, metadata[USER_PROP_NAME_CONSTANTS.LOCATION]));
                    }

                    if (key === USER_PROP_NAME_CONSTANTS.PROFILE_PICTURE_SIZES) {
                      updateOps.push(this.contracts.UserFactoryClient.updateProfilePhoto(userId, Utils$3.decodeMultihash(metadata[USER_PROP_NAME_CONSTANTS.PROFILE_PICTURE_SIZES]).digest));
                    }

                    if (key === USER_PROP_NAME_CONSTANTS.COVER_PHOTO_SIZES) {
                      updateOps.push(this.contracts.UserFactoryClient.updateCoverPhoto(userId, Utils$3.decodeMultihash(metadata[USER_PROP_NAME_CONSTANTS.COVER_PHOTO_SIZES]).digest));
                    }
                  }
                }

                latestBlockNumber = -Infinity;

                if (!(updateOps.length > 0)) {
                  _context24.next = 14;
                  break;
                }

                _context24.next = 9;
                return Promise.all(updateOps);

              case 9:
                ops = _context24.sent;
                sortedOpsDesc = ops.sort(function (op1, op2) {
                  return op2.txReceipt.blockNumber - op1.txReceipt.blockNumber;
                });
                latestTx = sortedOpsDesc[0].txReceipt;
                latestBlockNumber = latestTx.blockNumber;
                latestBlockHash = latestTx.blockHash;

              case 14:
                return _context24.abrupt("return", {
                  ops: ops,
                  latestBlockNumber: latestBlockNumber,
                  latestBlockHash: latestBlockHash
                });

              case 15:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function _updateUserOperations(_x28, _x29, _x30) {
        return _updateUserOperations2.apply(this, arguments);
      }

      return _updateUserOperations;
    }()
  }, {
    key: "_validateUserMetadata",
    value: function _validateUserMetadata(metadata) {
      this.OBJECT_HAS_PROPS(metadata, USER_PROPS, USER_REQUIRED_PROPS);
    }
    /**
     * Metadata object may have extra fields.
     * - Add what user props might be missing to normalize
     * - Only keep core fields in USER_PROPS and 'user_id'.
     */

  }, {
    key: "cleanUserMetadata",
    value: function cleanUserMetadata(metadata) {
      USER_PROPS.forEach(function (prop) {
        if (!(prop in metadata)) {
          metadata[prop] = null;
        }
      });
      return pick(metadata, USER_PROPS.concat('user_id'));
    } // Perform replica set update
    // Conditionally write to UserFactory contract, else write to UserReplicaSetManager
    // This behavior is to ensure backwards compatibility prior to contract deploy

  }, {
    key: "_updateReplicaSetOnChain",
    value: function () {
      var _updateReplicaSetOnChain2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(userId, creatorNodeEndpoint) {
        var primaryEndpoint, secondaries, _yield$Promise$all, _yield$Promise$all2, primarySpID, secondary1SpID, secondary2SpID, txReceipt, replicaSetSPIDs;

        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if (this.contracts.UserReplicaSetManagerClient) {
                  _context25.next = 3;
                  break;
                }

                _context25.next = 3;
                return this.contracts.initUserReplicaSetManagerClient();

              case 3:
                primaryEndpoint = CreatorNode$1.getPrimary(creatorNodeEndpoint);
                secondaries = CreatorNode$1.getSecondaries(creatorNodeEndpoint);

                if (!(secondaries.length < 2)) {
                  _context25.next = 7;
                  break;
                }

                throw new Error("Invalid number of secondaries found - received ".concat(secondaries));

              case 7:
                _context25.next = 9;
                return Promise.all([this._retrieveSpIDFromEndpoint(primaryEndpoint), this._retrieveSpIDFromEndpoint(secondaries[0]), this._retrieveSpIDFromEndpoint(secondaries[1])]);

              case 9:
                _yield$Promise$all = _context25.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);
                primarySpID = _yield$Promise$all2[0];
                secondary1SpID = _yield$Promise$all2[1];
                secondary2SpID = _yield$Promise$all2[2];
                _context25.next = 16;
                return this.contracts.UserReplicaSetManagerClient.updateReplicaSet(userId, primarySpID, [secondary1SpID, secondary2SpID]);

              case 16:
                txReceipt = _context25.sent;
                replicaSetSPIDs = [primarySpID, secondary1SpID, secondary2SpID];
                return _context25.abrupt("return", {
                  txReceipt: txReceipt,
                  replicaSetSPIDs: replicaSetSPIDs
                });

              case 19:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function _updateReplicaSetOnChain(_x31, _x32) {
        return _updateReplicaSetOnChain2.apply(this, arguments);
      }

      return _updateReplicaSetOnChain;
    }() // Retrieve cached value for spID from endpoint if present, otherwise fetch from eth web3
    // Any error in the web3 fetch will short circuit the entire operation as expected

  }, {
    key: "_retrieveSpIDFromEndpoint",
    value: function () {
      var _retrieveSpIDFromEndpoint2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(endpoint) {
        var cachedSpID, spID, spEndpointInfo;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                cachedSpID = getSpIDForEndpoint(endpoint);
                spID = cachedSpID;

                if (spID) {
                  _context26.next = 10;
                  break;
                }

                _context26.next = 5;
                return this.ethContracts.ServiceProviderFactoryClient.getServiceProviderInfoFromEndpoint(endpoint);

              case 5:
                spEndpointInfo = _context26.sent;
                // Throw if this spID is 0, indicating invalid
                spID = spEndpointInfo.spID;

                if (!(spID === 0)) {
                  _context26.next = 9;
                  break;
                }

                throw new Error("Failed to find spID for ".concat(endpoint));

              case 9:
                // Cache value if it is valid
                setSpIDForEndpoint(endpoint, spID);

              case 10:
                return _context26.abrupt("return", spID);

              case 11:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function _retrieveSpIDFromEndpoint(_x33) {
        return _retrieveSpIDFromEndpoint2.apply(this, arguments);
      }

      return _retrieveSpIDFromEndpoint;
    }()
  }]);

  return Users;
}(Base$5);

user.exports = Users;
user.exports.USER_PROP_NAME_CONSTANTS = USER_PROP_NAME_CONSTANTS;

var Base$4 = base.Base,
    Services$3 = base.Services;
var CreatorNode = require$$10.CreatorNode;
var Utils$2 = require$$18.Utils;
var retry$1 = retry__default["default"];
var TRACK_PROPS = ['owner_id', 'title', 'length', 'cover_art_sizes', 'tags', 'genre', 'mood', 'credits_splits', 'release_date', 'file_type'];
var TRACK_REQUIRED_PROPS = ['owner_id', 'title'];

var Track = /*#__PURE__*/function (_Base) {
  _inherits(Track, _Base);

  var _super = _createSuper(Track);

  function Track() {
    var _this;

    _classCallCheck(this, Track);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.getTracks = _this.getTracks.bind(_assertThisInitialized(_this));
    _this.getTracksIncludingUnlisted = _this.getTracksIncludingUnlisted.bind(_assertThisInitialized(_this));
    _this.getRandomTracks = _this.getRandomTracks.bind(_assertThisInitialized(_this));
    _this.getStemsForTrack = _this.getStemsForTrack.bind(_assertThisInitialized(_this));
    _this.getRemixesOfTrack = _this.getRemixesOfTrack.bind(_assertThisInitialized(_this));
    _this.getRemixTrackParents = _this.getRemixTrackParents.bind(_assertThisInitialized(_this));
    _this.getSavedTracks = _this.getSavedTracks.bind(_assertThisInitialized(_this));
    _this.getTrendingTracks = _this.getTrendingTracks.bind(_assertThisInitialized(_this));
    _this.getTrackListens = _this.getTrackListens.bind(_assertThisInitialized(_this));
    _this.getSaversForTrack = _this.getSaversForTrack.bind(_assertThisInitialized(_this));
    _this.getSaversForPlaylist = _this.getSaversForPlaylist.bind(_assertThisInitialized(_this));
    _this.getRepostersForTrack = _this.getRepostersForTrack.bind(_assertThisInitialized(_this));
    _this.getRepostersForPlaylist = _this.getRepostersForPlaylist.bind(_assertThisInitialized(_this));
    _this.getListenHistoryTracks = _this.getListenHistoryTracks.bind(_assertThisInitialized(_this));
    _this.checkIfDownloadAvailable = _this.checkIfDownloadAvailable.bind(_assertThisInitialized(_this));
    _this.uploadTrack = _this.uploadTrack.bind(_assertThisInitialized(_this));
    _this.uploadTrackContentToCreatorNode = _this.uploadTrackContentToCreatorNode.bind(_assertThisInitialized(_this));
    _this.addTracksToChainAndCnode = _this.addTracksToChainAndCnode.bind(_assertThisInitialized(_this));
    _this.updateTrack = _this.updateTrack.bind(_assertThisInitialized(_this));
    _this.logTrackListen = _this.logTrackListen.bind(_assertThisInitialized(_this));
    _this.addTrackRepost = _this.addTrackRepost.bind(_assertThisInitialized(_this));
    _this.deleteTrackRepost = _this.deleteTrackRepost.bind(_assertThisInitialized(_this));
    _this.addTrackSave = _this.addTrackSave.bind(_assertThisInitialized(_this));
    _this.deleteTrackSave = _this.deleteTrackSave.bind(_assertThisInitialized(_this));
    _this.deleteTrack = _this.deleteTrack.bind(_assertThisInitialized(_this));
    return _this;
  }
  /* ------- GETTERS ------- */

  /**
   * get tracks with all relevant track data
   * can be filtered by providing an integer array of ids
   * @param {number} limit
   * @param {number} offset
   * @param {Object} idsArray
   * @param {number} targetUserId the owner of the tracks being queried
   * @param {string} sort a string of form eg. blocknumber:asc,timestamp:desc describing a sort path
   * @param {number} minBlockNumber The min block number
   * @param {boolean} filterDeleted If set to true filters out deleted tracks
   * @returns {Object} {Array of track metadata Objects}
   * additional metadata fields on track objects:
   *  {Integer} repost_count - repost count for given track
   *  {Integer} save_count - save count for given track
   *  {Array} followee_reposts - followees of current user that have reposted given track
   *  {Boolean} has_current_user_reposted - has current user reposted given track
   *  {Boolean} has_current_user_saved - has current user saved given track
   * @example
   * await getTracks()
   * await getTracks(100, 0, [3,2,6]) - Invalid track ids will not be accepted
   */


  _createClass(Track, [{
    key: "getTracks",
    value: function () {
      var _getTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var limit,
            offset,
            idsArray,
            targetUserId,
            sort,
            minBlockNumber,
            filterDeleted,
            withUsers,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                limit = _args.length > 0 && _args[0] !== undefined ? _args[0] : 100;
                offset = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;
                idsArray = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
                targetUserId = _args.length > 3 && _args[3] !== undefined ? _args[3] : null;
                sort = _args.length > 4 && _args[4] !== undefined ? _args[4] : null;
                minBlockNumber = _args.length > 5 && _args[5] !== undefined ? _args[5] : null;
                filterDeleted = _args.length > 6 && _args[6] !== undefined ? _args[6] : null;
                withUsers = _args.length > 7 && _args[7] !== undefined ? _args[7] : false;
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context.abrupt("return", this.discoveryProvider.getTracks(limit, offset, idsArray, targetUserId, sort, minBlockNumber, filterDeleted, withUsers));

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getTracks() {
        return _getTracks.apply(this, arguments);
      }

      return getTracks;
    }()
    /**
     * Gets tracks by their slug and owner handle
     * @param {string} handle the owner's handle
     * @param {string} slug the track's slug, including collision identifiers
     */

  }, {
    key: "getTracksByHandleAndSlug",
    value: function () {
      var _getTracksByHandleAndSlug = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(handle, slug) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context2.abrupt("return", this.discoveryProvider.getTracksByHandleAndSlug(handle, slug));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getTracksByHandleAndSlug(_x, _x2) {
        return _getTracksByHandleAndSlug.apply(this, arguments);
      }

      return getTracksByHandleAndSlug;
    }()
    /**
     * @typedef {Object} getTracksIdentifier
     * @property {string} handle
     * @property {number} id
     * @property {string} url_title
     */

    /**
     * gets all tracks matching identifiers, including unlisted.
     *
     * @param {getTracksIdentifier[]} identifiers
     * @returns {(Array)} track
     */

  }, {
    key: "getTracksIncludingUnlisted",
    value: function () {
      var _getTracksIncludingUnlisted = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(identifiers) {
        var withUsers,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                withUsers = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : false;
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context3.abrupt("return", this.discoveryProvider.getTracksIncludingUnlisted(identifiers, withUsers));

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getTracksIncludingUnlisted(_x3) {
        return _getTracksIncludingUnlisted.apply(this, arguments);
      }

      return getTracksIncludingUnlisted;
    }()
    /**
     * Gets random tracks from trending tracks for a given genre.
     * If genre not given, will return trending tracks across all genres.
     * Excludes specified track ids.
     *
     * @param {string} genre
     * @param {number} limit
     * @param {number[]} exclusionList
     * @param {string} time
     * @returns {(Array)} track
     */

  }, {
    key: "getRandomTracks",
    value: function () {
      var _getRandomTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(genre, limit, exclusionList, time) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context4.abrupt("return", this.discoveryProvider.getRandomTracks(genre, limit, exclusionList, time));

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getRandomTracks(_x4, _x5, _x6, _x7) {
        return _getRandomTracks.apply(this, arguments);
      }

      return getRandomTracks;
    }()
    /**
     * Gets all stems for a given trackId as an array of tracks.
     * @param {number} trackId
     * @returns {(Array)} track
     */

  }, {
    key: "getStemsForTrack",
    value: function () {
      var _getStemsForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(trackId) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context5.abrupt("return", this.discoveryProvider.getStemsForTrack(trackId));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getStemsForTrack(_x8) {
        return _getStemsForTrack.apply(this, arguments);
      }

      return getStemsForTrack;
    }()
    /**
     * Gets all the remixes of a given trackId as an array of tracks.
     * @param {number} trackId
     * @param {number} limit
     * @param {number} offset
     * @returns {(Array)} track
     */

  }, {
    key: "getRemixesOfTrack",
    value: function () {
      var _getRemixesOfTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(trackId) {
        var limit,
            offset,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                limit = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : null;
                offset = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : null;
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context6.abrupt("return", this.discoveryProvider.getRemixesOfTrack(trackId, limit, offset));

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getRemixesOfTrack(_x9) {
        return _getRemixesOfTrack.apply(this, arguments);
      }

      return getRemixesOfTrack;
    }()
    /**
     * Gets the remix parents of a given trackId as an array of tracks.
     * @param {number} trackId
     * @param {number} limit
     * @param {number} offset
     * @returns {(Array)} track
     * @returns {(Array)} track
     */

  }, {
    key: "getRemixTrackParents",
    value: function () {
      var _getRemixTrackParents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(trackId) {
        var limit,
            offset,
            _args7 = arguments;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                limit = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : null;
                offset = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : null;
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context7.abrupt("return", this.discoveryProvider.getRemixTrackParents(trackId, limit, offset));

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getRemixTrackParents(_x10) {
        return _getRemixTrackParents.apply(this, arguments);
      }

      return getRemixTrackParents;
    }()
    /**
     * Return saved tracks for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param {number} limit - max # of items to return
     * @param {number} offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getSavedTracks",
    value: function () {
      var _getSavedTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var limit,
            offset,
            withUsers,
            _args8 = arguments;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                limit = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : 100;
                offset = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : 0;
                withUsers = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : false;
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context8.abrupt("return", this.discoveryProvider.getSavedTracks(limit, offset, withUsers));

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getSavedTracks() {
        return _getSavedTracks.apply(this, arguments);
      }

      return getSavedTracks;
    }()
    /**
     * Gets tracks trending on Audius.
     * @param {string} genre
     * @param {string} timeFrame one of day, week, month, or year
     * @param {?Array<number>} idsArray track ids
     * @param {?number} limit
     * @param {?number} offset
     * @returns {{listenCounts: Array<{trackId:number, listens:number}>}}
     */

  }, {
    key: "getTrendingTracks",
    value: function () {
      var _getTrendingTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var genre,
            time,
            idsArray,
            limit,
            offset,
            _args9 = arguments;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                genre = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : null;
                time = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : null;
                idsArray = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : null;
                limit = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : null;
                offset = _args9.length > 4 && _args9[4] !== undefined ? _args9[4] : null;
                this.REQUIRES(Services$3.IDENTITY_SERVICE);
                return _context9.abrupt("return", this.discoveryProvider.getTrendingTracks(genre, time, idsArray, limit, offset));

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getTrendingTracks() {
        return _getTrendingTracks.apply(this, arguments);
      }

      return getTrendingTracks;
    }()
    /**
     * Gets listens for tracks bucketted by timeFrame.
     * @param {string} timeFrame one of day, week, month, or year
     * @param {?Array<number>} idsArray track ids
     * @param {?string} startTime parseable by Date.parse
     * @param {?string} endTime parseable by Date.parse
     * @param {?number} limit
     * @param {?number} offset
     * @returns {{bucket:Array<{trackId:number, date:bucket, listens:number}>}}
      */

  }, {
    key: "getTrackListens",
    value: function () {
      var _getTrackListens = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var timeFrame,
            idsArray,
            startTime,
            endTime,
            limit,
            offset,
            _args10 = arguments;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                timeFrame = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : null;
                idsArray = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : null;
                startTime = _args10.length > 2 && _args10[2] !== undefined ? _args10[2] : null;
                endTime = _args10.length > 3 && _args10[3] !== undefined ? _args10[3] : null;
                limit = _args10.length > 4 && _args10[4] !== undefined ? _args10[4] : null;
                offset = _args10.length > 5 && _args10[5] !== undefined ? _args10[5] : null;
                this.REQUIRES(Services$3.IDENTITY_SERVICE);
                return _context10.abrupt("return", this.identityService.getTrackListens(timeFrame, idsArray, startTime, endTime, limit, offset));

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getTrackListens() {
        return _getTrackListens.apply(this, arguments);
      }

      return getTrackListens;
    }()
    /**
     * get users that saved saveTrackId, sorted by follower count descending
     * @param {number} saveTrackId
     * @return {Array} array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForTrack(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getSaversForTrack",
    value: function () {
      var _getSaversForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var limit,
            offset,
            saveTrackId,
            _args11 = arguments;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                limit = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : 100;
                offset = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : 0;
                saveTrackId = _args11.length > 2 ? _args11[2] : undefined;
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context11.abrupt("return", this.discoveryProvider.getSaversForTrack(limit, offset, saveTrackId));

              case 5:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getSaversForTrack() {
        return _getSaversForTrack.apply(this, arguments);
      }

      return getSaversForTrack;
    }()
    /**
     * get users that saved savePlaylistId, sorted by follower count descending
     * @param {number} savePlaylistId
     * @return {Array} array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getSaversForPlaylist(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getSaversForPlaylist",
    value: function () {
      var _getSaversForPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var limit,
            offset,
            savePlaylistId,
            _args12 = arguments;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                limit = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : 100;
                offset = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : 0;
                savePlaylistId = _args12.length > 2 ? _args12[2] : undefined;
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context12.abrupt("return", this.discoveryProvider.getSaversForPlaylist(limit, offset, savePlaylistId));

              case 5:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getSaversForPlaylist() {
        return _getSaversForPlaylist.apply(this, arguments);
      }

      return getSaversForPlaylist;
    }()
    /**
     * get users that reposted repostTrackId, sorted by follower count descending
     * @param {number} repostTrackId
     * @return {Array} array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForTrack(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getRepostersForTrack",
    value: function () {
      var _getRepostersForTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var limit,
            offset,
            repostTrackId,
            _args13 = arguments;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                limit = _args13.length > 0 && _args13[0] !== undefined ? _args13[0] : 100;
                offset = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : 0;
                repostTrackId = _args13.length > 2 ? _args13[2] : undefined;
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context13.abrupt("return", this.discoveryProvider.getRepostersForTrack(limit, offset, repostTrackId));

              case 5:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getRepostersForTrack() {
        return _getRepostersForTrack.apply(this, arguments);
      }

      return getRepostersForTrack;
    }()
    /**
     * get users that reposted repostPlaylistId, sorted by follower count descending
     * @param {number} repostPlaylistId
     * @return {Array} array of user objects
     * additional metadata fields on user objects:
     *  {Integer} follower_count - follower count of given user
     * @example
     * getRepostersForPlaylist(100, 0, 1) - ID must be valid
     */

  }, {
    key: "getRepostersForPlaylist",
    value: function () {
      var _getRepostersForPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var limit,
            offset,
            repostPlaylistId,
            _args14 = arguments;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                limit = _args14.length > 0 && _args14[0] !== undefined ? _args14[0] : 100;
                offset = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : 0;
                repostPlaylistId = _args14.length > 2 ? _args14[2] : undefined;
                this.REQUIRES(Services$3.DISCOVERY_PROVIDER);
                return _context14.abrupt("return", this.discoveryProvider.getRepostersForPlaylist(limit, offset, repostPlaylistId));

              case 5:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getRepostersForPlaylist() {
        return _getRepostersForPlaylist.apply(this, arguments);
      }

      return getRepostersForPlaylist;
    }()
    /**
     * Return saved tracks for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param {number} limit - max # of items to return
     * @param {number} offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getListenHistoryTracks",
    value: function () {
      var _getListenHistoryTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        var limit,
            offset,
            userId,
            _args15 = arguments;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                limit = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : 100;
                offset = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : 0;
                this.REQUIRES(Services$3.IDENTITY_SERVICE);
                userId = this.userStateManager.getCurrentUserId();
                return _context15.abrupt("return", this.identityService.getListenHistoryTracks(userId, limit, offset));

              case 5:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getListenHistoryTracks() {
        return _getListenHistoryTracks.apply(this, arguments);
      }

      return getListenHistoryTracks;
    }()
    /**
     * Checks if a download is available from provided creator node endpoints
     * @param {string} creatorNodeEndpoints creator node endpoints
     * @param {number} trackId
     */

  }, {
    key: "checkIfDownloadAvailable",
    value: function () {
      var _checkIfDownloadAvailable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(trackId, creatorNodeEndpoints) {
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                return _context16.abrupt("return", CreatorNode.checkIfDownloadAvailable(trackId, creatorNodeEndpoints));

              case 1:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16);
      }));

      function checkIfDownloadAvailable(_x11, _x12) {
        return _checkIfDownloadAvailable.apply(this, arguments);
      }

      return checkIfDownloadAvailable;
    }()
    /* ------- SETTERS ------- */

    /**
     * Takes in a readable stream if isServer is true, or a file reference if isServer is
     * false.
     * Uploads file, retrieves multihash, adds multihash to input metadata object,
     * uploads metadata, and finally returns metadata multihash
     * Wraps the stateless function in AudiusLib.
     *
     * @param {File} trackFile ReadableStream from server, or File handle on client
     * @param {File} coverArtFile ReadableStream from server, or File handle on client
     * @param {Object} metadata json of the track metadata with all fields, missing fields will error
     * @param {function} onProgress callback fired with (loaded, total) on byte upload progress
     */

  }, {
    key: "uploadTrack",
    value: function () {
      var _uploadTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(trackFile, coverArtFile, metadata, onProgress) {
        var _this2 = this;

        var phases, phase, ownerId, _yield$retry, metadataMultihash, metadataFileUUID, transcodedTrackUUID, transcodedTrackCID, multihashDecoded, _yield$this$contracts, txReceipt, trackId;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                this.REQUIRES(Services$3.CREATOR_NODE);
                this.FILE_IS_VALID(trackFile);
                phases = {
                  GETTING_USER: 'GETTING_USER',
                  UPLOADING_TRACK_CONTENT: 'UPLOADING_TRACK_CONTENT',
                  ADDING_TRACK: 'ADDING_TRACK',
                  ASSOCIATING_TRACK: 'ASSOCIATING_TRACK'
                };
                phase = phases.GETTING_USER;
                _context18.prev = 4;
                if (coverArtFile) this.FILE_IS_VALID(coverArtFile);
                this.IS_OBJECT(metadata);
                ownerId = this.userStateManager.getCurrentUserId();

                if (ownerId) {
                  _context18.next = 10;
                  break;
                }

                return _context18.abrupt("return", {
                  error: 'No users loaded for this wallet',
                  phase: phase
                });

              case 10:
                metadata.owner_id = ownerId;

                this._validateTrackMetadata(metadata);

                phase = phases.UPLOADING_TRACK_CONTENT; // Upload metadata

                _context18.next = 15;
                return retry$1( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(bail, num) {
                    return regeneratorRuntime.wrap(function _callee17$(_context17) {
                      while (1) {
                        switch (_context17.prev = _context17.next) {
                          case 0:
                            return _context17.abrupt("return", _this2.creatorNode.uploadTrackContent(trackFile, coverArtFile, metadata, onProgress));

                          case 1:
                          case "end":
                            return _context17.stop();
                        }
                      }
                    }, _callee17);
                  }));

                  return function (_x17, _x18) {
                    return _ref.apply(this, arguments);
                  };
                }(), {
                  // Retry function 3x
                  // 1st retry delay = 500ms, 2nd = 1500ms, 3rd...nth retry = 4000 ms (capped)
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: 3,
                  onRetry: function onRetry(err, i) {
                    if (err) {
                      console.log('uploadTrackContent retry error: ', err);
                    }
                  }
                });

              case 15:
                _yield$retry = _context18.sent;
                metadataMultihash = _yield$retry.metadataMultihash;
                metadataFileUUID = _yield$retry.metadataFileUUID;
                transcodedTrackUUID = _yield$retry.transcodedTrackUUID;
                transcodedTrackCID = _yield$retry.transcodedTrackCID;
                phase = phases.ADDING_TRACK; // Write metadata to chain

                multihashDecoded = Utils$2.decodeMultihash(metadataMultihash);
                _context18.next = 24;
                return this.contracts.TrackFactoryClient.addTrack(ownerId, multihashDecoded.digest, multihashDecoded.hashFn, multihashDecoded.size);

              case 24:
                _yield$this$contracts = _context18.sent;
                txReceipt = _yield$this$contracts.txReceipt;
                trackId = _yield$this$contracts.trackId;
                phase = phases.ASSOCIATING_TRACK; // Associate the track id with the file metadata and block number

                _context18.next = 30;
                return this.creatorNode.associateTrack(trackId, metadataFileUUID, txReceipt.blockNumber, transcodedTrackUUID);

              case 30:
                return _context18.abrupt("return", {
                  blockHash: txReceipt.blockHash,
                  blockNumber: txReceipt.blockNumber,
                  trackId: trackId,
                  transcodedTrackCID: transcodedTrackCID,
                  error: false
                });

              case 33:
                _context18.prev = 33;
                _context18.t0 = _context18["catch"](4);
                return _context18.abrupt("return", {
                  error: _context18.t0.message,
                  phase: phase
                });

              case 36:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this, [[4, 33]]);
      }));

      function uploadTrack(_x13, _x14, _x15, _x16) {
        return _uploadTrack.apply(this, arguments);
      }

      return uploadTrack;
    }()
    /**
     * Takes in a readable stream if isServer is true, or a file reference if isServer is
     * false.
     * WARNING: Uploads file to creator node, but does not call contracts
     * Please pair this with the addTracksToChainAndCnode
     */

  }, {
    key: "uploadTrackContentToCreatorNode",
    value: function () {
      var _uploadTrackContentToCreatorNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(trackFile, coverArtFile, metadata, onProgress) {
        var _this3 = this;

        var ownerId, _yield$retry2, metadataMultihash, metadataFileUUID, transcodedTrackCID, transcodedTrackUUID;

        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                this.REQUIRES(Services$3.CREATOR_NODE);
                this.FILE_IS_VALID(trackFile);
                if (coverArtFile) this.FILE_IS_VALID(coverArtFile);
                this.IS_OBJECT(metadata);
                ownerId = this.userStateManager.getCurrentUserId();

                if (ownerId) {
                  _context20.next = 7;
                  break;
                }

                throw new Error('No users loaded for this wallet');

              case 7:
                metadata.owner_id = ownerId;

                this._validateTrackMetadata(metadata); // Upload metadata


                _context20.next = 11;
                return retry$1( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(bail, num) {
                    return regeneratorRuntime.wrap(function _callee19$(_context19) {
                      while (1) {
                        switch (_context19.prev = _context19.next) {
                          case 0:
                            return _context19.abrupt("return", _this3.creatorNode.uploadTrackContent(trackFile, coverArtFile, metadata, onProgress));

                          case 1:
                          case "end":
                            return _context19.stop();
                        }
                      }
                    }, _callee19);
                  }));

                  return function (_x23, _x24) {
                    return _ref2.apply(this, arguments);
                  };
                }(), {
                  // Retry function 3x
                  // 1st retry delay = 500ms, 2nd = 1500ms, 3rd...nth retry = 4000 ms (capped)
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: 3,
                  onRetry: function onRetry(err, i) {
                    if (err) {
                      console.log('uploadTrackContentToCreatorNode retry error: ', err);
                    }
                  }
                });

              case 11:
                _yield$retry2 = _context20.sent;
                metadataMultihash = _yield$retry2.metadataMultihash;
                metadataFileUUID = _yield$retry2.metadataFileUUID;
                transcodedTrackCID = _yield$retry2.transcodedTrackCID;
                transcodedTrackUUID = _yield$retry2.transcodedTrackUUID;
                return _context20.abrupt("return", {
                  metadataMultihash: metadataMultihash,
                  metadataFileUUID: metadataFileUUID,
                  transcodedTrackCID: transcodedTrackCID,
                  transcodedTrackUUID: transcodedTrackUUID
                });

              case 17:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function uploadTrackContentToCreatorNode(_x19, _x20, _x21, _x22) {
        return _uploadTrackContentToCreatorNode.apply(this, arguments);
      }

      return uploadTrackContentToCreatorNode;
    }()
    /**
     * Takes an array of [{metadataMultihash, metadataFileUUID}, {}, ]
     * Adds tracks to chain for this user
     * Associates tracks with user on creatorNode
     */

  }, {
    key: "addTracksToChainAndCnode",
    value: function () {
      var _addTracksToChainAndCnode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(trackMultihashAndUUIDList) {
        var _this4 = this;

        var ownerId, addedToChain, requestFailed, associatedWithCreatorNode;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                this.REQUIRES(Services$3.CREATOR_NODE);
                ownerId = this.userStateManager.getCurrentUserId();

                if (ownerId) {
                  _context23.next = 4;
                  break;
                }

                throw new Error('No users loaded for this wallet');

              case 4:
                addedToChain = [];
                requestFailed = false;
                _context23.next = 8;
                return Promise.all(trackMultihashAndUUIDList.map( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(trackInfo, i) {
                    var metadataMultihash, metadataFileUUID, transcodedTrackUUID, multihashDecoded, _yield$_this4$contrac, txReceipt, trackId;

                    return regeneratorRuntime.wrap(function _callee21$(_context21) {
                      while (1) {
                        switch (_context21.prev = _context21.next) {
                          case 0:
                            _context21.prev = 0;
                            metadataMultihash = trackInfo.metadataMultihash, metadataFileUUID = trackInfo.metadataFileUUID, transcodedTrackUUID = trackInfo.transcodedTrackUUID; // Write metadata to chain

                            // Write metadata to chain
                            multihashDecoded = Utils$2.decodeMultihash(metadataMultihash);
                            _context21.next = 5;
                            return _this4.contracts.TrackFactoryClient.addTrack(ownerId, multihashDecoded.digest, multihashDecoded.hashFn, multihashDecoded.size);

                          case 5:
                            _yield$_this4$contrac = _context21.sent;
                            txReceipt = _yield$_this4$contrac.txReceipt;
                            trackId = _yield$_this4$contrac.trackId;
                            addedToChain[i] = {
                              trackId: trackId,
                              metadataFileUUID: metadataFileUUID,
                              transcodedTrackUUID: transcodedTrackUUID,
                              txReceipt: txReceipt
                            };
                            _context21.next = 15;
                            break;

                          case 11:
                            _context21.prev = 11;
                            _context21.t0 = _context21["catch"](0);
                            requestFailed = true;
                            console.error(_context21.t0);

                          case 15:
                          case "end":
                            return _context21.stop();
                        }
                      }
                    }, _callee21, null, [[0, 11]]);
                  }));

                  return function (_x26, _x27) {
                    return _ref3.apply(this, arguments);
                  };
                }()));

              case 8:
                if (!(requestFailed || addedToChain.filter(Boolean).length !== trackMultihashAndUUIDList.length)) {
                  _context23.next = 10;
                  break;
                }

                return _context23.abrupt("return", {
                  error: true,
                  trackIds: addedToChain.filter(Boolean).map(function (x) {
                    return x.trackId;
                  })
                });

              case 10:
                associatedWithCreatorNode = [];
                _context23.prev = 11;
                _context23.next = 14;
                return Promise.all(addedToChain.map( /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(chainTrackInfo) {
                    var metadataFileUUID, transcodedTrackUUID, trackId;
                    return regeneratorRuntime.wrap(function _callee22$(_context22) {
                      while (1) {
                        switch (_context22.prev = _context22.next) {
                          case 0:
                            metadataFileUUID = chainTrackInfo.metadataFileUUID;
                            transcodedTrackUUID = chainTrackInfo.transcodedTrackUUID;
                            trackId = chainTrackInfo.trackId;
                            _context22.next = 5;
                            return _this4.creatorNode.associateTrack(trackId, metadataFileUUID, chainTrackInfo.txReceipt.blockNumber, transcodedTrackUUID);

                          case 5:
                            associatedWithCreatorNode.push(trackId);

                          case 6:
                          case "end":
                            return _context22.stop();
                        }
                      }
                    }, _callee22);
                  }));

                  return function (_x28) {
                    return _ref4.apply(this, arguments);
                  };
                }()));

              case 14:
                _context23.next = 19;
                break;

              case 16:
                _context23.prev = 16;
                _context23.t0 = _context23["catch"](11);
                return _context23.abrupt("return", {
                  error: true,
                  trackIds: addedToChain.map(function (x) {
                    return x.trackId;
                  })
                });

              case 19:
                return _context23.abrupt("return", {
                  error: false,
                  trackIds: addedToChain.map(function (x) {
                    return x.trackId;
                  })
                });

              case 20:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this, [[11, 16]]);
      }));

      function addTracksToChainAndCnode(_x25) {
        return _addTracksToChainAndCnode.apply(this, arguments);
      }

      return addTracksToChainAndCnode;
    }()
    /**
     * Updates an existing track given metadata. This function expects that all associated files
     * such as track content, cover art are already on creator node.
     * @param {Object} metadata json of the track metadata with all fields, missing fields will error
     */

  }, {
    key: "updateTrack",
    value: function () {
      var _updateTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(metadata) {
        var ownerId, _yield$this$creatorNo, metadataMultihash, metadataFileUUID, multihashDecoded, trackId, _yield$this$contracts2, txReceipt;

        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                this.REQUIRES(Services$3.CREATOR_NODE);
                this.IS_OBJECT(metadata);
                ownerId = this.userStateManager.getCurrentUserId();

                if (ownerId) {
                  _context24.next = 5;
                  break;
                }

                throw new Error('No users loaded for this wallet');

              case 5:
                metadata.owner_id = ownerId;

                this._validateTrackMetadata(metadata); // Upload new metadata


                _context24.next = 9;
                return this.creatorNode.uploadTrackMetadata(metadata);

              case 9:
                _yield$this$creatorNo = _context24.sent;
                metadataMultihash = _yield$this$creatorNo.metadataMultihash;
                metadataFileUUID = _yield$this$creatorNo.metadataFileUUID;
                // Write the new metadata to chain
                multihashDecoded = Utils$2.decodeMultihash(metadataMultihash);
                trackId = metadata.track_id;
                _context24.next = 16;
                return this.contracts.TrackFactoryClient.updateTrack(trackId, ownerId, multihashDecoded.digest, multihashDecoded.hashFn, multihashDecoded.size);

              case 16:
                _yield$this$contracts2 = _context24.sent;
                txReceipt = _yield$this$contracts2.txReceipt;
                _context24.next = 20;
                return this.creatorNode.associateTrack(trackId, metadataFileUUID, txReceipt.blockNumber);

              case 20:
                return _context24.abrupt("return", {
                  blockHash: txReceipt.blockHash,
                  blockNumber: txReceipt.blockNumber,
                  trackId: trackId
                });

              case 21:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function updateTrack(_x29) {
        return _updateTrack.apply(this, arguments);
      }

      return updateTrack;
    }()
    /**
     * Logs a track listen for a given user id.
     * @param {string} unauthUuid account for those not logged in
     * @param {number} trackId listened to
     */

  }, {
    key: "logTrackListen",
    value: function () {
      var _logTrackListen = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(trackId, unauthUuid) {
        var solanaListen,
            accountId,
            userId,
            _args25 = arguments;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                solanaListen = _args25.length > 2 && _args25[2] !== undefined ? _args25[2] : false;
                this.REQUIRES(Services$3.IDENTITY_SERVICE);
                accountId = this.userStateManager.getCurrentUserId();
                userId = accountId || unauthUuid;
                return _context25.abrupt("return", this.identityService.logTrackListen(trackId, userId, null, null, solanaListen));

              case 5:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function logTrackListen(_x30, _x31) {
        return _logTrackListen.apply(this, arguments);
      }

      return logTrackListen;
    }()
    /** Adds a repost for a given user and track
    * @param {number} trackId track being reposted
    */

  }, {
    key: "addTrackRepost",
    value: function () {
      var _addTrackRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(trackId) {
        var userId;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                userId = this.userStateManager.getCurrentUserId();
                return _context26.abrupt("return", this.contracts.SocialFeatureFactoryClient.addTrackRepost(userId, trackId));

              case 2:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function addTrackRepost(_x32) {
        return _addTrackRepost.apply(this, arguments);
      }

      return addTrackRepost;
    }()
    /**
     * Deletes a repost for a given user and track
     * @param {number} track id of deleted repost
     */

  }, {
    key: "deleteTrackRepost",
    value: function () {
      var _deleteTrackRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(trackId) {
        var userId;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                userId = this.userStateManager.getCurrentUserId();
                return _context27.abrupt("return", this.contracts.SocialFeatureFactoryClient.deleteTrackRepost(userId, trackId));

              case 2:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function deleteTrackRepost(_x33) {
        return _deleteTrackRepost.apply(this, arguments);
      }

      return deleteTrackRepost;
    }()
    /**
     * Adds a track save for a given user and track
     * @param {number} trackId track being saved
     */

  }, {
    key: "addTrackSave",
    value: function () {
      var _addTrackSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(trackId) {
        var userId;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                userId = this.userStateManager.getCurrentUserId();
                return _context28.abrupt("return", this.contracts.UserLibraryFactoryClient.addTrackSave(userId, trackId));

              case 2:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function addTrackSave(_x34) {
        return _addTrackSave.apply(this, arguments);
      }

      return addTrackSave;
    }()
    /**
     * Delete a track save for a given user and track
     * @param {number} track save being removed
     */

  }, {
    key: "deleteTrackSave",
    value: function () {
      var _deleteTrackSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(trackId) {
        var userId;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                userId = this.userStateManager.getCurrentUserId();
                return _context29.abrupt("return", this.contracts.UserLibraryFactoryClient.deleteTrackSave(userId, trackId));

              case 2:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function deleteTrackSave(_x35) {
        return _deleteTrackSave.apply(this, arguments);
      }

      return deleteTrackSave;
    }()
    /**
     * Marks a tracks as deleted
     * @param {number} trackId
     */

  }, {
    key: "deleteTrack",
    value: function () {
      var _deleteTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(trackId) {
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                return _context30.abrupt("return", this.contracts.TrackFactoryClient.deleteTrack(trackId));

              case 1:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function deleteTrack(_x36) {
        return _deleteTrack.apply(this, arguments);
      }

      return deleteTrack;
    }()
    /* ------- PRIVATE  ------- */

  }, {
    key: "_validateTrackMetadata",
    value: function _validateTrackMetadata(metadata) {
      this.OBJECT_HAS_PROPS(metadata, TRACK_PROPS, TRACK_REQUIRED_PROPS);
    }
  }]);

  return Track;
}(Base$4);

var track = Track;

var Base$3 = base.Base,
    Services$2 = base.Services;
var Utils$1 = require$$18.Utils;
var MAX_PLAYLIST_LENGTH = 200;

var Playlists = /*#__PURE__*/function (_Base) {
  _inherits(Playlists, _Base);

  var _super = _createSuper(Playlists);

  function Playlists() {
    var _this;

    _classCallCheck(this, Playlists);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.getPlaylists = _this.getPlaylists.bind(_assertThisInitialized(_this));
    _this.getSavedPlaylists = _this.getSavedPlaylists.bind(_assertThisInitialized(_this));
    _this.getSavedAlbums = _this.getSavedAlbums.bind(_assertThisInitialized(_this));
    _this.createPlaylist = _this.createPlaylist.bind(_assertThisInitialized(_this));
    _this.addPlaylistTrack = _this.addPlaylistTrack.bind(_assertThisInitialized(_this));
    _this.orderPlaylistTracks = _this.orderPlaylistTracks.bind(_assertThisInitialized(_this));
    _this.validateTracksInPlaylist = _this.validateTracksInPlaylist.bind(_assertThisInitialized(_this));
    _this.uploadPlaylistCoverPhoto = _this.uploadPlaylistCoverPhoto.bind(_assertThisInitialized(_this));
    _this.updatePlaylistCoverPhoto = _this.updatePlaylistCoverPhoto.bind(_assertThisInitialized(_this));
    _this.updatePlaylistName = _this.updatePlaylistName.bind(_assertThisInitialized(_this));
    _this.updatePlaylistDescription = _this.updatePlaylistDescription.bind(_assertThisInitialized(_this));
    _this.updatePlaylistPrivacy = _this.updatePlaylistPrivacy.bind(_assertThisInitialized(_this));
    _this.addPlaylistRepost = _this.addPlaylistRepost.bind(_assertThisInitialized(_this));
    _this.deletePlaylistRepost = _this.deletePlaylistRepost.bind(_assertThisInitialized(_this));
    _this.deletePlaylistTrack = _this.deletePlaylistTrack.bind(_assertThisInitialized(_this));
    _this.addPlaylistSave = _this.addPlaylistSave.bind(_assertThisInitialized(_this));
    _this.deletePlaylistSave = _this.deletePlaylistSave.bind(_assertThisInitialized(_this));
    _this.deletePlaylist = _this.deletePlaylist.bind(_assertThisInitialized(_this));
    return _this;
  }
  /* ------- GETTERS ------- */

  /**
   * get full playlist objects, including tracks, for passed in array of playlistId
   * @param {number} limit max # of items to return
   * @param {number} offset offset into list to return from (for pagination)
   * @param {Array} idsArray list of playlist ids
   * @param {number} targetUserId the user whose playlists we're trying to get
   * @param {boolean} withUsers whether to return users nested within the collection objects
   * @returns {Array} array of playlist objects
   * additional metadata fields on playlist objects:
   *  {Integer} repost_count - repost count for given playlist
   *  {Integer} save_count - save count for given playlist
   *  {Boolean} has_current_user_reposted - has current user reposted given playlist
   *  {Array} followee_reposts - followees of current user that have reposted given playlist
   *  {Boolean} has_current_user_reposted - has current user reposted given playlist
   *  {Boolean} has_current_user_saved - has current user saved given playlist
   */


  _createClass(Playlists, [{
    key: "getPlaylists",
    value: function () {
      var _getPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var limit,
            offset,
            idsArray,
            targetUserId,
            withUsers,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                limit = _args.length > 0 && _args[0] !== undefined ? _args[0] : 100;
                offset = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;
                idsArray = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;
                targetUserId = _args.length > 3 && _args[3] !== undefined ? _args[3] : null;
                withUsers = _args.length > 4 && _args[4] !== undefined ? _args[4] : false;
                this.REQUIRES(Services$2.DISCOVERY_PROVIDER);
                return _context.abrupt("return", this.discoveryProvider.getPlaylists(limit, offset, idsArray, targetUserId, withUsers));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getPlaylists() {
        return _getPlaylists.apply(this, arguments);
      }

      return getPlaylists;
    }()
    /**
     * Return saved playlists for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param {number} limit - max # of items to return
     * @param {number} offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getSavedPlaylists",
    value: function () {
      var _getSavedPlaylists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var limit,
            offset,
            withUsers,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                limit = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 100;
                offset = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;
                withUsers = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false;
                this.REQUIRES(Services$2.DISCOVERY_PROVIDER);
                return _context2.abrupt("return", this.discoveryProvider.getSavedPlaylists(limit, offset, withUsers));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getSavedPlaylists() {
        return _getSavedPlaylists.apply(this, arguments);
      }

      return getSavedPlaylists;
    }()
    /**
     * Return saved albums for current user
     * NOTE in returned JSON, SaveType string one of track, playlist, album
     * @param {number} limit - max # of items to return
     * @param {number} offset - offset into list to return from (for pagination)
     */

  }, {
    key: "getSavedAlbums",
    value: function () {
      var _getSavedAlbums = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var limit,
            offset,
            withUsers,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                limit = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 100;
                offset = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;
                withUsers = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : false;
                this.REQUIRES(Services$2.DISCOVERY_PROVIDER);
                return _context3.abrupt("return", this.discoveryProvider.getSavedAlbums(limit, offset, withUsers));

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getSavedAlbums() {
        return _getSavedAlbums.apply(this, arguments);
      }

      return getSavedAlbums;
    }()
    /* ------- SETTERS ------- */

    /**
     * Creates a new playlist
     * @param {number} userId
     * @param {string} playlistName
     * @param {boolean} isPrivate
     * @param {boolean} isAlbum
     * @param {Array<number>} trackIds
     */

  }, {
    key: "createPlaylist",
    value: function () {
      var _createPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(userId, playlistName, isPrivate, isAlbum, trackIds) {
        var _this2 = this;

        var maxInitialTracks, createInitialIdsArray, postInitialIdsArray, playlistId, receipt, response;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                maxInitialTracks = 50;
                createInitialIdsArray = trackIds.slice(0, maxInitialTracks);
                postInitialIdsArray = trackIds.slice(maxInitialTracks);
                receipt = {};
                _context4.prev = 4;
                _context4.next = 7;
                return this.contracts.PlaylistFactoryClient.createPlaylist(userId, playlistName, isPrivate, isAlbum, createInitialIdsArray);

              case 7:
                response = _context4.sent;
                playlistId = response.playlistId;
                receipt = response.txReceipt; // Add remaining tracks

                _context4.next = 12;
                return Promise.all(postInitialIdsArray.map(function (trackId) {
                  return _this2.contracts.PlaylistFactoryClient.addPlaylistTrack(playlistId, trackId);
                }));

              case 12:
                if (!(postInitialIdsArray.length > 0)) {
                  _context4.next = 16;
                  break;
                }

                _context4.next = 15;
                return this.contracts.PlaylistFactoryClient.orderPlaylistTracks(playlistId, trackIds);

              case 15:
                receipt = _context4.sent;

              case 16:
                _context4.next = 23;
                break;

              case 18:
                _context4.prev = 18;
                _context4.t0 = _context4["catch"](4);
                console.debug("Reached libs createPlaylist catch block with playlist id ".concat(playlistId));
                console.error(_context4.t0);
                return _context4.abrupt("return", {
                  playlistId: playlistId,
                  error: true
                });

              case 23:
                return _context4.abrupt("return", {
                  blockHash: receipt.blockHash,
                  blockNumber: receipt.blockNumber,
                  playlistId: playlistId,
                  error: false
                });

              case 24:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[4, 18]]);
      }));

      function createPlaylist(_x, _x2, _x3, _x4, _x5) {
        return _createPlaylist.apply(this, arguments);
      }

      return createPlaylist;
    }()
    /**
     * Adds a track to a given playlist
     * @param {number} playlistId
     * @param {number} trackId
     */

  }, {
    key: "addPlaylistTrack",
    value: function () {
      var _addPlaylistTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(playlistId, trackId) {
        var userId, playlist;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.REQUIRES(Services$2.DISCOVERY_PROVIDER);
                userId = this.userStateManager.getCurrentUserId();
                _context5.next = 4;
                return this.discoveryProvider.getPlaylists(100, 0, [playlistId], userId);

              case 4:
                playlist = _context5.sent;

                if (!(!Array.isArray(playlist) || !playlist.length)) {
                  _context5.next = 7;
                  break;
                }

                throw new Error('Cannot add track - Playlist does not exist or has not yet been indexed by discovery provider');

              case 7:
                if (!(playlist[0].playlist_contents.track_ids.length >= MAX_PLAYLIST_LENGTH)) {
                  _context5.next = 9;
                  break;
                }

                throw new Error("Cannot add track - playlist is already at max length of ".concat(MAX_PLAYLIST_LENGTH));

              case 9:
                return _context5.abrupt("return", this.contracts.PlaylistFactoryClient.addPlaylistTrack(playlistId, trackId));

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function addPlaylistTrack(_x6, _x7) {
        return _addPlaylistTrack.apply(this, arguments);
      }

      return addPlaylistTrack;
    }()
    /**
     * Reorders the tracks in a playlist
     * @param {number} playlistId
     * @param {Array<number>} trackIds
     * @param {number?} retriesOverride [Optional, defaults to web3Manager.sendTransaction retries default]
     */

  }, {
    key: "orderPlaylistTracks",
    value: function () {
      var _orderPlaylistTracks = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(playlistId, trackIds, retriesOverride) {
        var userId, playlist, playlistTrackIds, trackIdsSorted, playlistTrackIdsSorted, i;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this.REQUIRES(Services$2.DISCOVERY_PROVIDER);

                if (Array.isArray(trackIds)) {
                  _context6.next = 3;
                  break;
                }

                throw new Error('Cannot order playlist - trackIds must be array');

              case 3:
                userId = this.userStateManager.getCurrentUserId();
                _context6.next = 6;
                return this.discoveryProvider.getPlaylists(100, 0, [playlistId], userId);

              case 6:
                playlist = _context6.sent;

                if (!(!Array.isArray(playlist) || !playlist.length)) {
                  _context6.next = 9;
                  break;
                }

                throw new Error('Cannot order playlist - Playlist does not exist or has not yet been indexed by discovery provider');

              case 9:
                playlistTrackIds = playlist[0].playlist_contents.track_ids.map(function (a) {
                  return a.track;
                }); // error if trackIds arg array length does not match playlist length

                if (!(trackIds.length !== playlistTrackIds.length)) {
                  _context6.next = 12;
                  break;
                }

                throw new Error('Cannot order playlist - trackIds length must match playlist length');

              case 12:
                // ensure existing playlist tracks and trackIds have same content, regardless of order
                trackIdsSorted = _toConsumableArray(trackIds).sort();
                playlistTrackIdsSorted = playlistTrackIds.sort();
                i = 0;

              case 15:
                if (!(i < trackIdsSorted.length)) {
                  _context6.next = 21;
                  break;
                }

                if (!(trackIdsSorted[i] !== playlistTrackIdsSorted[i])) {
                  _context6.next = 18;
                  break;
                }

                throw new Error('Cannot order playlist - trackIds must have same content as playlist tracks');

              case 18:
                i++;
                _context6.next = 15;
                break;

              case 21:
                return _context6.abrupt("return", this.contracts.PlaylistFactoryClient.orderPlaylistTracks(playlistId, trackIds, retriesOverride));

              case 22:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function orderPlaylistTracks(_x8, _x9, _x10) {
        return _orderPlaylistTracks.apply(this, arguments);
      }

      return orderPlaylistTracks;
    }()
    /**
     * Checks if a playlist has entered a corrupted state
     * Check that each of the tracks within a playlist retrieved from discprov are in the onchain playlist
     * Note: the onchain playlists stores the tracks as a mapping of track ID to track count and the
     * track order is an event that is indexed by discprov. The track order event does not validate that the
     * updated order of tracks has the correct track count, so a track order event w/ duplicate tracks can
     * lead the playlist entering a corrupted state.
     * @param {number} playlistId
     */

  }, {
    key: "validateTracksInPlaylist",
    value: function () {
      var _validateTracksInPlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(playlistId) {
        var userId, playlistsReponse, playlist, playlistTrackIds, invalidTrackIds, _iterator, _step, trackId, trackInPlaylist;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this.REQUIRES(Services$2.DISCOVERY_PROVIDER, Services$2.CREATOR_NODE);
                userId = this.userStateManager.getCurrentUserId();
                _context7.next = 4;
                return this.discoveryProvider.getPlaylists(1, 0, [playlistId], userId);

              case 4:
                playlistsReponse = _context7.sent;

                if (!(!Array.isArray(playlistsReponse) || !playlistsReponse.length)) {
                  _context7.next = 7;
                  break;
                }

                throw new Error('Cannot validate playlist - Playlist does not exist, is private and not owned by current user or has not yet been indexed by discovery provider');

              case 7:
                playlist = playlistsReponse[0];
                playlistTrackIds = playlist.playlist_contents.track_ids.map(function (a) {
                  return a.track;
                }); // Check if each track is in the playlist

                invalidTrackIds = [];
                _iterator = _createForOfIteratorHelper(playlistTrackIds);
                _context7.prev = 11;

                _iterator.s();

              case 13:
                if ((_step = _iterator.n()).done) {
                  _context7.next = 21;
                  break;
                }

                trackId = _step.value;
                _context7.next = 17;
                return this.contracts.PlaylistFactoryClient.isTrackInPlaylist(playlistId, trackId);

              case 17:
                trackInPlaylist = _context7.sent;
                if (!trackInPlaylist) invalidTrackIds.push(trackId);

              case 19:
                _context7.next = 13;
                break;

              case 21:
                _context7.next = 26;
                break;

              case 23:
                _context7.prev = 23;
                _context7.t0 = _context7["catch"](11);

                _iterator.e(_context7.t0);

              case 26:
                _context7.prev = 26;

                _iterator.f();

                return _context7.finish(26);

              case 29:
                return _context7.abrupt("return", {
                  isValid: invalidTrackIds.length === 0,
                  invalidTrackIds: invalidTrackIds
                });

              case 30:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[11, 23, 26, 29]]);
      }));

      function validateTracksInPlaylist(_x11) {
        return _validateTracksInPlaylist.apply(this, arguments);
      }

      return validateTracksInPlaylist;
    }()
    /**
     * Uploads a cover photo for a playlist without updating the actual playlist
     * @param {File} coverPhotoFile the file to upload as the cover photo
     * @return {string} CID of the uploaded cover photo
     */

  }, {
    key: "uploadPlaylistCoverPhoto",
    value: function () {
      var _uploadPlaylistCoverPhoto = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(coverPhotoFile) {
        var updatedPlaylistImage;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this.REQUIRES(Services$2.CREATOR_NODE);
                _context8.next = 3;
                return this.creatorNode.uploadImage(coverPhotoFile, true // square
                );

              case 3:
                updatedPlaylistImage = _context8.sent;
                return _context8.abrupt("return", updatedPlaylistImage.dirCID);

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function uploadPlaylistCoverPhoto(_x12) {
        return _uploadPlaylistCoverPhoto.apply(this, arguments);
      }

      return uploadPlaylistCoverPhoto;
    }()
    /**
     * Updates the cover photo for a playlist
     * @param {number} playlistId
     * @param {File} coverPhoto
     */

  }, {
    key: "updatePlaylistCoverPhoto",
    value: function () {
      var _updatePlaylistCoverPhoto = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(playlistId, coverPhoto) {
        var updatedPlaylistImageDirCid;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this.REQUIRES(Services$2.CREATOR_NODE);
                _context9.next = 3;
                return this.uploadPlaylistCoverPhoto(coverPhoto, true);

              case 3:
                updatedPlaylistImageDirCid = _context9.sent;
                return _context9.abrupt("return", this.contracts.PlaylistFactoryClient.updatePlaylistCoverPhoto(playlistId, Utils$1.formatOptionalMultihash(updatedPlaylistImageDirCid)));

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function updatePlaylistCoverPhoto(_x13, _x14) {
        return _updatePlaylistCoverPhoto.apply(this, arguments);
      }

      return updatePlaylistCoverPhoto;
    }()
    /**
     * Updates a playlist name
     * @param {number} playlistId
     * @param {string} playlistName
     */

  }, {
    key: "updatePlaylistName",
    value: function () {
      var _updatePlaylistName = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(playlistId, playlistName) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", this.contracts.PlaylistFactoryClient.updatePlaylistName(playlistId, playlistName));

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function updatePlaylistName(_x15, _x16) {
        return _updatePlaylistName.apply(this, arguments);
      }

      return updatePlaylistName;
    }()
    /**
     * Updates a playlist description
     * @param {number} playlistId
     * @param {string} updatedPlaylistDescription
     */

  }, {
    key: "updatePlaylistDescription",
    value: function () {
      var _updatePlaylistDescription = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(playlistId, updatedPlaylistDescription) {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                return _context11.abrupt("return", this.contracts.PlaylistFactoryClient.updatePlaylistDescription(playlistId, updatedPlaylistDescription));

              case 1:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function updatePlaylistDescription(_x17, _x18) {
        return _updatePlaylistDescription.apply(this, arguments);
      }

      return updatePlaylistDescription;
    }()
    /**
     * Updates whether a playlist is public or private
     * @param {number} playlistId
     * @param {boolean} updatedPlaylistPrivacy
     */

  }, {
    key: "updatePlaylistPrivacy",
    value: function () {
      var _updatePlaylistPrivacy = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(playlistId, updatedPlaylistPrivacy) {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                return _context12.abrupt("return", this.contracts.PlaylistFactoryClient.updatePlaylistPrivacy(playlistId, updatedPlaylistPrivacy));

              case 1:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function updatePlaylistPrivacy(_x19, _x20) {
        return _updatePlaylistPrivacy.apply(this, arguments);
      }

      return updatePlaylistPrivacy;
    }()
    /**
     * Reposts a playlist for a user
     * @param {number} userId
     * @param {number} playlistId
     */

  }, {
    key: "addPlaylistRepost",
    value: function () {
      var _addPlaylistRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(playlistId) {
        var userId;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                userId = this.userStateManager.getCurrentUserId();
                return _context13.abrupt("return", this.contracts.SocialFeatureFactoryClient.addPlaylistRepost(userId, playlistId));

              case 2:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function addPlaylistRepost(_x21) {
        return _addPlaylistRepost.apply(this, arguments);
      }

      return addPlaylistRepost;
    }()
    /**
     * Undoes a repost on a playlist for a user
     * @param {number} userId
     * @param {number} playlistId
     */

  }, {
    key: "deletePlaylistRepost",
    value: function () {
      var _deletePlaylistRepost = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(playlistId) {
        var userId;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                userId = this.userStateManager.getCurrentUserId();
                return _context14.abrupt("return", this.contracts.SocialFeatureFactoryClient.deletePlaylistRepost(userId, playlistId));

              case 2:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function deletePlaylistRepost(_x22) {
        return _deletePlaylistRepost.apply(this, arguments);
      }

      return deletePlaylistRepost;
    }()
    /**
     * Marks a track to be deleted from a playlist. The playlist entry matching
     * the provided timestamp is deleted in the case of duplicates.
     * @param {number} playlistId
     * @param {number} deletedTrackId
     * @param {string} deletedPlaylistTimestamp parseable timestamp (to be copied from playlist metadata)
     * @param {number?} retriesOverride [Optional, defaults to web3Manager.sendTransaction retries default]
     */

  }, {
    key: "deletePlaylistTrack",
    value: function () {
      var _deletePlaylistTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(playlistId, deletedTrackId, deletedPlaylistTimestamp, retriesOverride) {
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                return _context15.abrupt("return", this.contracts.PlaylistFactoryClient.deletePlaylistTrack(playlistId, deletedTrackId, deletedPlaylistTimestamp, retriesOverride));

              case 1:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function deletePlaylistTrack(_x23, _x24, _x25, _x26) {
        return _deletePlaylistTrack.apply(this, arguments);
      }

      return deletePlaylistTrack;
    }()
    /**
     * Saves a playlist on behalf of a user
     * @param {number} userId
     * @param {number} playlistId
     */

  }, {
    key: "addPlaylistSave",
    value: function () {
      var _addPlaylistSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(playlistId) {
        var userId;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                userId = this.userStateManager.getCurrentUserId();
                return _context16.abrupt("return", this.contracts.UserLibraryFactoryClient.addPlaylistSave(userId, playlistId));

              case 2:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function addPlaylistSave(_x27) {
        return _addPlaylistSave.apply(this, arguments);
      }

      return addPlaylistSave;
    }()
    /**
     * Unsaves a playlist on behalf of a user
     * @param {number} userId
     * @param {number} playlistId
     */

  }, {
    key: "deletePlaylistSave",
    value: function () {
      var _deletePlaylistSave = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(playlistId) {
        var userId;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                userId = this.userStateManager.getCurrentUserId();
                return _context17.abrupt("return", this.contracts.UserLibraryFactoryClient.deletePlaylistSave(userId, playlistId));

              case 2:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function deletePlaylistSave(_x28) {
        return _deletePlaylistSave.apply(this, arguments);
      }

      return deletePlaylistSave;
    }()
    /**
     * Marks a playlist as deleted
     * @param {number} playlistId
     */

  }, {
    key: "deletePlaylist",
    value: function () {
      var _deletePlaylist = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(playlistId) {
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                return _context18.abrupt("return", this.contracts.PlaylistFactoryClient.deletePlaylist(playlistId));

              case 1:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function deletePlaylist(_x29) {
        return _deletePlaylist.apply(this, arguments);
      }

      return deletePlaylist;
    }()
  }]);

  return Playlists;
}(Base$3);

var playlist = Playlists;

var require$$2 = /*@__PURE__*/getAugmentedNamespace(network);

var urlJoin = urlJoin__default["default"];
if (urlJoin && urlJoin["default"]) urlJoin = urlJoin["default"];
var axios$1 = axios__default["default"];
var Base$2 = base.Base,
    Services$1 = base.Services;
var raceRequests = require$$2.raceRequests;
var retry = retry__default["default"];
/**
 * Downloads a file using an element in the DOM
 * @param {*} url
 * @param {*} filename
 */

var downloadURL = function downloadURL(url, filename) {
  if (document) {
    var link = document.createElement('a');
    link.href = url;
    link.target = '_blank';
    link.download = filename;
    link.click();
    return;
  }

  throw new Error('No body document found');
};

var File = /*#__PURE__*/function (_Base) {
  _inherits(File, _Base);

  var _super = _createSuper(File);

  function File(user) {
    var _this;

    _classCallCheck(this, File);

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.User = user;
    return _this;
  }
  /**
   * Fetches a file from Content Node with a given CID.
   * @param {string} cid IPFS content identifier
   * @param {Array<string>} creatorNodeGateways Content Node gateways to fetch content from
   * @param {?function} callback callback called on each successful/failed fetch with
   *  [String, Bool](gateway, succeeded)
   *  Can be used for tracking metrics on which gateways were used.
   */


  _createClass(File, [{
    key: "fetchCID",
    value: function () {
      var _fetchCID = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(cid, creatorNodeGateways) {
        var callback,
            responseType,
            trackId,
            urls,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                callback = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : null;
                responseType = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 'blob';
                trackId = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : null;
                urls = [];
                creatorNodeGateways.forEach(function (gateway) {
                  var gatewayWithCid = urlJoin(gateway, cid);
                  if (trackId) gatewayWithCid = urlJoin(gatewayWithCid, {
                    query: {
                      trackId: trackId
                    }
                  });
                  urls.push(gatewayWithCid);
                });
                return _context2.abrupt("return", retry( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(bail) {
                    var _yield$raceRequests, response, errored, allUnauthorized, legacyUrls, _yield$raceRequests2, _response;

                    return regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.prev = 0;
                            _context.next = 3;
                            return raceRequests(urls, callback, {
                              method: 'get',
                              responseType: responseType
                            },
                            /* timeout */
                            null);

                          case 3:
                            _yield$raceRequests = _context.sent;
                            response = _yield$raceRequests.response;
                            errored = _yield$raceRequests.errored;

                            if (response) {
                              _context.next = 12;
                              break;
                            }

                            allUnauthorized = errored.every(function (error) {
                              return error.response.status === 403;
                            });

                            if (!allUnauthorized) {
                              _context.next = 11;
                              break;
                            }

                            // In the case for a 403, do not retry fetching
                            bail(new Error('Unauthorized'));
                            return _context.abrupt("return");

                          case 11:
                            throw new Error("Could not fetch ".concat(cid));

                          case 12:
                            return _context.abrupt("return", response);

                          case 15:
                            _context.prev = 15;
                            _context.t0 = _context["catch"](0);

                            if (!cid.includes('/')) {
                              _context.next = 33;
                              break;
                            }

                            // dirCID -- an image
                            console.debug("Attempted to fetch image ".concat(cid, " via legacy method")); // Try legacy image format
                            // Lop off anything like /480x480.jpg in the CID

                            // Try legacy image format
                            // Lop off anything like /480x480.jpg in the CID
                            legacyUrls = creatorNodeGateways.map(function (gateway) {
                              return urlJoin(gateway, cid.split('/')[0]);
                            });
                            _context.prev = 20;
                            _context.next = 23;
                            return raceRequests(legacyUrls, callback, {
                              method: 'get',
                              responseType: responseType
                            },
                            /* timeout */
                            null);

                          case 23:
                            _yield$raceRequests2 = _context.sent;
                            _response = _yield$raceRequests2.response;

                            if (_response) {
                              _context.next = 27;
                              break;
                            }

                            throw new Error("Could not fetch ".concat(cid, " via legacy method"));

                          case 27:
                            return _context.abrupt("return", _response);

                          case 30:
                            _context.prev = 30;
                            _context.t1 = _context["catch"](20);
                            throw new Error("Failed to retrieve ".concat(cid, " by legacy method"));

                          case 33:
                            throw new Error("Failed to retrieve ".concat(cid));

                          case 34:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee, null, [[0, 15], [20, 30]]);
                  }));

                  return function (_x3) {
                    return _ref.apply(this, arguments);
                  };
                }(), {
                  minTimeout: 500,
                  maxTimeout: 4000,
                  factor: 3,
                  retries: 5,
                  onRetry: function onRetry(err, i) {
                    // eslint-disable-next-line no-console
                    console.log("FetchCID attempt ".concat(i, " error: ").concat(err));
                  }
                }));

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function fetchCID(_x, _x2) {
        return _fetchCID.apply(this, arguments);
      }

      return fetchCID;
    }()
    /**
     * Fetches a file from Content Node with a given CID. Follows the same pattern
     * as fetchCID, but resolves with a download of the file rather than
     * returning the response content.
     * @param {string} cid IPFS content identifier
     * @param {Array<string>} creatorNodeGateways Content Node gateways to fetch content from
     * @param {string?} filename optional filename for the download
     */

  }, {
    key: "downloadCID",
    value: function () {
      var _downloadCID = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(cid, creatorNodeGateways, filename) {
        var urls, _yield$raceRequests3, response;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                urls = creatorNodeGateways.map(function (gateway) {
                  return urlJoin(gateway, cid, {
                    query: {
                      filename: filename
                    }
                  });
                });
                _context3.prev = 1;
                _context3.next = 4;
                return raceRequests(urls, function (url) {
                  return downloadURL(url, filename);
                }, {
                  method: 'head'
                },
                /* timeout */
                10000);

              case 4:
                _yield$raceRequests3 = _context3.sent;
                response = _yield$raceRequests3.response;
                return _context3.abrupt("return", response);

              case 9:
                _context3.prev = 9;
                _context3.t0 = _context3["catch"](1);
                throw new Error("Failed to retrieve ".concat(cid));

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[1, 9]]);
      }));

      function downloadCID(_x4, _x5, _x6) {
        return _downloadCID.apply(this, arguments);
      }

      return downloadCID;
    }()
    /**
     * Checks if a CID exists on a Content Node.
     * @param {string} cid IPFS content identifier
     * @param {Array<string>} creatorNodeGateways Content Node gateways to fetch content from
     * Eg. creatorNodeGateways = ["https://creatornode.audius.co/ipfs/", "https://creatornode2.audius.co/ipfs/"]
     */

  }, {
    key: "checkIfCidAvailable",
    value: function () {
      var _checkIfCidAvailable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(cid, creatorNodeGateways) {
        var exists;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                exists = {};
                _context5.next = 3;
                return Promise.all(creatorNodeGateways.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(gateway) {
                    var _yield$axios, status;

                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.prev = 0;
                            _context4.next = 3;
                            return axios$1({
                              url: urlJoin(gateway, cid),
                              method: 'head'
                            });

                          case 3:
                            _yield$axios = _context4.sent;
                            status = _yield$axios.status;
                            exists[gateway] = status === 200;
                            _context4.next = 11;
                            break;

                          case 8:
                            _context4.prev = 8;
                            _context4.t0 = _context4["catch"](0);
                            exists[gateway] = false;

                          case 11:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4, null, [[0, 8]]);
                  }));

                  return function (_x9) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 3:
                return _context5.abrupt("return", exists);

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function checkIfCidAvailable(_x7, _x8) {
        return _checkIfCidAvailable.apply(this, arguments);
      }

      return checkIfCidAvailable;
    }()
    /**
     * Uploads an image to the connected Content Node.
     * @param {File} file
     */

  }, {
    key: "uploadImage",
    value: function () {
      var _uploadImage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(file, square) {
        var timeoutMs,
            resp,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                timeoutMs = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : null;
                this.REQUIRES(Services$1.CREATOR_NODE);
                this.FILE_IS_VALID(file); // Assign a creator_node_endpoint to the user if necessary

                _context6.next = 5;
                return this.User.assignReplicaSetIfNecessary();

              case 5:
                _context6.next = 7;
                return this.creatorNode.uploadImage(file, square,
                /* onProgress */
                undefined, timeoutMs);

              case 7:
                resp = _context6.sent;
                return _context6.abrupt("return", resp);

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function uploadImage(_x10, _x11) {
        return _uploadImage.apply(this, arguments);
      }

      return uploadImage;
    }()
  }]);

  return File;
}(Base$2);

var file = File;

var rewards = createModule("/$$rollup_base$$/src/api");

var require$$6 = /*@__PURE__*/getAugmentedNamespace(utils$2);

var axios = axios__default["default"];
var sampleSize$1 = require$$0__default$3["default"].sampleSize;
var Base$1 = base.Base,
    Services = base.Services;
var BN = bn.exports;
var RewardsManagerError = errors.RewardsManagerError;
var WAUDIO_DECMIALS = require$$5.WAUDIO_DECMIALS;
var Utils = require$$6.Utils;
var decodeHashId$1 = Utils.decodeHashId;
var GetAttestationError = Object.freeze({
  CHALLENGE_INCOMPLETE: 'CHALLENGE_INCOMPLETE',
  ALREADY_DISBURSED: 'ALREADY_DISBURSED',
  INVALID_ORACLE: 'INVALID_ORACLE',
  MISSING_CHALLENGES: 'MISSING_CHALLENGES',
  INVALID_INPUT: 'INVALID_INPUT',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  HCAPTCHA: 'HCAPTCHA',
  COGNITO_FLOW: 'COGNITO_FLOW',
  DISCOVERY_NODE_ATTESTATION_ERROR: 'DISCOVERY_NODE_ATTESTATION_ERROR',
  DISCOVERY_NODE_UNKNOWN_RESPONSE: 'DISCOVERY_NODE_UNKNOWN_RESPONSE',
  AAO_ATTESTATION_ERROR: 'AAO_ATTESTATION_ERROR',
  AAO_ATTESTATION_REJECTION: 'AAO_ATTESTATION_REJECTION',
  AAO_ATTESTATION_UNKNOWN_RESPONSE: 'AAO_ATTESTATION_UNKNOWN_RESPONSE',
  UNKNOWN_ERROR: 'UNKNOWN_ERROR'
});
var AggregateAttestationError = Object.freeze({
  INSUFFICIENT_DISCOVERY_NODE_COUNT: 'INSUFFICIENT_DISCOVERY_NODE_COUNT',
  UNKNOWN_ERROR: 'UNKNOWN_ERROR'
});
var GetSenderAttestationError = Object.freeze({
  REQUEST_FOR_ATTESTATION_FAILED: 'REQUEST_FOR_ATTESTATION_FAILED'
});
/**
 * Combined error type for `SubmitAndEvaluate`
 */

var SubmitAndEvaluateError = Object.freeze(_objectSpread2(_objectSpread2(_objectSpread2({}, GetAttestationError), AggregateAttestationError), RewardsManagerError));
var AttestationPhases = Object.freeze({
  SANITY_CHECKS: 'SANITY_CHECKS',
  AGGREGATE_ATTESTATIONS: 'AGGREGATE_ATTESTATIONS',
  SUBMIT_ATTESTATIONS: 'SUBMIT_ATTESTATIONS',
  EVALUATE_ATTESTATIONS: 'EVALUATE_ATTESTATIONS'
});
var AAO_REQUEST_TIMEOUT_MS = 15 * 1000;
var WRAPPED_AUDIO_PRECISION = Math.pow(10, WAUDIO_DECMIALS);
/**
 * @typedef {import("../services/solanaWeb3Manager/rewards.js").AttestationMeta} AttestationMeta
 */

var Rewards = /*#__PURE__*/function (_Base) {
  _inherits(Rewards, _Base);

  var _super = _createSuper(Rewards);

  function Rewards(ServiceProvider) {
    var _this;

    _classCallCheck(this, Rewards);

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.ServiceProvider = ServiceProvider;
    return _this;
  }
  /**
   *
   * Top level method to aggregate attestations, submit them to RewardsManager, and evalute the result.
   *
   * @typedef {Object} GetSubmitAndEvaluateAttestationsReturn
   * @property {Boolean} success
   * @property {GetAttestationError} error
   *
   * @param {{
   *   challengeId: string,
   *   encodedUserId: string,
   *   handle: string,
   *   recipientEthAddress: string,
   *   specifier: string,
   *   oracleEthAddress: string,
   *   amount: number,
   *   quorumSize: number,
   *   AAOEndpoint: string,
   *   endpoints: Array<string>,
   *   instructionsPerTransaction?: number,
   *   maxAggregationAttempts?: number
   *   logger: any
   *   feePayerOverride: string | null
   * }} {
   *   challengeId,
   *   encodedUserId,
   *   handle,
   *   recipientEthAddress,
   *   specifier,
   *   oracleEthAddress,
   *   amount,
   *   quorumSize,
   *   AAOEndpoint,
   *   endpoints,
   *   maxAggregationAttempts,
   *   instructionsPerTransaction,
   *   logger,
   *   feePayerOverride
   * }
   * @returns {Promise<GetSubmitAndEvaluateAttestationsReturn>}
   * @memberof Challenge
   */


  _createClass(Rewards, [{
    key: "submitAndEvaluate",
    value: function () {
      var _submitAndEvaluate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
        var challengeId, encodedUserId, handle, recipientEthAddress, specifier, oracleEthAddress, amount, quorumSize, AAOEndpoint, instructionsPerTransaction, _ref$maxAggregationAt, maxAggregationAttempts, _ref$endpoints, endpoints, _ref$logger, logger, _ref$feePayerOverride, feePayerOverride, phase, nodesToReselect, _yield$this$aggregate, discoveryNodeAttestations, aaoAttestation, aggregateError, erroringNodes, fullTokenAmount, _yield$this$solanaWeb, submitErrorCode, submitError, shouldRetryInSeperateTransactions, _yield$this$solanaWeb2, evaluateErrorCode, evaluateError, err, log;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                challengeId = _ref.challengeId, encodedUserId = _ref.encodedUserId, handle = _ref.handle, recipientEthAddress = _ref.recipientEthAddress, specifier = _ref.specifier, oracleEthAddress = _ref.oracleEthAddress, amount = _ref.amount, quorumSize = _ref.quorumSize, AAOEndpoint = _ref.AAOEndpoint, instructionsPerTransaction = _ref.instructionsPerTransaction, _ref$maxAggregationAt = _ref.maxAggregationAttempts, maxAggregationAttempts = _ref$maxAggregationAt === void 0 ? 20 : _ref$maxAggregationAt, _ref$endpoints = _ref.endpoints, endpoints = _ref$endpoints === void 0 ? null : _ref$endpoints, _ref$logger = _ref.logger, logger = _ref$logger === void 0 ? console : _ref$logger, _ref$feePayerOverride = _ref.feePayerOverride, feePayerOverride = _ref$feePayerOverride === void 0 ? null : _ref$feePayerOverride;
                nodesToReselect = null;
                _context.prev = 2;
                phase = AttestationPhases.SANITY_CHECKS; // fail if amount is a decimal

                if (!(Number(amount) !== amount || amount % 1 !== 0)) {
                  _context.next = 6;
                  break;
                }

                throw new Error('Invalid amount');

              case 6:
                // Aggregate
                logger.info("submitAndEvaluate: aggregating attestations for userId [".concat(decodeHashId$1(encodedUserId), "], challengeId [").concat(challengeId, "]"));
                phase = AttestationPhases.AGGREGATE_ATTESTATIONS;
                _context.next = 10;
                return this.aggregateAttestations({
                  challengeId: challengeId,
                  encodedUserId: encodedUserId,
                  handle: handle,
                  specifier: specifier,
                  oracleEthAddress: oracleEthAddress,
                  amount: amount,
                  quorumSize: quorumSize,
                  AAOEndpoint: AAOEndpoint,
                  endpoints: endpoints,
                  logger: logger,
                  maxAttempts: maxAggregationAttempts
                });

              case 10:
                _yield$this$aggregate = _context.sent;
                discoveryNodeAttestations = _yield$this$aggregate.discoveryNodeAttestations;
                aaoAttestation = _yield$this$aggregate.aaoAttestation;
                aggregateError = _yield$this$aggregate.error;
                erroringNodes = _yield$this$aggregate.erroringNodes;

                if (!aggregateError) {
                  _context.next = 18;
                  break;
                }

                nodesToReselect = erroringNodes;
                throw new Error(aggregateError);

              case 18:
                // Submit
                logger.info("submitAndEvaluate: submitting for challenge [".concat(challengeId, "], userId: [").concat(decodeHashId$1(encodedUserId), "] with [").concat(discoveryNodeAttestations.length, "] DN and [").concat(aaoAttestation ? 1 : 0, "] oracle attestations."));
                fullTokenAmount = new BN(amount * WRAPPED_AUDIO_PRECISION);
                phase = AttestationPhases.SUBMIT_ATTESTATIONS;
                _context.next = 23;
                return this.solanaWeb3Manager.submitChallengeAttestations({
                  attestations: discoveryNodeAttestations,
                  oracleAttestation: aaoAttestation,
                  challengeId: challengeId,
                  specifier: specifier,
                  recipientEthAddress: recipientEthAddress,
                  tokenAmount: fullTokenAmount,
                  instructionsPerTransaction: instructionsPerTransaction,
                  logger: logger,
                  feePayerOverride: feePayerOverride
                });

              case 23:
                _yield$this$solanaWeb = _context.sent;
                submitErrorCode = _yield$this$solanaWeb.errorCode;
                submitError = _yield$this$solanaWeb.error;

                if (!(submitErrorCode || submitError)) {
                  _context.next = 35;
                  break;
                }

                shouldRetryInSeperateTransactions = submitErrorCode === RewardsManagerError.REPEATED_SENDERS || submitErrorCode === RewardsManagerError.SIGN_COLLISION || submitErrorCode === RewardsManagerError.OPERATOR_COLLISION; // If we have sender collisions, we should
                // submit one attestation per transaction and try to get
                // into a good state.
                // TODO: in the case this retry fails, we still proceed
                // to evaluate phase and will error there (not ideal)

                if (!shouldRetryInSeperateTransactions) {
                  _context.next = 34;
                  break;
                }

                logger.warn("submitAndEvaluate: saw repeat senders for userId [".concat(decodeHashId$1(encodedUserId), "] challengeId: [").concat(challengeId, "] with err: ").concat(submitErrorCode, ", breaking up into individual transactions"));
                _context.next = 32;
                return this.solanaWeb3Manager.submitChallengeAttestations({
                  attestations: discoveryNodeAttestations,
                  oracleAttestation: aaoAttestation,
                  challengeId: challengeId,
                  specifier: specifier,
                  recipientEthAddress: recipientEthAddress,
                  tokenAmount: fullTokenAmount,
                  instructionsPerTransaction: 2,
                  // SECP + Attestation
                  logger: logger,
                  feePayerOverride: feePayerOverride
                });

              case 32:
                _context.next = 35;
                break;

              case 34:
                throw new Error(submitErrorCode || submitError);

              case 35:
                // Evaluate
                logger.info("submitAndEvaluate: evaluating for challenge [".concat(challengeId, "], userId: [").concat(decodeHashId$1(encodedUserId), "]"));
                phase = AttestationPhases.EVALUATE_ATTESTATIONS;
                _context.next = 39;
                return this.solanaWeb3Manager.evaluateChallengeAttestations({
                  challengeId: challengeId,
                  specifier: specifier,
                  recipientEthAddress: recipientEthAddress,
                  oracleEthAddress: oracleEthAddress,
                  tokenAmount: fullTokenAmount,
                  logger: logger,
                  feePayerOverride: feePayerOverride
                });

              case 39:
                _yield$this$solanaWeb2 = _context.sent;
                evaluateErrorCode = _yield$this$solanaWeb2.errorCode;
                evaluateError = _yield$this$solanaWeb2.error;

                if (!(evaluateErrorCode || evaluateError)) {
                  _context.next = 44;
                  break;
                }

                throw new Error(evaluateErrorCode || evaluateError);

              case 44:
                return _context.abrupt("return", {
                  success: true,
                  error: null,
                  phase: null,
                  nodesToReselect: null
                });

              case 47:
                _context.prev = 47;
                _context.t0 = _context["catch"](2);
                err = _context.t0.message;
                log = err === GetAttestationError.COGNITO_FLOW || err === GetAttestationError.HCAPTCHA ? logger.info : logger.error;
                log("submitAndEvaluate: failed for userId: [".concat(decodeHashId$1(encodedUserId), "] challenge-id [").concat(challengeId, "] at phase [").concat(phase, "] with err: ").concat(err));
                return _context.abrupt("return", {
                  success: false,
                  error: err,
                  phase: phase,
                  nodesToReselect: nodesToReselect
                });

              case 53:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 47]]);
      }));

      function submitAndEvaluate(_x) {
        return _submitAndEvaluate.apply(this, arguments);
      }

      return submitAndEvaluate;
    }()
    /**
     *
     * Aggregates attestations from Discovery Nodes and AAO.
     *
     * @typedef {Object} AttestationsReturn
     * @property {Array<AttestationMeta>} discoveryNodeAttestations
     * @property {AttestationMeta} aaoAttestation
     * @property {GetAttestationError} error
     *
     * @param {{
     *   challengeId: string,
     *   encodedUserId: string,
     *   handle: string,
     *   specifier: string,
     *   oracleEthAddress: string,
     *   amount: number,
     *   quorumSize: number,
     *   AAOEndpoint: string,
     *   maxAttempts: number
     *   endpoints = null
     *   logger: any
     * }} {
     *   challengeId,
     *   encodedUserId,
     *   handle,
     *   specifier,
     *   oracleEthAddress,
     *   amount,
     *   quorumSize,
     *   AAOEndpoint,
     *   maxAttempts
     *   endpoints = null,
     *   logger
     * }
     * @returns {Promise<AttestationsReturn>}
     * @memberof Rewards
     */

  }, {
    key: "aggregateAttestations",
    value: function () {
      var _aggregateAttestations = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
        var challengeId, encodedUserId, handle, specifier, oracleEthAddress, amount, quorumSize, AAOEndpoint, maxAttempts, _ref2$endpoints, endpoints, _ref2$logger, logger, aaoAttestation, _yield$this$getAAOAtt, success, aaoAttestationError, err, discoveryNodeAttestationResults, discoveryNodeSuccesses, discoveryNodeErrors, error, erroringNodes, _err;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                challengeId = _ref2.challengeId, encodedUserId = _ref2.encodedUserId, handle = _ref2.handle, specifier = _ref2.specifier, oracleEthAddress = _ref2.oracleEthAddress, amount = _ref2.amount, quorumSize = _ref2.quorumSize, AAOEndpoint = _ref2.AAOEndpoint, maxAttempts = _ref2.maxAttempts, _ref2$endpoints = _ref2.endpoints, endpoints = _ref2$endpoints === void 0 ? null : _ref2$endpoints, _ref2$logger = _ref2.logger, logger = _ref2$logger === void 0 ? console : _ref2$logger;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);

                if (!endpoints) {
                  _context2.next = 6;
                  break;
                }

                endpoints = sampleSize$1(endpoints, quorumSize);
                _context2.next = 9;
                break;

              case 6:
                _context2.next = 8;
                return this.ServiceProvider.getUniquelyOwnedDiscoveryNodes(quorumSize);

              case 8:
                endpoints = _context2.sent;

              case 9:
                if (!(endpoints.length < quorumSize)) {
                  _context2.next = 12;
                  break;
                }

                logger.error("Tried to fetch [".concat(quorumSize, "] attestations, but only found [").concat(endpoints.length, "] registered nodes."));
                return _context2.abrupt("return", {
                  discoveryNodeAttestations: null,
                  aaoAttestation: null,
                  error: AggregateAttestationError.INSUFFICIENT_DISCOVERY_NODE_COUNT,
                  erroringNodes: null
                });

              case 12:
                // First attempt AAO
                aaoAttestation = null;
                _context2.prev = 13;
                _context2.next = 16;
                return this.getAAOAttestation({
                  challengeId: challengeId,
                  specifier: specifier,
                  handle: handle,
                  amount: amount,
                  AAOEndpoint: AAOEndpoint,
                  oracleEthAddress: oracleEthAddress
                });

              case 16:
                _yield$this$getAAOAtt = _context2.sent;
                success = _yield$this$getAAOAtt.success;
                aaoAttestationError = _yield$this$getAAOAtt.error;

                if (!aaoAttestationError) {
                  _context2.next = 21;
                  break;
                }

                return _context2.abrupt("return", {
                  discoveryNodeAttestations: null,
                  aaoAttestation: null,
                  error: aaoAttestationError,
                  erroringNodes: null
                });

              case 21:
                aaoAttestation = success;
                _context2.next = 29;
                break;

              case 24:
                _context2.prev = 24;
                _context2.t0 = _context2["catch"](13);
                err = _context2.t0.message;
                logger.error("Failed to aggregate attestations for user [".concat(decodeHashId$1(encodedUserId), "], challenge-id: [").concat(challengeId, "] with err: ").concat(err));
                return _context2.abrupt("return", {
                  discoveryNodeAttestations: null,
                  aaoAttestation: null,
                  error: GetAttestationError.AAO_ATTESTATION_ERROR,
                  erroringNodes: null
                });

              case 29:
                _context2.prev = 29;
                _context2.next = 32;
                return this._getDiscoveryAttestationsWithRetries({
                  endpoints: endpoints,
                  challengeId: challengeId,
                  encodedUserId: encodedUserId,
                  specifier: specifier,
                  oracleEthAddress: oracleEthAddress,
                  logger: logger,
                  maxAttempts: maxAttempts
                });

              case 32:
                discoveryNodeAttestationResults = _context2.sent;
                discoveryNodeSuccesses = discoveryNodeAttestationResults.map(function (r) {
                  return r.success;
                });
                discoveryNodeErrors = discoveryNodeAttestationResults.map(function (r) {
                  return r.error;
                });
                error = discoveryNodeErrors.find(Boolean);

                if (!error) {
                  _context2.next = 39;
                  break;
                }

                // Propagate out the specific nodes that errored
                erroringNodes = discoveryNodeAttestationResults.filter(function (r) {
                  return r.error;
                }).map(function (r) {
                  return r.endpoint;
                });
                return _context2.abrupt("return", {
                  discoveryNodeAttestations: null,
                  aaoAttestation: null,
                  error: error,
                  erroringNodes: erroringNodes
                });

              case 39:
                return _context2.abrupt("return", {
                  discoveryNodeAttestations: discoveryNodeSuccesses,
                  aaoAttestation: aaoAttestation,
                  error: null,
                  erroringNodes: null
                });

              case 42:
                _context2.prev = 42;
                _context2.t1 = _context2["catch"](29);
                _err = _context2.t1.message;
                logger.error("Failed to aggregate attestations for user [".concat(decodeHashId$1(encodedUserId), "], challenge-id: [").concat(challengeId, "] with err: ").concat(_err));
                return _context2.abrupt("return", {
                  discoveryNodeAttestations: null,
                  aaoAttestation: null,
                  error: GetAttestationError.DISCOVERY_NODE_ATTESTATION_ERROR,
                  erroringNodes: null
                });

              case 47:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[13, 24], [29, 42]]);
      }));

      function aggregateAttestations(_x2) {
        return _aggregateAttestations.apply(this, arguments);
      }

      return aggregateAttestations;
    }()
    /**
     *
     * Retrieves a Discovery Node attestation for a given userId.
     *
     * @typedef {Object} GetAttestationReturn
     * @property {AttestationMeta} success
     * @property {GetAttestationError} error
     *
     * @param {{
     *   challengeId: string,
     *   encodedUserId: string,
     *   specifier: string,
     *   oracleEthAddress: string,
     *   discoveryProviderEndpoint: string
     *   logger: any
     * }} {
     *   challengeId,
     *   encodedUserId,
     *   specifier,
     *   oracleEthAddress,
     *   discoveryProviderEndpoint
     *   logger
     * }
     * @returns {Promise<GetAttestationReturn>}
     * @memberof Challenge
     */

  }, {
    key: "getChallengeAttestation",
    value: function () {
      var _getChallengeAttestation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref3) {
        var challengeId, encodedUserId, specifier, oracleEthAddress, discoveryProviderEndpoint, _ref3$logger, logger, res, meta, err, mappedErr;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                challengeId = _ref3.challengeId, encodedUserId = _ref3.encodedUserId, specifier = _ref3.specifier, oracleEthAddress = _ref3.oracleEthAddress, discoveryProviderEndpoint = _ref3.discoveryProviderEndpoint, _ref3$logger = _ref3.logger, logger = _ref3$logger === void 0 ? console : _ref3$logger;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context3.prev = 2;
                _context3.next = 5;
                return this.discoveryProvider.getChallengeAttestation(challengeId, encodedUserId, specifier, oracleEthAddress, discoveryProviderEndpoint);

              case 5:
                res = _context3.sent;
                meta = {
                  ethAddress: res.owner_wallet,
                  signature: res.attestation
                };
                return _context3.abrupt("return", {
                  success: meta,
                  error: null
                });

              case 10:
                _context3.prev = 10;
                _context3.t0 = _context3["catch"](2);
                err = _context3.t0.message;
                logger.error("Failed to get challenge attestation for userId [".concat(decodeHashId$1(encodedUserId), "] challengeId [").concat(challengeId, "]from ").concat(discoveryProviderEndpoint, " with ").concat(err));
                mappedErr = GetAttestationError[err] || GetAttestationError.DISCOVERY_NODE_UNKNOWN_RESPONSE;
                return _context3.abrupt("return", {
                  success: null,
                  error: mappedErr
                });

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 10]]);
      }));

      function getChallengeAttestation(_x3) {
        return _getChallengeAttestation.apply(this, arguments);
      }

      return getChallengeAttestation;
    }()
  }, {
    key: "getUndisbursedChallenges",
    value: function () {
      var _getUndisbursedChallenges = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _ref4,
            limit,
            offset,
            completedBlockNumber,
            encodedUserId,
            _ref4$logger,
            logger,
            res,
            error,
            _args4 = arguments;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _ref4 = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {
                  logger: console
                }, limit = _ref4.limit, offset = _ref4.offset, completedBlockNumber = _ref4.completedBlockNumber, encodedUserId = _ref4.encodedUserId, _ref4$logger = _ref4.logger, logger = _ref4$logger === void 0 ? console : _ref4$logger;
                this.REQUIRES(Services.DISCOVERY_PROVIDER);
                _context4.prev = 2;
                _context4.next = 5;
                return this.discoveryProvider.getUndisbursedChallenges(limit, offset, completedBlockNumber, encodedUserId);

              case 5:
                res = _context4.sent;
                return _context4.abrupt("return", {
                  success: res,
                  error: null
                });

              case 9:
                _context4.prev = 9;
                _context4.t0 = _context4["catch"](2);
                error = _context4.t0.message;
                logger.error("Failed to get undisbursed challenges with error: ".concat(error));
                return _context4.abrupt("return", {
                  success: null,
                  error: error
                });

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[2, 9]]);
      }));

      function getUndisbursedChallenges() {
        return _getUndisbursedChallenges.apply(this, arguments);
      }

      return getUndisbursedChallenges;
    }()
    /**
     *
     * Retrieves an AAO attestation for a given user handle.
     *
     * @typedef {Object} GetAAOAttestationReturn
     * @property {AttestationMeta} success
     * @property {GetAttestationError} error
     *
     * @param {{
     *   challengeId: string,
     *   specifier: string,
     *   handle: string,
     *   amount: number,
     *   AAOEndpoint: string,
     *   oracleEthAddress: string
     *   logger: any
     * }} {
     *   challengeId,
     *   specifier,
     *   handle,
     *   amount,
     *   AAOEndpoint,
     *   oracleEthAddress,
     *   logger
     * }
     * @returns {Promise<GetAAOAttestationReturn>}
     * @memberof Challenge
     */

  }, {
    key: "getAAOAttestation",
    value: function () {
      var _getAAOAttestation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref5) {
        var challengeId, specifier, handle, amount, AAOEndpoint, oracleEthAddress, _ref5$logger, logger, data, request, response, _response$data, result, needs, mappedErr, err;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                challengeId = _ref5.challengeId, specifier = _ref5.specifier, handle = _ref5.handle, amount = _ref5.amount, AAOEndpoint = _ref5.AAOEndpoint, oracleEthAddress = _ref5.oracleEthAddress, _ref5$logger = _ref5.logger, logger = _ref5$logger === void 0 ? console : _ref5$logger;
                data = {
                  challengeId: challengeId,
                  challengeSpecifier: specifier,
                  amount: amount
                };
                request = {
                  method: 'post',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  url: "".concat(AAOEndpoint, "/attestation/").concat(handle),
                  timeout: AAO_REQUEST_TIMEOUT_MS,
                  data: data
                };
                _context5.prev = 3;
                _context5.next = 6;
                return axios(request);

              case 6:
                response = _context5.sent;
                // if attestation is successful, 'result' represents a signature
                // otherwise, 'result' is false
                // - there may or may not be a value for `needs` if the attestation fails
                // - depending on whether the user can take an action to attempt remediation
                _response$data = response.data, result = _response$data.result, needs = _response$data.needs;

                if (result) {
                  _context5.next = 12;
                  break;
                }

                logger.error("Failed to get AAO attestation".concat(needs ? ": needs ".concat(needs) : ''));
                mappedErr = needs ? GetAttestationError[needs] || GetAttestationError.AAO_ATTESTATION_UNKNOWN_RESPONSE : GetAttestationError.AAO_ATTESTATION_REJECTION;
                return _context5.abrupt("return", {
                  success: null,
                  error: mappedErr
                });

              case 12:
                return _context5.abrupt("return", {
                  success: {
                    signature: result,
                    ethAddress: oracleEthAddress
                  },
                  error: null
                });

              case 15:
                _context5.prev = 15;
                _context5.t0 = _context5["catch"](3);
                err = _context5.t0.message;
                logger.error("Failed to get AAO attestation: ".concat(err));
                return _context5.abrupt("return", {
                  success: null,
                  error: GetAttestationError.AAO_ATTESTATION_ERROR
                });

              case 20:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[3, 15]]);
      }));

      function getAAOAttestation(_x4) {
        return _getAAOAttestation.apply(this, arguments);
      }

      return getAAOAttestation;
    }()
  }, {
    key: "_getDiscoveryAttestationsWithRetries",
    value: function () {
      var _getDiscoveryAttestationsWithRetries2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(_ref6) {
        var _this2 = this;

        var endpoints, challengeId, encodedUserId, specifier, oracleEthAddress, logger, maxAttempts, retryCount, unrecoverableError, completedAttestations, needsAttestations, attestations;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                endpoints = _ref6.endpoints, challengeId = _ref6.challengeId, encodedUserId = _ref6.encodedUserId, specifier = _ref6.specifier, oracleEthAddress = _ref6.oracleEthAddress, logger = _ref6.logger, maxAttempts = _ref6.maxAttempts;
                retryCount = 0;
                unrecoverableError = false;
                completedAttestations = [];
                needsAttestations = endpoints;

              case 5:
                logger.info("Aggregating attestations with retries challenge: ".concat(challengeId, ", userId: ").concat(encodedUserId, ", endpoints: ").concat(needsAttestations, ", attempt ").concat(retryCount));

                if (!(retryCount > 0)) {
                  _context7.next = 9;
                  break;
                }

                _context7.next = 9;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, 2000);
                });

              case 9:
                _context7.next = 11;
                return Promise.all(needsAttestations.map( /*#__PURE__*/function () {
                  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(endpoint) {
                    var res;
                    return regeneratorRuntime.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return _this2.getChallengeAttestation({
                              challengeId: challengeId,
                              encodedUserId: encodedUserId,
                              specifier: specifier,
                              oracleEthAddress: oracleEthAddress,
                              discoveryProviderEndpoint: endpoint,
                              logger: logger
                            });

                          case 2:
                            res = _context6.sent;
                            return _context6.abrupt("return", {
                              endpoint: endpoint,
                              res: res
                            });

                          case 4:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6);
                  }));

                  return function (_x6) {
                    return _ref7.apply(this, arguments);
                  };
                }()));

              case 11:
                attestations = _context7.sent;
                needsAttestations = [];
                attestations.forEach(function (a) {
                  // If it's a retryable error
                  var isRetryable = a.res.error === GetAttestationError.CHALLENGE_INCOMPLETE || a.res.error === GetAttestationError.MISSING_CHALLENGES;

                  if (isRetryable) {
                    needsAttestations.push(a.endpoint);
                    logger.info("Node ".concat(a.endpoint, " challenge still incomplete for challenge [").concat(challengeId, "], userId: ").concat(encodedUserId)); // If final attempt, make sure we return the result

                    if (retryCount === maxAttempts) {
                      completedAttestations.push(_objectSpread2(_objectSpread2({}, a.res), {}, {
                        endpoint: a.endpoint
                      }));
                    }
                  } else {
                    completedAttestations.push(_objectSpread2(_objectSpread2({}, a.res), {}, {
                      endpoint: a.endpoint
                    }));

                    if (a.res.error) {
                      unrecoverableError = true;
                    }
                  }
                });
                retryCount++;

              case 15:
                if (needsAttestations.length && retryCount <= maxAttempts) {
                  _context7.next = 5;
                  break;
                }

              case 16:
                if (needsAttestations.length || unrecoverableError) {
                  logger.info("Failed to aggregate attestations for challenge [".concat(challengeId, "], userId: [").concat(decodeHashId$1(encodedUserId), "]"));
                } else {
                  logger.info("Successfully aggregated attestations for challenge [".concat(challengeId, "], userId: [").concat(decodeHashId$1(encodedUserId), "]"));
                }

                return _context7.abrupt("return", completedAttestations);

              case 18:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function _getDiscoveryAttestationsWithRetries(_x5) {
        return _getDiscoveryAttestationsWithRetries2.apply(this, arguments);
      }

      return _getDiscoveryAttestationsWithRetries;
    }()
    /**
     *
     * Creates a new discovery node sender for rewards. A sender may
     * attest in user challenge completion to issue rewards.
     *
     * This method queries other discovery nodes asking for attestation of
     * a given new senderEthAddress (delegate wallet) and operatorEthAddress (owner wallet).
     * Those attestations are bundled
     *
     * @param {{
     *   senderEthAddress: string
     *   operatorEthAddress: string
     *   senderEndpoint: string
     *   endpoints?: string[]
     *   numAttestations?: number
     *   feePayerOverride?: string
     * }} {
     *   senderEthAddress: the new sender eth address to add. The delegate wallet.
     *   operatorEthAddress: the unique address of the operator that runs this service
     *   senderEndpoint: the new sender's service endpoint
     *   endpoints: optional endpoints from other nodes. If not provided, nodes are selected from chain.
     *   numAttestations: optional number of attestations to get from other nodes, default 3
     *   feePayerOverride: optional override feepayer
     * }
     * @memberof Rewards
     */

  }, {
    key: "createSenderPublic",
    value: function () {
      var _createSenderPublic = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(_ref8) {
        var _this3 = this;

        var senderEthAddress, operatorEthAddress, endpoints, _ref8$numAttestations, numAttestations, feePayerOverride, attestEndpoints, error, attestations, receipt;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                senderEthAddress = _ref8.senderEthAddress, operatorEthAddress = _ref8.operatorEthAddress, endpoints = _ref8.endpoints, _ref8$numAttestations = _ref8.numAttestations, numAttestations = _ref8$numAttestations === void 0 ? 3 : _ref8$numAttestations, feePayerOverride = _ref8.feePayerOverride;

                if (!endpoints) {
                  _context10.next = 5;
                  break;
                }

                attestEndpoints = sampleSize$1(endpoints, numAttestations);
                _context10.next = 8;
                break;

              case 5:
                _context10.next = 7;
                return this.ServiceProvider.getUniquelyOwnedDiscoveryNodes(numAttestations, [], /*#__PURE__*/function () {
                  var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(node) {
                    var isRegistered;
                    return regeneratorRuntime.wrap(function _callee8$(_context8) {
                      while (1) {
                        switch (_context8.prev = _context8.next) {
                          case 0:
                            _context8.next = 2;
                            return _this3.solanaWeb3Manager.getIsDiscoveryNodeRegistered(node.delegateOwnerWallet);

                          case 2:
                            isRegistered = _context8.sent;
                            return _context8.abrupt("return", isRegistered);

                          case 4:
                          case "end":
                            return _context8.stop();
                        }
                      }
                    }, _callee8);
                  }));

                  return function (_x8) {
                    return _ref9.apply(this, arguments);
                  };
                }());

              case 7:
                attestEndpoints = _context10.sent;

              case 8:
                if (!(attestEndpoints.length < numAttestations)) {
                  _context10.next = 10;
                  break;
                }

                throw new Error("Not enough other nodes found, need ".concat(numAttestations, ", found ").concat(attestEndpoints.length));

              case 10:
                error = null;
                _context10.next = 13;
                return Promise.all(attestEndpoints.map( /*#__PURE__*/function () {
                  var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(attestEndpoint) {
                    var res;
                    return regeneratorRuntime.wrap(function _callee9$(_context9) {
                      while (1) {
                        switch (_context9.prev = _context9.next) {
                          case 0:
                            _context9.prev = 0;
                            _context9.next = 3;
                            return _this3.discoveryProvider.getCreateSenderAttestation(senderEthAddress, attestEndpoint);

                          case 3:
                            res = _context9.sent;
                            return _context9.abrupt("return", {
                              ethAddress: res.owner_wallet,
                              signature: res.attestation
                            });

                          case 7:
                            _context9.prev = 7;
                            _context9.t0 = _context9["catch"](0);
                            console.error(_context9.t0);
                            error = true;

                          case 11:
                          case "end":
                            return _context9.stop();
                        }
                      }
                    }, _callee9, null, [[0, 7]]);
                  }));

                  return function (_x9) {
                    return _ref10.apply(this, arguments);
                  };
                }()));

              case 13:
                attestations = _context10.sent;

                if (!error) {
                  _context10.next = 17;
                  break;
                }

                console.error("Failed to get attestations from other nodes ".concat(attestEndpoints));
                return _context10.abrupt("return", {
                  success: null,
                  error: GetSenderAttestationError.REQUEST_FOR_ATTESTATION_FAILED
                });

              case 17:
                _context10.next = 19;
                return this.solanaWeb3Manager.createSender({
                  senderEthAddress: senderEthAddress,
                  operatorEthAddress: operatorEthAddress,
                  attestations: attestations,
                  feePayerOverride: feePayerOverride
                });

              case 19:
                receipt = _context10.sent;
                return _context10.abrupt("return", receipt);

              case 21:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function createSenderPublic(_x7) {
        return _createSenderPublic.apply(this, arguments);
      }

      return createSenderPublic;
    }()
    /**
     * Logs results of an attestation to identity.
     *
     * @param {{
     *  status: string,
     *  userId: string,
     *  challengeId: string,
     *  amount: number,
     *  source: string
     *  specifier: string
     *  error?: string,
     *  phase?: string,
     *  reason?: string
     * }} { status, userId, challengeId, amount, error, phase, specifier, reason }
     * @memberof IdentityService
     */

  }, {
    key: "sendAttestationResult",
    value: function () {
      var _sendAttestationResult = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(_ref11) {
        var status, userId, challengeId, amount, error, phase, source, specifier, reason;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                status = _ref11.status, userId = _ref11.userId, challengeId = _ref11.challengeId, amount = _ref11.amount, error = _ref11.error, phase = _ref11.phase, source = _ref11.source, specifier = _ref11.specifier, reason = _ref11.reason;
                _context11.next = 3;
                return this.identityService.sendAttestationResult({
                  status: status,
                  userId: userId,
                  challengeId: challengeId,
                  amount: amount,
                  error: error,
                  phase: phase,
                  source: source,
                  specifier: specifier,
                  reason: reason
                });

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function sendAttestationResult(_x10) {
        return _sendAttestationResult.apply(this, arguments);
      }

      return sendAttestationResult;
    }()
  }]);

  return Rewards;
}(Base$1);

rewards.exports = Rewards;
var SubmitAndEvaluateError_1 = rewards.exports.SubmitAndEvaluateError = SubmitAndEvaluateError;
rewards.exports.AttestationPhases = AttestationPhases;

var sampleSize = require$$0__default$3["default"].sampleSize;
var Base = base.Base;
var timeRequests = require$$2.timeRequests;
var CreatorNodeSelection = require$$10.CreatorNodeSelection;
var CONTENT_NODE_SERVICE_NAME = 'content-node';
var DISCOVERY_NODE_SERVICE_NAME = 'discovery-node'; // Default timeout for each content node's sync and health check

var CONTENT_NODE_DEFAULT_SELECTION_TIMEOUT = 7500; // Default time at which responses are considered equal weighting.
// Content nodes that reply within 200ms of eachother are given equal footing
// in selection

var CONTENT_NODE_SELECTION_EQUIVALENCY_DELTA = 200;
/**
 * API methods to interact with Audius service providers.
 * Types of services include:
 *    - Content Node (host creator content)
 *    - Discovery Node (index and make content queryable)
 * Retrieving lists of available services, etc. are found here.
 */

var ServiceProvider = /*#__PURE__*/function (_Base) {
  _inherits(ServiceProvider, _Base);

  var _super = _createSuper(ServiceProvider);

  function ServiceProvider() {
    _classCallCheck(this, ServiceProvider);

    return _super.apply(this, arguments);
  }

  _createClass(ServiceProvider, [{
    key: "listCreatorNodes",
    value:
    /* ------- Content Node  ------- */
    function () {
      var _listCreatorNodes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.ethContracts.ServiceProviderFactoryClient.getServiceProviderList(CONTENT_NODE_SERVICE_NAME));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function listCreatorNodes() {
        return _listCreatorNodes.apply(this, arguments);
      }

      return listCreatorNodes;
    }()
    /**
     * Fetches healthy Content Nodes filtered down to a given whitelist and blacklist
     * @param {Set<string>?} whitelist whether or not to include only specified nodes (default no whiltelist)
     * @param {Set<string?} blacklist whether or not to exclude any nodes (default no blacklist)
     */

  }, {
    key: "getSelectableCreatorNodes",
    value: function () {
      var _getSelectableCreatorNodes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var whitelist,
            blacklist,
            timeout,
            creatorNodes,
            timings,
            services,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                whitelist = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : null;
                blacklist = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;
                timeout = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : CONTENT_NODE_DEFAULT_SELECTION_TIMEOUT;
                _context2.next = 5;
                return this.listCreatorNodes();

              case 5:
                creatorNodes = _context2.sent;

                // Filter whitelist
                if (whitelist) {
                  creatorNodes = creatorNodes.filter(function (node) {
                    return whitelist.has(node.endpoint);
                  });
                } // Filter blacklist


                if (blacklist) {
                  creatorNodes = creatorNodes.filter(function (node) {
                    return !blacklist.has(node.endpoint);
                  });
                } // Time requests and get version info


                _context2.next = 10;
                return timeRequests({
                  requests: creatorNodes.map(function (node) {
                    return {
                      id: node.endpoint,
                      url: "".concat(node.endpoint, "/health_check/verbose")
                    };
                  }),
                  sortByVersion: true,
                  timeout: timeout
                });

              case 10:
                timings = _context2.sent;
                services = {};
                timings.forEach(function (timing) {
                  if (timing.response) services[timing.request.id] = timing.response.data.data;
                });
                return _context2.abrupt("return", services);

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getSelectableCreatorNodes() {
        return _getSelectableCreatorNodes.apply(this, arguments);
      }

      return getSelectableCreatorNodes;
    }()
    /**
     * Fetches healthy Content Nodes and autoselects a primary
     * and two secondaries.
     * @param {number} numberOfNodes total number of nodes to fetch (2 secondaries means 3 total)
     * @param {Set<string>?} whitelist whether or not to include only specified nodes (default no whitelist)
     * @param {Set<string?} blacklist whether or not to exclude any nodes (default no blacklist)
     * @param {boolean} performSyncCheck whether or not to perform sync check
     * @param {number?} timeout ms applied to each request made to a content node
     * @returns { primary, secondaries, services }
     * // primary: string
     * // secondaries: string[]
     * // services: { creatorNodeEndpoint: healthCheckResponse }
     */

  }, {
    key: "autoSelectCreatorNodes",
    value: function () {
      var _autoSelectCreatorNodes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref) {
        var _ref$numberOfNodes, numberOfNodes, _ref$whitelist, whitelist, _ref$blacklist, blacklist, _ref$performSyncCheck, performSyncCheck, _ref$timeout, timeout, _ref$equivalencyDelta, equivalencyDelta, _ref$preferHigherPatc, preferHigherPatchForPrimary, _ref$preferHigherPatc2, preferHigherPatchForSecondaries, _ref$log, log, creatorNodeSelection, _yield$creatorNodeSel, primary, secondaries, services;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _ref$numberOfNodes = _ref.numberOfNodes, numberOfNodes = _ref$numberOfNodes === void 0 ? 3 : _ref$numberOfNodes, _ref$whitelist = _ref.whitelist, whitelist = _ref$whitelist === void 0 ? null : _ref$whitelist, _ref$blacklist = _ref.blacklist, blacklist = _ref$blacklist === void 0 ? null : _ref$blacklist, _ref$performSyncCheck = _ref.performSyncCheck, performSyncCheck = _ref$performSyncCheck === void 0 ? true : _ref$performSyncCheck, _ref$timeout = _ref.timeout, timeout = _ref$timeout === void 0 ? CONTENT_NODE_DEFAULT_SELECTION_TIMEOUT : _ref$timeout, _ref$equivalencyDelta = _ref.equivalencyDelta, equivalencyDelta = _ref$equivalencyDelta === void 0 ? CONTENT_NODE_SELECTION_EQUIVALENCY_DELTA : _ref$equivalencyDelta, _ref$preferHigherPatc = _ref.preferHigherPatchForPrimary, preferHigherPatchForPrimary = _ref$preferHigherPatc === void 0 ? true : _ref$preferHigherPatc, _ref$preferHigherPatc2 = _ref.preferHigherPatchForSecondaries, preferHigherPatchForSecondaries = _ref$preferHigherPatc2 === void 0 ? true : _ref$preferHigherPatc2, _ref$log = _ref.log, log = _ref$log === void 0 ? true : _ref$log;
                creatorNodeSelection = new CreatorNodeSelection({
                  creatorNode: this.creatorNode,
                  ethContracts: this.ethContracts,
                  logger: this.logger,
                  numberOfNodes: numberOfNodes,
                  whitelist: whitelist,
                  blacklist: blacklist,
                  timeout: timeout,
                  equivalencyDelta: equivalencyDelta,
                  preferHigherPatchForPrimary: preferHigherPatchForPrimary,
                  preferHigherPatchForSecondaries: preferHigherPatchForSecondaries
                });
                _context3.next = 4;
                return creatorNodeSelection.select(performSyncCheck, log);

              case 4:
                _yield$creatorNodeSel = _context3.sent;
                primary = _yield$creatorNodeSel.primary;
                secondaries = _yield$creatorNodeSel.secondaries;
                services = _yield$creatorNodeSel.services;
                return _context3.abrupt("return", {
                  primary: primary,
                  secondaries: secondaries,
                  services: services
                });

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function autoSelectCreatorNodes(_x) {
        return _autoSelectCreatorNodes.apply(this, arguments);
      }

      return autoSelectCreatorNodes;
    }()
    /* ------- Discovery Node ------ */

  }, {
    key: "listDiscoveryProviders",
    value: function () {
      var _listDiscoveryProviders = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", this.ethContracts.ServiceProviderFactoryClient.getServiceProviderList(DISCOVERY_NODE_SERVICE_NAME));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function listDiscoveryProviders() {
        return _listDiscoveryProviders.apply(this, arguments);
      }

      return listDiscoveryProviders;
    }()
    /**
     * Returns a list of discovery nodes of size `quorumSize` that belong to
     * unique service operators.
     * Throws if unable to find a large enough list.
     * @param {number} quorumSize
     * @param {any[]} discoveryProviders the verbose list of discovery providers to select from
     * @param {(node: { delegateOwnerWallet: string }) => boolean} filter an optional filter step to remove certain nodes
     */

  }, {
    key: "getUniquelyOwnedDiscoveryNodes",
    value: function () {
      var _getUniquelyOwnedDiscoveryNodes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(quorumSize) {
        var discoveryProviders,
            filter,
            grouped,
            owners,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                discoveryProviders = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : [];
                filter = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : function (node) {
                  return true;
                };

                if (!(!discoveryProviders || discoveryProviders.length === 0)) {
                  _context5.next = 6;
                  break;
                }

                _context5.next = 5;
                return this.discoveryProvider.serviceSelector.findAll({
                  verbose: true
                });

              case 5:
                discoveryProviders = _context5.sent;

              case 6:
                discoveryProviders.filter(filter); // Group nodes by owner

                grouped = discoveryProviders.reduce(function (acc, curr) {
                  if (curr.owner in acc) {
                    acc[curr.owner].push(curr);
                  } else {
                    acc[curr.owner] = [curr];
                  }

                  return acc;
                }, {});

                if (!(Object.keys(grouped) < quorumSize)) {
                  _context5.next = 10;
                  break;
                }

                throw new Error('Not enough unique owners to choose from');

              case 10:
                // Select quorumSize owners from the groups
                owners = sampleSize(Object.keys(grouped), quorumSize); // Select 1 node from each owner selected

                return _context5.abrupt("return", owners.map(function (owner) {
                  return sampleSize(grouped[owner], 1)[0].endpoint;
                }));

              case 12:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getUniquelyOwnedDiscoveryNodes(_x2) {
        return _getUniquelyOwnedDiscoveryNodes.apply(this, arguments);
      }

      return getUniquelyOwnedDiscoveryNodes;
    }()
  }]);

  return ServiceProvider;
}(Base);

var serviceProvider = ServiceProvider;

var decodeHashId = Utils$b.decodeHashId; // `BaseRewardsReporter` is intended to be subclassed, and provides
// "reporting" functionality to RewardsAttester (i.e. posts to Slack if something notable happens)

var BaseRewardsReporter = /*#__PURE__*/function () {
  function BaseRewardsReporter() {
    _classCallCheck(this, BaseRewardsReporter);
  }

  _createClass(BaseRewardsReporter, [{
    key: "reportSuccess",
    value: function () {
      var _reportSuccess = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function reportSuccess(_x) {
        return _reportSuccess.apply(this, arguments);
      }

      return reportSuccess;
    }()
  }, {
    key: "reportRetry",
    value: function () {
      var _reportRetry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function reportRetry(_x2) {
        return _reportRetry.apply(this, arguments);
      }

      return reportRetry;
    }()
  }, {
    key: "reportFailure",
    value: function () {
      var _reportFailure = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function reportFailure(_x3) {
        return _reportFailure.apply(this, arguments);
      }

      return reportFailure;
    }()
  }, {
    key: "reportAAORejection",
    value: function () {
      var _reportAAORejection = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function reportAAORejection(_x4) {
        return _reportAAORejection.apply(this, arguments);
      }

      return reportAAORejection;
    }()
  }]);

  return BaseRewardsReporter;
}();

var MAX_DISBURSED_CACHE_SIZE = 100;
var SOLANA_EST_SEC_PER_SLOT = 0.5;
var POA_SEC_PER_BLOCK = 5;
var MAX_DISCOVERY_NODE_BLOCKLIST_LEN = 10;
/**
 * Class to encapsulate logic for calculating disbursement delay thresholds.
 * Periodically polls Solana to get slot production rate.
 * Caches old values (`allowedStalenessSec`) for current POA block & Solana slot to reduce RPC
 * overhead.
 *
 * Exposes `getPOABlockThreshold` and `getSolanaSlotThreshold`
 *
 * @class ThresholdCalculator
 */

var AttestationDelayCalculator = /*#__PURE__*/function () {
  function AttestationDelayCalculator(_ref) {
    var libs = _ref.libs,
        runBehindSec = _ref.runBehindSec,
        allowedStalenessSec = _ref.allowedStalenessSec,
        _ref$solanaPollingInt = _ref.solanaPollingInterval,
        solanaPollingInterval = _ref$solanaPollingInt === void 0 ? 30 : _ref$solanaPollingInt,
        _ref$logger = _ref.logger,
        logger = _ref$logger === void 0 ? console : _ref$logger;

    _classCallCheck(this, AttestationDelayCalculator);

    this.libs = libs;
    this.solanaSecPerSlot = SOLANA_EST_SEC_PER_SLOT;
    this.runBehindSec = runBehindSec;
    this.lastSolanaThreshold = null;
    this.lastPOAThreshold = null;
    this.allowedStalenessSec = allowedStalenessSec;
    this.solanaPollingInterval = solanaPollingInterval;
    this.logger = logger;
    this.intervalHandle = null;
  }

  _createClass(AttestationDelayCalculator, [{
    key: "start",
    value: function () {
      var _start = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var _this = this;

        var oldSlot;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.libs.solanaWeb3Manager.getSlot();

              case 2:
                oldSlot = _context6.sent;
                // eslint-disable-next-line
                this.intervalHandle = setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                  var newSlot, diff;
                  return regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return _this.libs.solanaWeb3Manager.getSlot();

                        case 2:
                          newSlot = _context5.sent;
                          diff = _this.solanaPollingInterval / (newSlot - oldSlot);
                          _this.solanaSecPerSlot = diff;

                          _this.logger.info("Setting Solana seconds per slot to ".concat(diff));

                          oldSlot = newSlot;

                        case 7:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                })), this.solanaPollingInterval * 1000);

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function start() {
        return _start.apply(this, arguments);
      }

      return start;
    }()
  }, {
    key: "stop",
    value: function stop() {
      if (this.intervalHandle) {
        clearInterval(this.intervalHandle);
      }
    }
  }, {
    key: "getPOABlockThreshold",
    value: function () {
      var _getPOABlockThreshold = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var currentBlock, threshold;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(this.lastPOAThreshold && (Date.now() - this.lastPOAThreshold.time) / 1000 < this.allowedStalenessSec)) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return", this.lastPOAThreshold.threshold);

              case 2:
                _context7.next = 4;
                return this.libs.web3Manager.getWeb3().eth.getBlockNumber();

              case 4:
                currentBlock = _context7.sent;
                threshold = currentBlock - this.runBehindSec / POA_SEC_PER_BLOCK;
                this.lastPOAThreshold = {
                  threshold: threshold,
                  time: Date.now()
                };
                return _context7.abrupt("return", threshold);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getPOABlockThreshold() {
        return _getPOABlockThreshold.apply(this, arguments);
      }

      return getPOABlockThreshold;
    }()
  }, {
    key: "getSolanaSlotThreshold",
    value: function () {
      var _getSolanaSlotThreshold = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var currentSlot, threshold;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!(this.lastSolanaThreshold && (Date.now() - this.lastSolanaThreshold.time) / 1000 < this.allowedStalenessSec)) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return", this.lastSolanaThreshold.threshold);

              case 2:
                _context8.next = 4;
                return this.libs.solanaWeb3Manager.getSlot();

              case 4:
                currentSlot = _context8.sent;
                threshold = currentSlot - this.runBehindSec / this.solanaSecPerSlot;
                this.lastSolanaThreshold = {
                  threshold: threshold,
                  time: Date.now()
                };
                return _context8.abrupt("return", threshold);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getSolanaSlotThreshold() {
        return _getSolanaSlotThreshold.apply(this, arguments);
      }

      return getSolanaSlotThreshold;
    }()
  }]);

  return AttestationDelayCalculator;
}();
/**
 * `RewardsAttester` is responsible for repeatedly attesting for completed rewards.
 *
 * **Implementation**
 *
 * `RewardsAttester` attempts to attest for `parallelization` rewards in parallel.
 * It won't move onto the next batch of rewards until every reward in that batch has
 * either succeeded or failed attestation. It retries errors that might be due to DN
 * timing issues, and skips AAO errors and some Solana program errors.
 *
 * Internally, state is tracked with two variables: `offset` and `startingBlock`.
 * `startingBlock` represents which block it start requesting attestations from, while `offset` determines
 * where within those results we offset. AAO rejected rewards
 * are never cleared from the DN rewards queue, so we have to move past them either with `offset` or `startingBlock`.
 * `RewardsAttester` accepts callbacks (`updateValues`) for a client to persist these values periodically.
 *
 * RewardsAttester will fetch a single large list of undisbursed rewards (`undisbursedQueue`), and
 * process that entire list before fetching new undisbursed rewards. It also maintains a list of
 * recently processed rewards, and filters those out when re-fetching new undisbursed rewards.
 */

var RewardsAttester = /*#__PURE__*/function () {
  /**
   * Creates an instance of RewardsAttester.
   * @memberof RewardsAttester
   */
  function RewardsAttester(_ref3) {
    var libs = _ref3.libs,
        startingBlock = _ref3.startingBlock,
        offset = _ref3.offset,
        parallelization = _ref3.parallelization,
        _ref3$logger = _ref3.logger,
        logger = _ref3$logger === void 0 ? console : _ref3$logger,
        quorumSize = _ref3.quorumSize,
        aaoEndpoint = _ref3.aaoEndpoint,
        aaoAddress = _ref3.aaoAddress,
        _ref3$updateValues = _ref3.updateValues,
        updateValues = _ref3$updateValues === void 0 ? function () {} : _ref3$updateValues,
        _ref3$getStartingBloc = _ref3.getStartingBlockOverride,
        getStartingBlockOverride = _ref3$getStartingBloc === void 0 ? function () {
      return null;
    } : _ref3$getStartingBloc,
        _ref3$maxRetries = _ref3.maxRetries,
        maxRetries = _ref3$maxRetries === void 0 ? 5 : _ref3$maxRetries,
        _ref3$reporter = _ref3.reporter,
        reporter = _ref3$reporter === void 0 ? new BaseRewardsReporter() : _ref3$reporter,
        _ref3$challengeIdsDen = _ref3.challengeIdsDenyList,
        challengeIdsDenyList = _ref3$challengeIdsDen === void 0 ? [] : _ref3$challengeIdsDen,
        _ref3$endpoints = _ref3.endpoints,
        endpoints = _ref3$endpoints === void 0 ? [] : _ref3$endpoints,
        _ref3$runBehindSec = _ref3.runBehindSec,
        runBehindSec = _ref3$runBehindSec === void 0 ? 0 : _ref3$runBehindSec,
        _ref3$isSolanaChallen = _ref3.isSolanaChallenge,
        isSolanaChallenge = _ref3$isSolanaChallen === void 0 ? function (_) {
      return true;
    } : _ref3$isSolanaChallen,
        _ref3$feePayerOverrid = _ref3.feePayerOverride,
        feePayerOverride = _ref3$feePayerOverrid === void 0 ? null : _ref3$feePayerOverrid,
        _ref3$maxAggregationA = _ref3.maxAggregationAttempts,
        maxAggregationAttempts = _ref3$maxAggregationA === void 0 ? 20 : _ref3$maxAggregationA,
        _ref3$updateStateCall = _ref3.updateStateCallback,
        updateStateCallback = _ref3$updateStateCall === void 0 ? /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      return function (_x5) {
        return _ref4.apply(this, arguments);
      };
    }() : _ref3$updateStateCall,
        _ref3$maxCooldownMsec = _ref3.maxCooldownMsec,
        maxCooldownMsec = _ref3$maxCooldownMsec === void 0 ? 15000 : _ref3$maxCooldownMsec;

    _classCallCheck(this, RewardsAttester);

    this.libs = libs;
    this.logger = logger;
    this.parallelization = parallelization;
    this.startingBlock = startingBlock;
    this.offset = offset;
    this.quorumSize = quorumSize;
    this.aaoEndpoint = aaoEndpoint;
    this.aaoAddress = aaoAddress;
    this.reporter = reporter;
    this.endpoints = endpoints;
    this.endpointPool = new Set(endpoints);
    this.maxRetries = maxRetries;
    this.maxAggregationAttempts = maxAggregationAttempts;
    this.updateValues = updateValues;
    this.challengeIdsDenyList = _construct(Set, _toConsumableArray(challengeIdsDenyList));
    this.undisbursedQueue = [];
    this.recentlyDisbursedQueue = [];
    this.cooldownMsec = 2000;
    this.backoffExponent = 1.8;
    this.maxCooldownMsec = maxCooldownMsec;
    this.getStartingBlockOverride = getStartingBlockOverride;
    this.feePayerOverride = feePayerOverride;
    this.attesterState = {
      phase: 'HALTED',
      lastSuccessChallengeTime: null,
      lastChallengeTime: null,
      lastActionTime: Date.now()
    }; // Calculate delay

    this.delayCalculator = new AttestationDelayCalculator({
      libs: libs,
      runBehindSec: runBehindSec,
      logger: logger,
      allowedStalenessSec: 5
    });
    this.isSolanaChallenge = isSolanaChallenge;
    this._performSingleAttestation = this._performSingleAttestation.bind(this);
    this._disbursementToKey = this._disbursementToKey.bind(this);
    this._shouldStop = false;
    this._updateStateCallback = updateStateCallback;
    this.discoveryNodeBlocklist = [];
  }
  /**
   * Begin attestation loop. Entry point for identity attestations
   *
   * @memberof RewardsAttester
   */


  _createClass(RewardsAttester, [{
    key: "start",
    value: function () {
      var _start2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var pool, _yield$this$_refillQu, error, toAttest, _yield$this$_attestIn, highestBlock, offset, successCount;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this.logger.info("Starting attester with:\n      quorum size: ".concat(this.quorumSize, ",       parallelization: ").concat(this.parallelization, "       AAO endpoint: ").concat(this.aaoEndpoint, "       AAO address: ").concat(this.aaoAddress, "       endpoints: ").concat(this.endpoints, "\n    ")); // If a list of endpoints was not specified,
                // set the pool to the entire list of discovery providers.
                // This overrides any configured whitelist for the service selector.

                if (!(this.endpointPool.size === 0)) {
                  _context10.next = 6;
                  break;
                }

                _context10.next = 4;
                return this.libs.discoveryProvider.serviceSelector.getServices();

              case 4:
                pool = _context10.sent;
                this.endpointPool = new Set(pool);

              case 6:
                _context10.next = 8;
                return this._selectDiscoveryNodes();

              case 8:
                _context10.next = 10;
                return this.delayCalculator.start();

              case 10:
                if (this._shouldStop) {
                  _context10.next = 52;
                  break;
                }

                _context10.prev = 11;
                _context10.next = 14;
                return this._awaitFeePayerBalance();

              case 14:
                _context10.next = 16;
                return this._checkForStartingBlockOverride();

              case 16:
                _context10.next = 18;
                return this._refillQueueIfNecessary();

              case 18:
                _yield$this$_refillQu = _context10.sent;
                error = _yield$this$_refillQu.error;

                if (!error) {
                  _context10.next = 23;
                  break;
                }

                this.logger.error("Got error trying to refill challenges: [".concat(error, "]"));
                throw new Error(error);

              case 23:
                if (this.undisbursedQueue.length) {
                  _context10.next = 30;
                  break;
                }

                this.logger.info('No undisbursed challenges. Sleeping...');
                _context10.next = 27;
                return this._updatePhase('SLEEPING');

              case 27:
                _context10.next = 29;
                return this._delay(1000);

              case 29:
                return _context10.abrupt("continue", 10);

              case 30:
                // Get undisbursed rewards
                toAttest = this.undisbursedQueue.splice(0, this.parallelization); // Attest for batch in parallel

                _context10.next = 33;
                return this._attestInParallel(toAttest);

              case 33:
                _yield$this$_attestIn = _context10.sent;
                highestBlock = _yield$this$_attestIn.highestBlock;
                offset = _yield$this$_attestIn.offset;
                successCount = _yield$this$_attestIn.successCount;

                // Set state
                // Set offset:
                // - If same startingBlock as before, add offset
                // - If new startingBlock, set offset
                if (highestBlock && this.startingBlock === highestBlock - 1) {
                  this.offset += offset;
                } else {
                  this.offset = offset;
                }

                this.logger.info("Updating values: startingBlock: ".concat(this.startingBlock, ", offset: ").concat(this.offset));
                this.startingBlock = highestBlock ? highestBlock - 1 : this.startingBlock; // Set the recently disbursed set

                this._addRecentlyDisbursed(toAttest); // run the `updateValues` callback


                _context10.next = 43;
                return this.updateValues({
                  startingBlock: this.startingBlock,
                  offset: this.offset,
                  successCount: successCount
                });

              case 43:
                _context10.next = 50;
                break;

              case 45:
                _context10.prev = 45;
                _context10.t0 = _context10["catch"](11);
                this.logger.error("Got error: ".concat(_context10.t0, ", sleeping"));
                _context10.next = 50;
                return this._delay(1000);

              case 50:
                _context10.next = 10;
                break;

              case 52:
                this._shouldStop = false;

              case 53:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[11, 45]]);
      }));

      function start() {
        return _start2.apply(this, arguments);
      }

      return start;
    }()
  }, {
    key: "stop",
    value: function () {
      var _stop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this._shouldStop = true;
                this.delayCalculator.stop();

              case 2:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function stop() {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
    /**
     * Called from the client to attest challenges
     */

  }, {
    key: "processChallenges",
    value: function () {
      var _processChallenges = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(challenges) {
        var toProcess, toAttest, _yield$this$_attestIn2, errors;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this._selectDiscoveryNodes();

              case 2:
                toProcess = _toConsumableArray(challenges);

              case 3:
                if (!toProcess.length) {
                  _context12.next = 23;
                  break;
                }

                _context12.prev = 4;
                this.logger.info("Processing ".concat(toProcess.length, " challenges"));
                toAttest = toProcess.splice(0, this.parallelization);
                _context12.next = 9;
                return this._attestInParallel(toAttest);

              case 9:
                _yield$this$_attestIn2 = _context12.sent;
                errors = _yield$this$_attestIn2.accumulatedErrors;

                if (!(errors !== null && errors !== void 0 && errors.length)) {
                  _context12.next = 14;
                  break;
                }

                this.logger.error("Got errors in processChallenges: ".concat(JSON.stringify(errors)));
                return _context12.abrupt("return", {
                  errors: errors
                });

              case 14:
                _context12.next = 21;
                break;

              case 16:
                _context12.prev = 16;
                _context12.t0 = _context12["catch"](4);
                this.logger.error("Got error: ".concat(_context12.t0, ", sleeping"));
                _context12.next = 21;
                return this._delay(1000);

              case 21:
                _context12.next = 3;
                break;

              case 23:
                return _context12.abrupt("return", {});

              case 24:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[4, 16]]);
      }));

      function processChallenges(_x6) {
        return _processChallenges.apply(this, arguments);
      }

      return processChallenges;
    }()
    /**
     * Updates attester config
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "updateConfig",
    value: function updateConfig(_ref5) {
      var aaoEndpoint = _ref5.aaoEndpoint,
          aaoAddress = _ref5.aaoAddress,
          endpoints = _ref5.endpoints,
          challengeIdsDenyList = _ref5.challengeIdsDenyList,
          parallelization = _ref5.parallelization;
      this.logger.info("Updating attester with config aaoEndpoint: ".concat(aaoEndpoint, ", aaoAddress: ").concat(aaoAddress, ", endpoints: ").concat(endpoints, ", challengeIdsDenyList: ").concat(challengeIdsDenyList, ", parallelization: ").concat(parallelization));
      this.aaoEndpoint = aaoEndpoint || this.aaoEndpoint;
      this.aaoAddress = aaoAddress || this.aaoAddress;
      this.endpoints = endpoints || this.endpoints;
      this.challengeIdsDenyList = challengeIdsDenyList ? _construct(Set, _toConsumableArray(challengeIdsDenyList)) : this.challengeIdsDenyList;
      this.parallelization = parallelization || this.parallelization;
    }
    /**
     * Sleeps until the feePayer has a usable Sol balance.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_awaitFeePayerBalance",
    value: function () {
      var _awaitFeePayerBalance2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var _this2 = this;

        var getHasBalance;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                getHasBalance = /*#__PURE__*/function () {
                  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
                    return regeneratorRuntime.wrap(function _callee13$(_context13) {
                      while (1) {
                        switch (_context13.prev = _context13.next) {
                          case 0:
                            return _context13.abrupt("return", _this2.libs.solanaWeb3Manager.hasBalance({
                              publicKey: _this2.libs.solanaWeb3Manager.feePayerKey
                            }));

                          case 1:
                          case "end":
                            return _context13.stop();
                        }
                      }
                    }, _callee13);
                  }));

                  return function getHasBalance() {
                    return _ref6.apply(this, arguments);
                  };
                }();

              case 1:
                _context14.next = 3;
                return getHasBalance();

              case 3:
                if (_context14.sent) {
                  _context14.next = 9;
                  break;
                }

                this.logger.warn('No usable balance. Waiting...');
                _context14.next = 7;
                return this._delay(2000);

              case 7:
                _context14.next = 1;
                break;

              case 9:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function _awaitFeePayerBalance() {
        return _awaitFeePayerBalance2.apply(this, arguments);
      }

      return _awaitFeePayerBalance;
    }()
    /**
     * Returns the override feePayer if set, otherwise a random fee payer from among the list of existing fee payers.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_getFeePayer",
    value: function _getFeePayer() {
      if (this.feePayerOverride) {
        return this.feePayerOverride;
      }

      var feePayerKeypairs = this.libs.solanaWeb3Manager.solanaWeb3Config.feePayerKeypairs;

      if (feePayerKeypairs !== null && feePayerKeypairs !== void 0 && feePayerKeypairs.length) {
        var randomFeePayerIndex = Math.floor(Math.random() * feePayerKeypairs.length);
        return feePayerKeypairs[randomFeePayerIndex].publicKey;
      }

      return null;
    }
    /**
     * Escape hatch for manually setting starting block.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_checkForStartingBlockOverride",
    value: function () {
      var _checkForStartingBlockOverride2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        var override;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.getStartingBlockOverride();

              case 2:
                override = _context15.sent;

                if (!(override === null || override === undefined)) {
                  _context15.next = 5;
                  break;
                }

                return _context15.abrupt("return");

              case 5:
                this.logger.info("Setting starting block override: ".concat(override, ", emptying recent disbursed queue"));
                this.startingBlock = override;
                this.offset = 0;
                this.recentlyDisbursedQueue = [];
                this.undisbursedQueue = [];
                this.discoveryNodeBlocklist = [];

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function _checkForStartingBlockOverride() {
        return _checkForStartingBlockOverride2.apply(this, arguments);
      }

      return _checkForStartingBlockOverride;
    }()
    /**
     * Main method to attest for a bucket of challenges in parallel.
     *
     * Algorithm:
     * - Gets `this.parallelization` undisbursed challenges from the queue, refilling it from DN if necessary.
     * - Call `_performSingleAttestation` on those in parallel.
     * - For challenges that failed, either keep retrying or discard them, depending on the error.
     * - Set offset and startingBlock
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_attestInParallel",
    value: function () {
      var _attestInParallel2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(toAttest) {
        var _this3 = this;

        var poaAttestations, highestBlock, retryCount, successful, noRetry, needsAttestation, shouldReselect, accumulatedErrors, successCount, offset, failingNodes, _failingNodes, results, _yield$this$_processR;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                this.logger.info("Attesting in parallel with startingBlock: ".concat(this.startingBlock, ", offset: ").concat(this.offset, ", parallelization: ").concat(this.parallelization));
                _context16.next = 3;
                return this._updatePhase('ATTESTING');

              case 3:
                // Get the highest block number, ignoring Solana based challenges (i.e. listens) which have a significantly higher
                // slot and throw off this calculation.
                // TODO: [AUD-1217] we should handle this in a less hacky way, possibly by
                // attesting for Solana + POA challenges separately.
                poaAttestations = toAttest.filter(function (_ref7) {
                  var challengeId = _ref7.challengeId;
                  return !_this3.isSolanaChallenge(challengeId);
                });
                highestBlock = poaAttestations.length ? Math.max.apply(Math, _toConsumableArray(poaAttestations.map(function (e) {
                  return e.completedBlocknumber;
                }))) : null;
                retryCount = 0;
                successful = [];
                noRetry = [];
                needsAttestation = toAttest;
                shouldReselect = false;
                accumulatedErrors = [];
                successCount = 0;
                offset = 0;
                failingNodes = [];

              case 14:
                _context16.next = 16;
                return this._updatePhase('ATTESTING');

              case 16:
                if (!(retryCount !== 0)) {
                  _context16.next = 19;
                  break;
                }

                _context16.next = 19;
                return this._backoff(retryCount);

              case 19:
                this.logger.info("Attestation attempt ".concat(retryCount + 1, ", max ").concat(this.maxRetries));

                if (!shouldReselect) {
                  _context16.next = 23;
                  break;
                }

                _context16.next = 23;
                return this._selectDiscoveryNodes();

              case 23:
                _context16.next = 25;
                return Promise.all(needsAttestation.map(this._performSingleAttestation));

              case 25:
                results = _context16.sent;
                _context16.next = 28;
                return this._processResponses(results, retryCount === this.maxRetries - 1);

              case 28:
                _yield$this$_processR = _context16.sent;
                successful = _yield$this$_processR.successful;
                noRetry = _yield$this$_processR.noRetry;
                needsAttestation = _yield$this$_processR.needsRetry;
                shouldReselect = _yield$this$_processR.shouldReselect;
                failingNodes = _yield$this$_processR.failingNodes;

                // Add failing nodes to the blocklist, trimming out oldest nodes if necessary
                if ((_failingNodes = failingNodes) !== null && _failingNodes !== void 0 && _failingNodes.length) {
                  (function () {
                    var existing = new Set(_this3.discoveryNodeBlocklist);
                    failingNodes.forEach(function (n) {
                      if (!existing.has(n)) {
                        _this3.discoveryNodeBlocklist.push(n);
                      }
                    });
                    _this3.discoveryNodeBlocklist = _this3.discoveryNodeBlocklist.slice(-1 * MAX_DISCOVERY_NODE_BLOCKLIST_LEN);
                  })();
                }

                successCount += successful.length;
                accumulatedErrors = [].concat(_toConsumableArray(accumulatedErrors), _toConsumableArray(noRetry)); // Increment offset by the # of errors we're not retrying that have the max block #.
                //
                // Note: any successfully completed rewards will eventually be flushed from the
                // disbursable queue on DN, but ignored rewards will stay stuck in that list, so we
                // have to move past them with offset if they're not already moved past with `startingBlock`.

                offset += noRetry.filter(function (_ref8) {
                  var completedBlocknumber = _ref8.completedBlocknumber;
                  return completedBlocknumber === highestBlock;
                }).length;
                retryCount++;

              case 39:
                if (needsAttestation.length && retryCount < this.maxRetries) {
                  _context16.next = 14;
                  break;
                }

              case 40:
                if (retryCount === this.maxRetries) {
                  this.logger.error("Gave up with ".concat(retryCount, " retries"));
                }

                return _context16.abrupt("return", {
                  accumulatedErrors: accumulatedErrors,
                  highestBlock: highestBlock,
                  offset: offset,
                  successCount: successCount
                });

              case 42:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function _attestInParallel(_x7) {
        return _attestInParallel2.apply(this, arguments);
      }

      return _attestInParallel;
    }()
    /**
     * Attempts to attest for a single challenge.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_performSingleAttestation",
    value: function () {
      var _performSingleAttestation2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(_ref9) {
        var challengeId, userId, specifier, amount, handle, wallet, completedBlocknumber, _yield$this$libs$Rewa, success, error, phase, nodesToReselect;

        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                challengeId = _ref9.challengeId, userId = _ref9.userId, specifier = _ref9.specifier, amount = _ref9.amount, handle = _ref9.handle, wallet = _ref9.wallet, completedBlocknumber = _ref9.completedBlocknumber;
                this.logger.info("Attempting to attest for userId [".concat(decodeHashId(userId), "], challengeId: [").concat(challengeId, "], quorum size: [").concat(this.quorumSize, "]}"));
                _context17.next = 4;
                return this.libs.Rewards.submitAndEvaluate({
                  challengeId: challengeId,
                  encodedUserId: userId,
                  handle: handle,
                  recipientEthAddress: wallet,
                  specifier: specifier,
                  oracleEthAddress: this.aaoAddress,
                  amount: amount,
                  quorumSize: this.quorumSize,
                  AAOEndpoint: this.aaoEndpoint,
                  endpoints: this.endpoints,
                  logger: this.logger,
                  feePayerOverride: this._getFeePayer(),
                  maxAggregationAttempts: this.maxAggregationAttempts
                });

              case 4:
                _yield$this$libs$Rewa = _context17.sent;
                success = _yield$this$libs$Rewa.success;
                error = _yield$this$libs$Rewa.error;
                phase = _yield$this$libs$Rewa.phase;
                nodesToReselect = _yield$this$libs$Rewa.nodesToReselect;

                if (!success) {
                  _context17.next = 12;
                  break;
                }

                this.logger.info("Successfully attestested for challenge [".concat(challengeId, "] for user [").concat(decodeHashId(userId), "], amount [").concat(amount, "]!"));
                return _context17.abrupt("return", {
                  challengeId: challengeId,
                  userId: userId,
                  specifier: specifier,
                  amount: amount,
                  handle: handle,
                  wallet: wallet,
                  completedBlocknumber: completedBlocknumber,
                  nodesToReselect: null
                });

              case 12:
                // Handle error path
                this.logger.error("Failed to attest for challenge [".concat(challengeId, "] for user [").concat(decodeHashId(userId), "], amount [").concat(amount, "], oracle: [").concat(this.aaoAddress, "] at phase: [").concat(phase, "] with error [").concat(error, "]"));
                return _context17.abrupt("return", {
                  challengeId: challengeId,
                  userId: userId,
                  specifier: specifier,
                  amount: amount,
                  handle: handle,
                  wallet: wallet,
                  completedBlocknumber: completedBlocknumber,
                  error: error,
                  phase: phase,
                  nodesToReselect: nodesToReselect
                });

              case 14:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _performSingleAttestation(_x8) {
        return _performSingleAttestation2.apply(this, arguments);
      }

      return _performSingleAttestation;
    }()
  }, {
    key: "_selectDiscoveryNodes",
    value: function () {
      var _selectDiscoveryNodes2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
        var _yield$this$libs$disc;

        var startTime, endpoints, blockSet;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this._updatePhase('SELECTING_NODES');

              case 2:
                this.logger.info("Selecting discovery nodes with blocklist ".concat(JSON.stringify(this.discoveryNodeBlocklist)));
                startTime = Date.now();
                _context18.next = 6;
                return this.libs.discoveryProvider.serviceSelector.findAll({
                  verbose: true,
                  whitelist: this.endpointPool.size > 0 ? this.endpointPool : null
                });

              case 6:
                _context18.t1 = _yield$this$libs$disc = _context18.sent;
                _context18.t0 = _context18.t1 !== null;

                if (!_context18.t0) {
                  _context18.next = 10;
                  break;
                }

                _context18.t0 = _yield$this$libs$disc !== void 0;

              case 10:
                if (!_context18.t0) {
                  _context18.next = 14;
                  break;
                }

                _context18.t2 = _yield$this$libs$disc;
                _context18.next = 15;
                break;

              case 14:
                _context18.t2 = [];

              case 15:
                endpoints = _context18.t2;
                // Filter out blocklisted nodes
                blockSet = new Set(this.discoveryNodeBlocklist);
                endpoints = _toConsumableArray(endpoints).filter(function (e) {
                  return !blockSet.has(e.endpoint);
                });
                _context18.next = 20;
                return this.libs.Rewards.ServiceProvider.getUniquelyOwnedDiscoveryNodes(this.quorumSize, endpoints);

              case 20:
                this.endpoints = _context18.sent;
                this.logger.info("Selected new discovery nodes in ".concat((Date.now() - startTime) / 1000, " seconds: [").concat(this.endpoints, "]"));

              case 22:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function _selectDiscoveryNodes() {
        return _selectDiscoveryNodes2.apply(this, arguments);
      }

      return _selectDiscoveryNodes;
    }()
    /**
     * Fetches new undisbursed rewards and inserts them into the undisbursedQueue
     * if the queue is currently empty.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_refillQueueIfNecessary",
    value: function () {
      var _refillQueueIfNecessary2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
        var _this4 = this;

        var _yield$this$libs$Rewa2, disbursable, error;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!this.undisbursedQueue.length) {
                  _context19.next = 2;
                  break;
                }

                return _context19.abrupt("return", {});

              case 2:
                this.logger.info("Refilling queue with startingBlock: ".concat(this.startingBlock, ", offset: ").concat(this.offset, ", recently disbursed: ").concat(JSON.stringify(this.recentlyDisbursedQueue)));
                _context19.next = 5;
                return this._updatePhase('REFILLING_QUEUE');

              case 5:
                _context19.next = 7;
                return this.libs.Rewards.getUndisbursedChallenges({
                  offset: this.offset,
                  completedBlockNumber: this.startingBlock,
                  logger: this.logger
                });

              case 7:
                _yield$this$libs$Rewa2 = _context19.sent;
                disbursable = _yield$this$libs$Rewa2.success;
                error = _yield$this$libs$Rewa2.error;

                if (!error) {
                  _context19.next = 12;
                  break;
                }

                return _context19.abrupt("return", {
                  error: error
                });

              case 12:
                if (disbursable !== null && disbursable !== void 0 && disbursable.length) {
                  this.logger.info("Got challenges: ".concat(disbursable.map(function (_ref10 // eslint-disable-line
                  ) {
                    var challenge_id = _ref10.challenge_id,
                        user_id = _ref10.user_id,
                        specifier = _ref10.specifier;
                    return "".concat(challenge_id, "-").concat(user_id, "-").concat(specifier);
                  }))); // eslint-disable-line
                } // Map to camelCase, and filter out
                // any challenges in the denylist or recently disbursed set


                this.undisbursedQueue = disbursable.map(function (_ref11) {
                  var challenge_id = _ref11.challenge_id,
                      user_id = _ref11.user_id,
                      specifier = _ref11.specifier,
                      amount = _ref11.amount,
                      handle = _ref11.handle,
                      wallet = _ref11.wallet,
                      completed_blocknumber = _ref11.completed_blocknumber;
                  return {
                    challengeId: challenge_id,
                    userId: user_id,
                    specifier: specifier,
                    amount: amount,
                    handle: handle,
                    wallet: wallet,
                    completedBlocknumber: completed_blocknumber
                  };
                }).filter(function (d) {
                  return !(_this4.challengeIdsDenyList.has(d.challengeId) || new Set(_this4.recentlyDisbursedQueue).has(_this4._disbursementToKey(d)));
                }); // Filter out recently disbursed challenges

                if (!this.undisbursedQueue.length) {
                  _context19.next = 18;
                  break;
                }

                _context19.next = 17;
                return this._filterRecentlyCompleted(this.undisbursedQueue);

              case 17:
                this.undisbursedQueue = _context19.sent;

              case 18:
                this.logger.info("Got ".concat(disbursable.length, " undisbursed challenges").concat(this.undisbursedQueue.length !== disbursable.length ? ", filtered out [".concat(disbursable.length - this.undisbursedQueue.length, "] challenges.") : '.'));
                return _context19.abrupt("return", {});

              case 20:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _refillQueueIfNecessary() {
        return _refillQueueIfNecessary2.apply(this, arguments);
      }

      return _refillQueueIfNecessary;
    }()
    /**
     * Processes responses from `_performSingleAttestation`,
     * bucketing errors into those that need retry and those that should be skipped.
     *
     * @memberof RewardsAttester
     */

  }, {
    key: "_processResponses",
    value: function () {
      var _processResponses2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(responses, isFinalAttempt) {
        var _this5 = this;

        var errors, AAO_ERRORS, NEEDS_RESELECT_ERRORS, ALREADY_COMPLETE_ERRORS, noRetry, successful, allErrors, stillIncomplete, needsRetry, shouldReselect, failingNodes, now, update;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                errors = SubmitAndEvaluateError_1;
                AAO_ERRORS = new Set([errors.HCAPTCHA, errors.COGNITO_FLOW, errors.AAO_ATTESTATION_REJECTION, errors.AAO_ATTESTATION_UNKNOWN_RESPONSE]); // Account for errors from DN aggregation + Solana program
                // CHALLENGE_INCOMPLETE and MISSING_CHALLENGES are already handled in the `submitAndEvaluate` flow -
                // safe to assume those won't work if we see them at this point.

                NEEDS_RESELECT_ERRORS = new Set([errors.INSUFFICIENT_DISCOVERY_NODE_COUNT, errors.CHALLENGE_INCOMPLETE, errors.MISSING_CHALLENGES]);
                ALREADY_COMPLETE_ERRORS = new Set([errors.ALREADY_DISBURSED, errors.ALREADY_SENT]);
                noRetry = [];
                successful = []; // Filter our successful responses

                allErrors = responses.filter(function (res) {
                  if (!res.error) {
                    var _decodeHashId;

                    successful.push(res);

                    _this5.reporter.reportSuccess({
                      userId: (_decodeHashId = decodeHashId(res.userId)) !== null && _decodeHashId !== void 0 ? _decodeHashId : -1,
                      challengeId: res.challengeId,
                      amount: res.amount,
                      specifier: res.specifier
                    });

                    return false;
                  }

                  return true;
                }); // Filter out responses that are already disbursed

                stillIncomplete = allErrors.filter(function (_ref12) {
                  var error = _ref12.error;
                  return !ALREADY_COMPLETE_ERRORS.has(error);
                }); // Filter to errors needing retry

                needsRetry = stillIncomplete.filter(function (res) {
                  var _decodeHashId2;

                  var report = {
                    userId: (_decodeHashId2 = decodeHashId(res.userId)) !== null && _decodeHashId2 !== void 0 ? _decodeHashId2 : -1,
                    challengeId: res.challengeId,
                    amount: res.amount,
                    error: res.error,
                    phase: res.phase,
                    specifier: res.specifier,
                    reason: 'unknown'
                  };

                  function getIsAAOError(err) {
                    return !!err && AAO_ERRORS.has(err);
                  }

                  var error = res.error;
                  var isAAOError = getIsAAOError(error); // Filter out and handle unretryable AAO errors

                  if (isAAOError) {
                    var _errors$HCAPTCHA$erro;

                    noRetry.push(res);
                    var errorType = (_errors$HCAPTCHA$erro = {}, _defineProperty(_errors$HCAPTCHA$erro, errors.HCAPTCHA, 'hcaptcha'), _defineProperty(_errors$HCAPTCHA$erro, errors.COGNITO_FLOW, 'cognito'), _defineProperty(_errors$HCAPTCHA$erro, errors.AAO_ATTESTATION_REJECTION, 'rejection'), _defineProperty(_errors$HCAPTCHA$erro, errors.AAO_ATTESTATION_UNKNOWN_RESPONSE, 'unknown'), _errors$HCAPTCHA$erro)[error];
                    report.reason = errorType;

                    _this5.reporter.reportAAORejection(report);
                  } else if (isFinalAttempt) {
                    // Final attempt at retries,
                    // should be classified as noRetry
                    // and reported as a failure
                    noRetry.push(res);

                    _this5.reporter.reportFailure(report);
                  } else {
                    // Otherwise, retry it
                    _this5.reporter.reportRetry(report);
                  }

                  return !isAAOError && !isFinalAttempt;
                });

                if (needsRetry.length) {
                  this.logger.info("Handling errors: ".concat(JSON.stringify(needsRetry.map(function (_ref13) {
                    var error = _ref13.error,
                        phase = _ref13.phase;
                    return {
                      error: error,
                      phase: phase
                    };
                  }))));
                } // Reselect if necessary


                shouldReselect = needsRetry.some(function (_ref14) {
                  var error = _ref14.error;
                  return NEEDS_RESELECT_ERRORS.has(error);
                });
                failingNodes = [];

                if (shouldReselect) {
                  failingNodes = _toConsumableArray(needsRetry.reduce(function (acc, cur) {
                    if (cur.nodesToReselect) {
                      var _cur$nodesToReselect;

                      (_cur$nodesToReselect = cur.nodesToReselect) === null || _cur$nodesToReselect === void 0 ? void 0 : _cur$nodesToReselect.forEach(function (n) {
                        return acc.add(n);
                      });
                    }

                    return acc;
                  }, new Set()));
                  this.logger.info("Failing nodes: ".concat(JSON.stringify(failingNodes)));
                } // Update state


                now = Date.now();
                update = {
                  lastChallengeTime: now
                };

                if (successful.length) {
                  update = _objectSpread2(_objectSpread2({}, update), {}, {
                    lastSuccessChallengeTime: now
                  });
                }

                _context20.next = 18;
                return this._updateState(update);

              case 18:
                return _context20.abrupt("return", {
                  successful: successful,
                  noRetry: noRetry,
                  needsRetry: needsRetry,
                  shouldReselect: shouldReselect,
                  failingNodes: failingNodes
                });

              case 19:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function _processResponses(_x9, _x10) {
        return _processResponses2.apply(this, arguments);
      }

      return _processResponses;
    }()
  }, {
    key: "_disbursementToKey",
    value: function _disbursementToKey(_ref15) {
      var challengeId = _ref15.challengeId,
          userId = _ref15.userId,
          specifier = _ref15.specifier;
      return "".concat(challengeId, "_").concat(userId, "_").concat(specifier);
    }
  }, {
    key: "_backoff",
    value: function () {
      var _backoff2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(retryCount) {
        var backoff;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                backoff = Math.min(this.cooldownMsec * Math.pow(this.backoffExponent, retryCount), this.maxCooldownMsec);
                this.logger.info("Waiting [".concat(backoff, "] msec"));
                _context21.next = 4;
                return this._updatePhase('RETRY_BACKOFF');

              case 4:
                _context21.next = 6;
                return this._delay(backoff);

              case 6:
                return _context21.abrupt("return", _context21.sent);

              case 7:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function _backoff(_x11) {
        return _backoff2.apply(this, arguments);
      }

      return _backoff;
    }()
  }, {
    key: "_delay",
    value: function () {
      var _delay2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(waitTime) {
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, waitTime);
                });

              case 2:
                return _context22.abrupt("return", _context22.sent);

              case 3:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22);
      }));

      function _delay(_x12) {
        return _delay2.apply(this, arguments);
      }

      return _delay;
    }()
  }, {
    key: "_addRecentlyDisbursed",
    value: function _addRecentlyDisbursed(challenges) {
      var _this$recentlyDisburs;

      var ids = challenges.map(this._disbursementToKey);

      (_this$recentlyDisburs = this.recentlyDisbursedQueue).push.apply(_this$recentlyDisburs, _toConsumableArray(ids));

      if (this.recentlyDisbursedQueue.length > MAX_DISBURSED_CACHE_SIZE) {
        this.recentlyDisbursedQueue.splice(0, this.recentlyDisbursedQueue.length - MAX_DISBURSED_CACHE_SIZE);
      }
    }
  }, {
    key: "_filterRecentlyCompleted",
    value: function () {
      var _filterRecentlyCompleted2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(challenges) {
        var _this6 = this;

        var _yield$Promise$all, _yield$Promise$all2, poaThreshold, solanaThreshold, res;

        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return Promise.all([this.delayCalculator.getPOABlockThreshold(), this.delayCalculator.getSolanaSlotThreshold()]);

              case 2:
                _yield$Promise$all = _context23.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                poaThreshold = _yield$Promise$all2[0];
                solanaThreshold = _yield$Promise$all2[1];
                this.logger.info("Filtering with POA threshold: ".concat(poaThreshold, ", Solana threshold: ").concat(solanaThreshold));
                res = challenges.filter(function (c) {
                  return c.completedBlocknumber <= (_this6.isSolanaChallenge(c.challengeId) ? solanaThreshold : poaThreshold);
                });

                if (res.length < challenges.length) {
                  this.logger.info("Filtered out ".concat(challenges.length - res.length, " recent challenges"));
                }

                return _context23.abrupt("return", res);

              case 10:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function _filterRecentlyCompleted(_x13) {
        return _filterRecentlyCompleted2.apply(this, arguments);
      }

      return _filterRecentlyCompleted;
    }()
  }, {
    key: "_updateState",
    value: function () {
      var _updateState2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(newState) {
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.prev = 0;
                this.attesterState = _objectSpread2(_objectSpread2(_objectSpread2({}, this.attesterState), newState), {}, {
                  lastActionTime: Date.now()
                });
                _context24.next = 4;
                return this._updateStateCallback(this.attesterState);

              case 4:
                _context24.next = 9;
                break;

              case 6:
                _context24.prev = 6;
                _context24.t0 = _context24["catch"](0);
                this.logger.error("Got error updating state: ".concat(_context24.t0));

              case 9:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this, [[0, 6]]);
      }));

      function _updateState(_x14) {
        return _updateState2.apply(this, arguments);
      }

      return _updateState;
    }()
  }, {
    key: "_updatePhase",
    value: function () {
      var _updatePhase2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(phase) {
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this._updateState({
                  phase: phase
                });

              case 2:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function _updatePhase(_x15) {
        return _updatePhase2.apply(this, arguments);
      }

      return _updatePhase;
    }()
  }]);

  return RewardsAttester;
}();

var rewardsAttester = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AttestationDelayCalculator: AttestationDelayCalculator,
  RewardsAttester: RewardsAttester
});

var require$$29 = /*@__PURE__*/getAugmentedNamespace(rewardsAttester);

(function (module, exports) {
  var packageJSON = require$$0$2;
  var EthWeb3Manager = require$$1.EthWeb3Manager;
  var SolanaAudiusData = require$$2$2.SolanaAudiusData;
  var Web3Manager = require$$3.Web3Manager;
  var EthContracts = require$$4$1.EthContracts;
  var SolanaWeb3Manager = solanaWeb3Manager;
  var AudiusContracts = dataContracts;
  var IdentityService = require$$7.IdentityService;
  var Comstock = require$$8.Comstock;
  var Hedgehog = require$$9.Hedgehog;
  var CreatorNode = require$$10.CreatorNode;
  var DiscoveryProvider = require$$11.DiscoveryProvider;
  var Oauth = require$$12.Oauth;
  var Wormhole = wormhole;
  var AudiusABIDecoder = require$$14.AudiusABIDecoder;
  var SchemaValidator = require$$15.SchemaValidator;
  var UserStateManager = require$$16.UserStateManager;
  var SanityChecks = sanityChecks;
  var Utils = require$$18.Utils,
      Captcha = require$$18.Captcha;
  var Account = account;
  var User = user.exports;
  var Track = track;
  var Playlist = playlist;
  var File = file;
  var Rewards = rewards.exports;
  var ServiceProvider = serviceProvider;
  var Web3 = web3;
  var SolanaUtils = utils;
  var Keypair = require$$1__default["default"].Keypair;
  var PublicKey = require$$1__default["default"].PublicKey;
  var RewardsAttester = require$$29.RewardsAttester;

  var AudiusLibs = /*#__PURE__*/function () {
    /**
     * Constructs an Audius Libs instance with configs.
     * Unless default-valued, all configs are optional.
     * @example
     *  const audius = AudiusLibs({
     *    discoveryProviderConfig: configDiscoveryProvider(),
     *    creatorNodeConfig: configCreatorNode('https://my-creator.node')
     *  })
     *  await audius.init()
     */
    function AudiusLibs(_ref) {
      var web3Config = _ref.web3Config,
          ethWeb3Config = _ref.ethWeb3Config,
          solanaWeb3Config = _ref.solanaWeb3Config,
          solanaAudiusDataConfig = _ref.solanaAudiusDataConfig,
          identityServiceConfig = _ref.identityServiceConfig,
          discoveryProviderConfig = _ref.discoveryProviderConfig,
          creatorNodeConfig = _ref.creatorNodeConfig,
          comstockConfig = _ref.comstockConfig,
          wormholeConfig = _ref.wormholeConfig,
          captchaConfig = _ref.captchaConfig,
          isServer = _ref.isServer,
          _ref$logger = _ref.logger,
          logger = _ref$logger === void 0 ? console : _ref$logger,
          _ref$isDebug = _ref.isDebug,
          isDebug = _ref$isDebug === void 0 ? false : _ref$isDebug,
          _ref$preferHigherPatc = _ref.preferHigherPatchForPrimary,
          preferHigherPatchForPrimary = _ref$preferHigherPatc === void 0 ? true : _ref$preferHigherPatc,
          _ref$preferHigherPatc2 = _ref.preferHigherPatchForSecondaries,
          preferHigherPatchForSecondaries = _ref$preferHigherPatc2 === void 0 ? true : _ref$preferHigherPatc2;

      _classCallCheck(this, AudiusLibs);

      // set version
      this.version = packageJSON.version;
      this.ethWeb3Config = ethWeb3Config;
      this.web3Config = web3Config;
      this.solanaWeb3Config = solanaWeb3Config;
      this.solanaAudiusDataConfig = solanaAudiusDataConfig;
      this.identityServiceConfig = identityServiceConfig;
      this.creatorNodeConfig = creatorNodeConfig;
      this.discoveryProviderConfig = discoveryProviderConfig;
      this.comstockConfig = comstockConfig;
      this.wormholeConfig = wormholeConfig;
      this.captchaConfig = captchaConfig;
      this.isServer = isServer;
      this.isDebug = isDebug;
      this.logger = logger;
      this.AudiusABIDecoder = AudiusABIDecoder;
      this.Utils = Utils; // Services to initialize. Initialized in .init().

      this.userStateManager = null;
      this.identityService = null;
      this.hedgehog = null;
      this.discoveryProvider = null;
      this.oauth = null;
      this.ethWeb3Manager = null;
      this.ethContracts = null;
      this.web3Manager = null;
      this.solanaWeb3Manager = null;
      this.anchorAudiusData = null;
      this.contracts = null;
      this.creatorNode = null; // API

      this.Account = null;
      this.User = null;
      this.Track = null;
      this.Playlist = null;
      this.File = null;
      this.Rewards = null;
      this.preferHigherPatchForPrimary = preferHigherPatchForPrimary;
      this.preferHigherPatchForSecondaries = preferHigherPatchForSecondaries; // Schemas

      var schemaValidator = new SchemaValidator();
      schemaValidator.init();
      this.schemas = schemaValidator.getSchemas();
    }
    /** Init services based on presence of a relevant config. */


    _createClass(AudiusLibs, [{
      key: "init",
      value: function () {
        var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var contractsToInit, currentUser, creatorNodeEndpoint, services;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.userStateManager = new UserStateManager(); // Config external web3 is an async function, so await it here in case it needs to be

                  _context.next = 3;
                  return this.web3Config;

                case 3:
                  this.web3Config = _context.sent;

                  /** Captcha */
                  if (this.captchaConfig) {
                    this.captcha = new Captcha(this.captchaConfig);
                  }
                  /** Identity Service */


                  if (!this.identityServiceConfig) {
                    _context.next = 10;
                    break;
                  }

                  this.identityService = new IdentityService(this.identityServiceConfig.url, this.captcha);
                  this.hedgehog = new Hedgehog(this.identityService, this.identityServiceConfig.useHedgehogLocalStorage);
                  _context.next = 12;
                  break;

                case 10:
                  if (!(this.web3Config && !this.web3Config.useExternalWeb3)) {
                    _context.next = 12;
                    break;
                  }

                  throw new Error('Identity Service required for internal Web3');

                case 12:
                  /** Web3 Managers */
                  if (this.ethWeb3Config) {
                    this.ethWeb3Manager = new EthWeb3Manager(this.ethWeb3Config, this.identityService, this.hedgehog);
                  }

                  if (!this.web3Config) {
                    _context.next = 18;
                    break;
                  }

                  this.web3Manager = new Web3Manager(this.web3Config, this.identityService, this.hedgehog, this.isServer);
                  _context.next = 17;
                  return this.web3Manager.init();

                case 17:
                  if (this.identityService) {
                    this.identityService.setWeb3Manager(this.web3Manager);
                  }

                case 18:
                  if (!this.solanaWeb3Config) {
                    _context.next = 22;
                    break;
                  }

                  this.solanaWeb3Manager = new SolanaWeb3Manager(this.solanaWeb3Config, this.identityService, this.web3Manager);
                  _context.next = 22;
                  return this.solanaWeb3Manager.init();

                case 22:
                  if (!(this.solanaWeb3Manager && this.solanaAudiusDataConfig)) {
                    _context.next = 26;
                    break;
                  }

                  this.solanaAudiusData = new SolanaAudiusData(this.solanaAudiusDataConfig, this.solanaWeb3Manager, this.web3Manager);
                  _context.next = 26;
                  return this.solanaAudiusData.init();

                case 26:
                  /** Contracts - Eth and Data Contracts */
                  contractsToInit = [];

                  if (this.ethWeb3Manager) {
                    this.ethContracts = new EthContracts(this.ethWeb3Manager, this.ethWeb3Config ? this.ethWeb3Config.tokenAddress : null, this.ethWeb3Config ? this.ethWeb3Config.registryAddress : null, this.ethWeb3Config && this.ethWeb3Config.claimDistributionContractAddress || null, this.ethWeb3Config && this.ethWeb3Config.wormholeContractAddress || null, this.isServer, this.logger, this.isDebug);
                    contractsToInit.push(this.ethContracts.init());
                  }

                  if (this.web3Manager) {
                    this.contracts = new AudiusContracts(this.web3Manager, this.web3Config ? this.web3Config.registryAddress : null, this.isServer, this.logger);
                    contractsToInit.push(this.contracts.init());
                  }

                  _context.next = 31;
                  return Promise.all(contractsToInit);

                case 31:
                  if (this.wormholeConfig && this.ethWeb3Manager && this.ethContracts && this.solanaWeb3Manager) {
                    this.wormholeClient = new Wormhole(this.hedgehog, this.ethWeb3Manager, this.ethContracts, this.identityService, this.solanaWeb3Manager, this.wormholeConfig.rpcHosts, this.wormholeConfig.solBridgeAddress, this.wormholeConfig.solTokenBridgeAddress, this.wormholeConfig.ethBridgeAddress, this.wormholeConfig.ethTokenBridgeAddress, this.isServer);
                  }
                  /** Discovery Provider */


                  if (!this.discoveryProviderConfig) {
                    _context.next = 37;
                    break;
                  }

                  this.discoveryProvider = new DiscoveryProvider(this.discoveryProviderConfig.whitelist, this.discoveryProviderConfig.blacklist, this.userStateManager, this.ethContracts, this.web3Manager, this.discoveryProviderConfig.reselectTimeout, this.discoveryProviderConfig.selectionCallback, this.discoveryProviderConfig.monitoringCallbacks, this.discoveryProviderConfig.selectionRequestTimeout, this.discoveryProviderConfig.selectionRequestRetries, this.discoveryProviderConfig.unhealthySlotDiffPlays, this.discoveryProviderConfig.unhealthyBlockDiff);
                  _context.next = 36;
                  return this.discoveryProvider.init();

                case 36:
                  if (typeof window !== 'undefined') {
                    this.oauth = new Oauth(this.discoveryProvider);
                  }

                case 37:
                  if (!this.creatorNodeConfig) {
                    _context.next = 43;
                    break;
                  }

                  currentUser = this.userStateManager.getCurrentUser();
                  creatorNodeEndpoint = currentUser ? CreatorNode.getPrimary(currentUser.creator_node_endpoint) || this.creatorNodeConfig.fallbackUrl : this.creatorNodeConfig.fallbackUrl;
                  this.creatorNode = new CreatorNode(this.web3Manager, creatorNodeEndpoint, this.isServer, this.userStateManager, this.creatorNodeConfig.lazyConnect, this.schemas, this.creatorNodeConfig.passList, this.creatorNodeConfig.blockList, this.creatorNodeConfig.monitoringCallbacks);
                  _context.next = 43;
                  return this.creatorNode.init();

                case 43:
                  /** Comstock */
                  if (this.comstockConfig) {
                    this.comstock = new Comstock(this.comstockConfig.url);
                  } // Initialize apis


                  services = [this.userStateManager, this.identityService, this.hedgehog, this.discoveryProvider, this.web3Manager, this.contracts, this.ethWeb3Manager, this.ethContracts, this.solanaWeb3Manager, this.anchorAudiusData, this.wormholeClient, this.creatorNode, this.comstock, this.captcha, this.isServer, this.logger];
                  this.ServiceProvider = _construct(ServiceProvider, services);
                  this.User = _construct(User, [this.ServiceProvider, this.preferHigherPatchForPrimary, this.preferHigherPatchForSecondaries].concat(services));
                  this.Account = _construct(Account, [this.User].concat(services));
                  this.Track = _construct(Track, services);
                  this.Playlist = _construct(Playlist, services);
                  this.File = _construct(File, [this.User].concat(services));
                  this.Rewards = _construct(Rewards, [this.ServiceProvider].concat(services));

                case 52:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function init() {
          return _init.apply(this, arguments);
        }

        return init;
      }()
    }], [{
      key: "configDiscoveryProvider",
      value:
      /**
       * Configures a discovery provider wrapper
       * @param {Set<string>?} whitelist whether or not to include only specified nodes (default no whitelist)
       * @param {Set<string>?} blacklist whether or not to exclude specified nodes (default no blacklist)
       * @param {number?} reselectTimeout timeout to clear locally cached discovery providers
       * @param {(selection: string) => void?} selectionCallback invoked with the select discovery provider
       * @param {object?} monitoringCallbacks callbacks to be invoked with metrics from requests sent to a service
       *  @param {function} monitoringCallbacks.request
       *  @param {function} monitoringCallbacks.healthCheck
       * @param {number?} selectionRequestTimeout the amount of time (ms) an individual request should take before reselecting
       * @param {number?} selectionRequestRetries the number of retries to a given discovery node we make before reselecting
       * @param {number?} unhealthySlotDiffPlays the number of slots we would consider a discovery node unhealthy
       * @param {number?} unhealthyBlockDiff the number of missed blocks after which we would consider a discovery node unhealthy
       */
      function configDiscoveryProvider() {
        var whitelist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var blacklist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var reselectTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var selectionCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var monitoringCallbacks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
        var selectionRequestTimeout = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
        var selectionRequestRetries = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
        var unhealthySlotDiffPlays = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
        var unhealthyBlockDiff = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
        return {
          whitelist: whitelist,
          blacklist: blacklist,
          reselectTimeout: reselectTimeout,
          selectionCallback: selectionCallback,
          monitoringCallbacks: monitoringCallbacks,
          selectionRequestTimeout: selectionRequestTimeout,
          selectionRequestRetries: selectionRequestRetries,
          unhealthySlotDiffPlays: unhealthySlotDiffPlays,
          unhealthyBlockDiff: unhealthyBlockDiff
        };
      }
      /**
       * Configures an identity service wrapper
       * @param {string} url
       * @param {boolean?} useHedgehogLocalStorage whether or not to read hedgehog entropy in local storage
       */

    }, {
      key: "configIdentityService",
      value: function configIdentityService(url) {
        var useHedgehogLocalStorage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return {
          url: url,
          useHedgehogLocalStorage: useHedgehogLocalStorage
        };
      }
      /**
       * Configures an identity service wrapper
       * @param {string} url
       */

    }, {
      key: "configComstock",
      value: function configComstock(url) {
        return {
          url: url
        };
      }
      /**
       * Configures a creator node wrapper
       * @param {string} fallbackUrl creator node endpoint to fall back to on requests
       * @param {boolean} lazyConnect whether to delay connection to the node until the first
       * request that requires a connection is made.
       * @param {Set<string>?} passList whether or not to include only specified nodes (default null)
       * @param {Set<string>?} blockList whether or not to exclude any nodes (default null)
       * @param {object?} monitoringCallbacks callbacks to be invoked with metrics from requests sent to a service
       * @param {function} monitoringCallbacks.request
       * @param {function} monitoringCallbacks.healthCheck
       */

    }, {
      key: "configCreatorNode",
      value: function configCreatorNode(fallbackUrl) {
        var lazyConnect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var passList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var blockList = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var monitoringCallbacks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
        return {
          fallbackUrl: fallbackUrl,
          lazyConnect: lazyConnect,
          passList: passList,
          blockList: blockList,
          monitoringCallbacks: monitoringCallbacks
        };
      }
      /**
       * Configures an external web3 to use with Audius Libs (e.g. MetaMask)
       * @param {string} registryAddress
       * @param {Object} web3Provider equal to web.currentProvider
       * @param {?number} networkId network chain id
       * @param {?string} walletOverride wallet address to force use instead of the first wallet on the provided web3
       * @param {?number} walletIndex if using a wallet returned from web3, pick the wallet at this index
       */

    }, {
      key: "configExternalWeb3",
      value: function () {
        var _configExternalWeb = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(registryAddress, web3Provider, networkId) {
          var walletOverride,
              web3Instance,
              wallets,
              _args2 = arguments;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  walletOverride = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : null;
                  _context2.next = 3;
                  return Utils.configureWeb3(web3Provider, networkId);

                case 3:
                  web3Instance = _context2.sent;

                  if (web3Instance) {
                    _context2.next = 6;
                    break;
                  }

                  throw new Error('External web3 incorrectly configured');

                case 6:
                  _context2.next = 8;
                  return web3Instance.eth.getAccounts();

                case 8:
                  wallets = _context2.sent;
                  return _context2.abrupt("return", {
                    registryAddress: registryAddress,
                    useExternalWeb3: true,
                    externalWeb3Config: {
                      web3: web3Instance,
                      ownerWallet: walletOverride || wallets[0]
                    }
                  });

                case 10:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        function configExternalWeb3(_x, _x2, _x3) {
          return _configExternalWeb.apply(this, arguments);
        }

        return configExternalWeb3;
      }()
      /**
       * Configures an internal web3 to use (via Hedgehog)
       * @param {string} registryAddress
       * @param {string | Web3 | Array<string>} providers web3 provider endpoint(s)
       */

    }, {
      key: "configInternalWeb3",
      value: function configInternalWeb3(registryAddress, providers, privateKey) {
        var providerList;

        if (typeof providers === 'string') {
          providerList = providers.split(',');
        } else if (providers instanceof Web3) {
          providerList = [providers];
        } else if (Array.isArray(providers)) {
          providerList = providers;
        } else {
          throw new Error('Providers must be of type string, Array, or Web3 instance');
        }

        return {
          registryAddress: registryAddress,
          useExternalWeb3: false,
          internalWeb3Config: {
            web3ProviderEndpoints: providerList,
            privateKey: privateKey
          }
        };
      }
      /**
       * Configures an eth web3
       * @param {string} tokenAddress
       * @param {string} registryAddress
       * @param {string | Web3 | Array<string>} providers web3 provider endpoint(s)
       * @param {string?} ownerWallet optional owner wallet to establish who we are sending transactions on behalf of
       * @param {string?} claimDistributionContractAddress
       * @param {string?} wormholeContractAddress
       */

    }, {
      key: "configEthWeb3",
      value: function configEthWeb3(tokenAddress, registryAddress, providers, ownerWallet, claimDistributionContractAddress, wormholeContractAddress) {
        var providerList;

        if (typeof providers === 'string') {
          providerList = providers.split(',');
        } else if (providers instanceof Web3) {
          providerList = [providers];
        } else if (Array.isArray(providers)) {
          providerList = providers;
        } else {
          throw new Error('Providers must be of type string, Array, or Web3 instance');
        }

        return {
          tokenAddress: tokenAddress,
          registryAddress: registryAddress,
          providers: providerList,
          ownerWallet: ownerWallet,
          claimDistributionContractAddress: claimDistributionContractAddress,
          wormholeContractAddress: wormholeContractAddress
        };
      }
      /**
       * Configures wormhole
       * @param {Object} config
       * @param {string | Array<string>} config.rpcHosts
       * @param {string} config.solBridgeAddress
       * @param {string} config.solTokenBridgeAddress
       * @param {string} config.ethBridgeAddress
       * @param {string} config.ethTokenBridgeAddress
       */

    }, {
      key: "configWormhole",
      value: function configWormhole(_ref2) {
        var rpcHosts = _ref2.rpcHosts,
            solBridgeAddress = _ref2.solBridgeAddress,
            solTokenBridgeAddress = _ref2.solTokenBridgeAddress,
            ethBridgeAddress = _ref2.ethBridgeAddress,
            ethTokenBridgeAddress = _ref2.ethTokenBridgeAddress;
        var rpcHostList;

        if (typeof rpcHosts === 'string') {
          rpcHostList = rpcHosts.split(',');
        } else if (Array.isArray(rpcHosts)) {
          rpcHostList = rpcHosts;
        } else {
          throw new Error('rpcHosts must be of type string or Array');
        }

        return {
          rpcHosts: rpcHostList,
          solBridgeAddress: solBridgeAddress,
          solTokenBridgeAddress: solTokenBridgeAddress,
          ethBridgeAddress: ethBridgeAddress,
          ethTokenBridgeAddress: ethTokenBridgeAddress
        };
      }
      /**
       * Configures a solana web3
       * @param {Object} config
       * @param {string} config.solanaClusterEndpoint the RPC endpoint to make requests against
       * @param {string} config.mintAddress wAudio mint address
       * @param {string} solanaTokenAddress native solana token program
       * @param {string} claimableTokenPDA the generated program derived address we use so our
       *  bank program can take ownership of accounts
       * @param {string} feePayerAddress address for the fee payer for transactions
       * @param {string} claimableTokenProgramAddress address of the audius user bank program
       * @param {string} rewardsManagerProgramId address for the Rewards Manager program
       * @param {string} rewardsManagerProgramPDA Rewards Manager PDA
       * @param {string} rewardsManagerTokenPDA The PDA of the rewards manager funds holder account
       * @param {boolean} useRelay Whether to use identity as a relay or submit transactions locally
       * @param {Uint8Array} feePayerSecretKeys fee payer secret keys, if client wants to switch between different fee payers during relay
       * @param {number} confirmationTimeout solana web3 connection confirmationTimeout in ms
       * @param {PublicKey|string} audiusDataAdminStorageKeypairPublicKey admin storage PK for audius-data program
       * @param {PublicKey|string} audiusDataProgramId program ID for the audius-data Anchor program
       * @param {Idl} audiusDataIdl IDL for the audius-data Anchor program.
       */

    }, {
      key: "configSolanaWeb3",
      value: function configSolanaWeb3(_ref3) {
        var solanaClusterEndpoint = _ref3.solanaClusterEndpoint,
            mintAddress = _ref3.mintAddress,
            solanaTokenAddress = _ref3.solanaTokenAddress,
            claimableTokenPDA = _ref3.claimableTokenPDA,
            feePayerAddress = _ref3.feePayerAddress,
            claimableTokenProgramAddress = _ref3.claimableTokenProgramAddress,
            rewardsManagerProgramId = _ref3.rewardsManagerProgramId,
            rewardsManagerProgramPDA = _ref3.rewardsManagerProgramPDA,
            rewardsManagerTokenPDA = _ref3.rewardsManagerTokenPDA,
            useRelay = _ref3.useRelay,
            feePayerSecretKeys = _ref3.feePayerSecretKeys,
            confirmationTimeout = _ref3.confirmationTimeout,
            audiusDataAdminStorageKeypairPublicKey = _ref3.audiusDataAdminStorageKeypairPublicKey,
            audiusDataProgramId = _ref3.audiusDataProgramId,
            audiusDataIdl = _ref3.audiusDataIdl;

        if (audiusDataAdminStorageKeypairPublicKey instanceof String) {
          audiusDataAdminStorageKeypairPublicKey = new PublicKey(audiusDataAdminStorageKeypairPublicKey);
        }

        if (audiusDataProgramId instanceof String) {
          audiusDataProgramId = new PublicKey(audiusDataProgramId);
        }

        return {
          solanaClusterEndpoint: solanaClusterEndpoint,
          mintAddress: mintAddress,
          solanaTokenAddress: solanaTokenAddress,
          claimableTokenPDA: claimableTokenPDA,
          feePayerAddress: feePayerAddress,
          claimableTokenProgramAddress: claimableTokenProgramAddress,
          rewardsManagerProgramId: rewardsManagerProgramId,
          rewardsManagerProgramPDA: rewardsManagerProgramPDA,
          rewardsManagerTokenPDA: rewardsManagerTokenPDA,
          useRelay: useRelay,
          feePayerKeypairs: feePayerSecretKeys ? feePayerSecretKeys.map(function (key) {
            return Keypair.fromSecretKey(key);
          }) : null,
          confirmationTimeout: confirmationTimeout,
          audiusDataAdminStorageKeypairPublicKey: audiusDataAdminStorageKeypairPublicKey,
          audiusDataProgramId: audiusDataProgramId,
          audiusDataIdl: audiusDataIdl
        };
      }
      /**
       * Configures a solana audius-data
       * @param {Object} config
       * @param {string} config.programId Program ID of the audius data program
       * @param {string} config.adminAccount Public Key of admin account
       */

    }, {
      key: "configSolanaAudiusData",
      value: function configSolanaAudiusData(_ref4) {
        var programId = _ref4.programId,
            adminAccount = _ref4.adminAccount;
        return {
          programId: programId,
          adminAccount: adminAccount
        };
      }
    }]);

    return AudiusLibs;
  }(); // This is needed to ensure default and named exports are handled correctly by rollup
  // https://github.com/rollup/plugins/tree/master/packages/commonjs#defaultismoduleexports


  exports.__esModule = true;
  module.exports = AudiusLibs;
  module.exports.AudiusABIDecoder = AudiusABIDecoder;
  module.exports.Utils = Utils;
  module.exports.SolanaUtils = SolanaUtils;
  module.exports.SanityChecks = SanityChecks;
  module.exports.RewardsAttester = RewardsAttester;
  module.exports.CreatorNode = CreatorNode;
})(src, src.exports);

var index = /*@__PURE__*/getDefaultExportFromCjs(src.exports);

module.exports = index;
//# sourceMappingURL=index.js.map
